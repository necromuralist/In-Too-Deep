<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#">
<head>
<meta charset="utf-8">
<meta content="An exercise in Transfer Learning." name="description">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>Transfer Learning Exercise | In Too Deep</title>
<link href="../../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="../../../../assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="../../../../assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta content="#5670d4" name="theme-color">
<meta content="Nikola (getnikola.com)" name="generator">
<link href="../../../../rss.xml" rel="alternate" title="RSS" type="application/rss+xml">
<link href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/transfer-learning-exercise/" rel="canonical"><!--[if lt IE 9]><script src="../../../../assets/js/html5.js"></script><![endif]-->
<link href="../../../../apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180">
<link href="../../../../favicon-32x32.png" rel="icon" sizes="32x32" type="image/png">
<link href="../../../../favicon-16x16.png" rel="icon" sizes="16x16" type="image/png">
<link href="../../../../site.webmanifest" rel="manifest">
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
<script async src="../../../assets/javascript/bokeh-1.3.4.min.js" type="text/javascript"></script>
<meta content="Cloistered Monkey" name="author">
<link href="/posts/nano/cnn/convolutional-layers-in-pytorch/" rel="prev" title="Convolutional Layers in PyTorch" type="text/html">
<link href="/posts/nano/cnn/weight-initialization/" rel="next" title="Weight Initialization" type="text/html">
<meta content="In Too Deep" property="og:site_name">
<meta content="Transfer Learning Exercise" property="og:title">
<meta content="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/transfer-learning-exercise/" property="og:url">
<meta content="An exercise in Transfer Learning." property="og:description">
<meta content="article" property="og:type">
<meta content="2018-12-15T14:50:47-08:00" property="article:published_time">
<meta content="cnn" property="article:tag">
<meta content="exercise" property="article:tag">
<meta content="transfer learning" property="article:tag">
</head>
<body>
<a class="sr-only sr-only-focusable" href="#content">Skip to main content</a> <!-- Menubar -->
<nav class="navbar navbar-expand-md static-top mb-4 navbar-light bg-light">
<div class="container"><!-- This keeps the margins nice -->
 <a class="navbar-brand" href="https://necromuralist.github.io/In-Too-Deep/"><span id="blog-title">In Too Deep</span></a> <button aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-target="#bs-navbar" data-toggle="collapse" type="button"><span class="navbar-toggler-icon"></span></button>
<div class="collapse navbar-collapse" id="bs-navbar">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="/archive.html">Archive</a></li>
<li class="nav-item"><a class="nav-link" href="/categories/">Tags</a></li>
<li class="nav-item"><a class="nav-link" href="/rss.xml">RSS feed</a></li>
<li class="nav-item"><a class="nav-link" href="https://necromuralist.github.io/">Cloistered Monkey</a></li>
</ul>
<!-- Google custom search -->
<form action="https://www.google.com/search" class="navbar-form navbar-right" method="get" role="search">
<div class="form-group"><input class="form-control" name="q" placeholder="Search" type="text"></div>
<!-- 
<button type="submit" class="btn btn-primary">
        <span class="glyphicon glyphicon-search"></span>
</button>
-->
<input name="sitesearch" type="hidden" value="https://necromuralist.github.io/In-Too-Deep/"></form>
<!-- End of custom search -->
<ul class="navbar-nav navbar-right">
<li class="nav-item"><a class="nav-link" href="/posts/nano/cnn/transfer-learning-exercise/index.org" id="sourcelink">Source</a></li>
</ul>
</div>
<!-- /.navbar-collapse --></div>
<!-- /.container --></nav>
<!-- End of Menubar -->
<div class="container" id="content" role="main">
<div class="body-content"><!--Body content-->
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title" itemprop="headline name"><a class="u-url" href="/posts/nano/cnn/transfer-learning-exercise/">Transfer Learning Exercise</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="/posts/nano/cnn/transfer-learning-exercise/" rel="bookmark"><time class="published dt-published" datetime="2018-12-15T14:50:47-08:00" itemprop="datePublished" title="2018-12-15 14:50">2018-12-15 14:50</time></a></p>
<p class="sourceline"><a class="sourcelink" href="/posts/nano/cnn/transfer-learning-exercise/index.org">Source</a></p>
</div>
</header>
<div class="e-content entry-content" itemprop="articleBody text">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="/posts/nano/cnn/transfer-learning-exercise/#org070a187">Introduction</a></li>
<li><a href="/posts/nano/cnn/transfer-learning-exercise/#orgb0d2aa6">Imports</a></li>
<li><a href="/posts/nano/cnn/transfer-learning-exercise/#org81e5a67">Flower power</a></li>
<li><a href="/posts/nano/cnn/transfer-learning-exercise/#org00198a6">Download the Data</a></li>
<li><a href="/posts/nano/cnn/transfer-learning-exercise/#org223b2e1">Transforming the Data</a></li>
<li><a href="/posts/nano/cnn/transfer-learning-exercise/#orgc2c1669">DataLoaders and Data Visualization</a></li>
<li><a href="/posts/nano/cnn/transfer-learning-exercise/#org783a98e">Visualize some sample data</a></li>
<li><a href="/posts/nano/cnn/transfer-learning-exercise/#orgefa47f0">Plot The Images In The Batch, Along With The Corresponding Labels</a></li>
<li><a href="/posts/nano/cnn/transfer-learning-exercise/#org1b37663">Define the Model</a></li>
<li><a href="/posts/nano/cnn/transfer-learning-exercise/#orgf6e3be9">Final Classifier Layer</a></li>
<li><a href="/posts/nano/cnn/transfer-learning-exercise/#org20d7575">Specify Loss Function and Optimizer</a></li>
<li><a href="/posts/nano/cnn/transfer-learning-exercise/#orgf14c475">Training</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org070a187">
<h2 id="org070a187">Introduction</h2>
<div class="outline-text-2" id="text-org070a187">
<p>Most of the time you won't want to train a whole convolutional network yourself. Modern ConvNets training on huge datasets like ImageNet take weeks on multiple GPUs. Instead, most people use a pretrained network either as a fixed feature extractor, or as an initial network to fine tune.</p>
<p>In this notebook, you'll be using <a href="https://arxiv.org/pdf/1409.1556.pdf">VGGNet</a> trained on the <a href="http://www.image-net.org/">ImageNet dataset</a> as a feature extractor.</p>
<p>VGGNet is great because it's simple and has great performance, coming in second in the ImageNet competition. The idea here is that we keep all the convolutional layers, but <b>replace the final fully-connected layer</b> with our own classifier. This way we can use VGGNet as a <b>fixed feature extractor</b> for our images then easily train a simple classifier on top of that.</p>
<ul class="org-ul">
<li>Use all but the last fully-connected layer as a fixed feature extractor.</li>
<li>Define a new, final classification layer and apply it to a task of our choice!</li>
</ul>
<p>You can read more about transfer learning from <a href="http://cs231n.github.io/transfer-learning/">the CS231n Stanford course notes</a>.</p>
</div>
</div>
<div class="outline-2" id="outline-container-orgb0d2aa6">
<h2 id="orgb0d2aa6">Imports</h2>
<div class="outline-text-2" id="text-orgb0d2aa6">
<div class="highlight">
<pre><span></span># python
from collections import OrderedDict
from datetime import datetime
import os

# pypi
from dotenv import load_dotenv
from torch import nn
from sklearn.model_selection import train_test_split
from torch.utils.data.sampler import SubsetRandomSampler

import matplotlib
import numpy
import seaborn
import torch
import torch.optim as optimize
import torchvision
from torchvision import datasets, models, transforms
import matplotlib.pyplot as pyplot

# this project
from neurotic.tangles.data_paths import DataPathTwo
</pre></div>
</div>
<div class="outline-3" id="outline-container-org45d01a1">
<h3 id="org45d01a1">Plotting</h3>
<div class="outline-text-3" id="text-org45d01a1">
<div class="highlight">
<pre><span></span>get_ipython().run_line_magic('matplotlib', 'inline')
get_ipython().run_line_magic('config', "InlineBackend.figure_format = 'retina'")
seaborn.set(style="whitegrid",
            rc={"axes.grid": False,
                "font.size": 8,
                "font.family": ["sans-serif"],
                "font.sans-serif": ["Latin Modern Sans", "Lato"],
                "figure.figsize": (8, 6)},
            font_scale=3)
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org81e5a67">
<h2 id="org81e5a67">Flower power</h2>
<div class="outline-text-2" id="text-org81e5a67">
<p>Here we'll be using VGGNet to classify images of flowers. We'll start, as usual, by importing our usual resources. And checking if we can train our model on the GPU.</p>
</div>
</div>
<div class="outline-2" id="outline-container-org00198a6">
<h2 id="org00198a6">Download the Data</h2>
<div class="outline-text-2" id="text-org00198a6">
<p>Download the flower data from <a href="https://s3.amazonaws.com/video.udacity-data.com/topher/2018/September/5baa60a0_flower-photos/flower-photos.zip">this link</a>, save it in the home directory of this notebook and extract the zip file to get the directory <code>flower_photos/</code>. <b>Make sure the directory has this exact name for accessing data: flower_photos</b>.</p>
<div class="highlight">
<pre><span></span>load_dotenv()
path = DataPathTwo(folder_key="FLOWERS")
print(path.folder)
for target in path.folder.iterdir():
    print(target)
</pre></div>
<pre class="example">
/home/hades/datasets/flower_photos
/home/hades/datasets/flower_photos/.DS_Store
/home/hades/datasets/flower_photos/train
/home/hades/datasets/flower_photos/test
/home/hades/datasets/flower_photos/LICENSE.txt

</pre></div>
<div class="outline-3" id="outline-container-org385b384">
<h3 id="org385b384">Check If CUDA Is Available</h3>
<div class="outline-text-3" id="text-org385b384">
<div class="highlight">
<pre><span></span>device = "cuda:0" if torch.cuda.is_available() else "cpu"
print(device)
</pre></div>
<pre class="example">
cuda:0

</pre>
<p>CUDA is running out of memory and crashing so don't use CUDA.</p>
<div class="highlight">
<pre><span></span>device = "cpu"
print(device)
</pre></div>
<pre class="example">
cpu

</pre></div>
</div>
<div class="outline-3" id="outline-container-orgf09c0c9">
<h3 id="orgf09c0c9">Load and Transform our Data</h3>
<div class="outline-text-3" id="text-orgf09c0c9">
<p>We'll be using PyTorch's <a href="https://pytorch.org/docs/stable/torchvision/datasets.html#imagefolder">ImageFolder</a> class which makes is very easy to load data from a directory. For example, the training images are all stored in a directory path that looks like this:</p>
<pre class="example">
root/class_1/xxx.png
root/class_1/xxy.png
root/class_1/xxz.png

root/class_2/123.png
root/class_2/nsdf3.png
root/class_2/asd932_.png
</pre>
<p>Where, in this case, the root folder for training is <code>flower_photos/train/</code> and the classes are the names of flower types.</p>
</div>
</div>
<div class="outline-3" id="outline-container-org6766a59">
<h3 id="org6766a59">Define Training and Test Data Directories</h3>
<div class="outline-text-3" id="text-org6766a59">
<div class="highlight">
<pre><span></span>train_dir = path.folder.joinpath('train/')
test_dir = path.folder.joinpath('test/')
print(train_dir)
print(test_dir)
</pre></div>
<pre class="example">
/home/hades/datasets/flower_photos/train
/home/hades/datasets/flower_photos/test

</pre>
<p><i>Classes</i> are folders in each directory with these names:</p>
<div class="highlight">
<pre><span></span>classes = ['daisy', 'dandelion', 'roses', 'sunflowers', 'tulips']
CLASS_COUNT = len(classes)
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org223b2e1">
<h2 id="org223b2e1">Transforming the Data</h2>
<div class="outline-text-2" id="text-org223b2e1">
<p>When we perform transfer learning, we have to shape our input data into the shape that the pre-trained model expects. VGG16 expects `224`-dim square images as input and so, we resize each flower image to fit this mold.</p>
</div>
<div class="outline-3" id="outline-container-org6f0ca6b">
<h3 id="org6f0ca6b">Load And Transform Data Using ImageFolder</h3>
<div class="outline-text-3" id="text-org6f0ca6b">
<p>VGG-16 Takes 224x224 images as input, so we resize all of them.</p>
<div class="highlight">
<pre><span></span>data_transform = transforms.Compose([transforms.RandomResizedCrop(224), 
                                      transforms.ToTensor()])

train_data = datasets.ImageFolder(train_dir, transform=data_transform)
test_data = datasets.ImageFolder(test_dir, transform=data_transform)
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org9c566c8">
<h3 id="org9c566c8">Print Out Some Data Stats</h3>
<div class="outline-text-3" id="text-org9c566c8">
<div class="highlight">
<pre><span></span>print('Num training images: ', len(train_data))
print('Num test images: ', len(test_data))
</pre></div>
<pre class="example">
Num training images:  3130
Num test images:  540

</pre>
<div class="highlight">
<pre><span></span>VALIDATION_FRACTION = 0.2
</pre></div>
<div class="highlight">
<pre><span></span>indices = list(range(len(train_data)))
training_indices, validation_indices = train_test_split(
    indices,
    test_size=VALIDATION_FRACTION)
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgc2c1669">
<h2 id="orgc2c1669">DataLoaders and Data Visualization</h2>
<div class="outline-text-2" id="text-orgc2c1669"></div>
<div class="outline-3" id="outline-container-org2d6b2a5">
<h3 id="org2d6b2a5">Define Dataloader Parameters</h3>
<div class="outline-text-3" id="text-org2d6b2a5">
<div class="highlight">
<pre><span></span>BATCH_SIZE = 20
NUM_WORKERS=4
</pre></div>
<div class="highlight">
<pre><span></span>train_sampler = SubsetRandomSampler(training_indices)
valid_sampler = SubsetRandomSampler(validation_indices)
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgfd4b253">
<h3 id="orgfd4b253">Prepare Data Loaders</h3>
<div class="outline-text-3" id="text-orgfd4b253">
<div class="highlight">
<pre><span></span>train_loader = torch.utils.data.DataLoader(train_data, batch_size=BATCH_SIZE, 
                                           sampler=train_sampler,
                                           num_workers=NUM_WORKERS)
valid_loader = torch.utils.data.DataLoader(train_data, batch_size=BATCH_SIZE, 
                                           sampler=valid_sampler, num_workers=NUM_WORKERS)
test_loader = torch.utils.data.DataLoader(test_data, batch_size=batch_size, 
                                          num_workers=num_workers, shuffle=True)
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org783a98e">
<h2 id="org783a98e">Visualize some sample data</h2>
<div class="outline-text-2" id="text-org783a98e"></div>
<div class="outline-3" id="outline-container-org252acac">
<h3 id="org252acac">obtain one batch of training images</h3>
<div class="outline-text-3" id="text-org252acac">
<div class="highlight">
<pre><span></span>dataiter = iter(train_loader)
images, labels = dataiter.next()
images = images.numpy() # convert images to numpy for display
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgefa47f0">
<h2 id="orgefa47f0">Plot The Images In The Batch, Along With The Corresponding Labels</h2>
<div class="outline-text-2" id="text-orgefa47f0">
<div class="highlight">
<pre><span></span>fig = pyplot.figure(figsize=(12, 10))
pyplot.rc("axes", titlesize=10)
for idx in numpy.arange(20):
    ax = fig.add_subplot(2, 20/2, idx+1, xticks=[], yticks=[])
    pyplot.imshow(numpy.transpose(images[idx], (1, 2, 0)))
    ax.set_title(classes[labels[idx]])
</pre></div>
<div class="figure">
<p><img alt="sample_batches.png" src="/posts/nano/cnn/transfer-learning-exercise/sample_batches.png"></p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org1b37663">
<h2 id="org1b37663">Define the Model</h2>
<div class="outline-text-2" id="text-org1b37663">
<p>To define a model for training we'll follow these steps:</p>
<ol class="org-ol">
<li>Load in a pre-trained VGG16 model</li>
<li>"Freeze" all the parameters, so the net acts as a fixed feature extractor</li>
<li>Remove the last layer</li>
<li>Replace the last layer with a linear classifier of our own</li>
</ol>
<p>/Freezing simply means that the parameters in the pre-trained model will <b>not</b> change during training.**</p>
<p>Load the pretrained model from pytorch</p>
<div class="highlight">
<pre><span></span>vgg16 = models.vgg16(pretrained=True)
</pre></div>
<p>Print Out The Model Structure</p>
<div class="highlight">
<pre><span></span>print(vgg16)
</pre></div>
<pre class="example">
VGG(
  (features): Sequential(
    (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (1): ReLU(inplace)
    (2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (3): ReLU(inplace)
    (4): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (5): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (6): ReLU(inplace)
    (7): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (8): ReLU(inplace)
    (9): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (10): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (11): ReLU(inplace)
    (12): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (13): ReLU(inplace)
    (14): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (15): ReLU(inplace)
    (16): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (17): Conv2d(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (18): ReLU(inplace)
    (19): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (20): ReLU(inplace)
    (21): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (22): ReLU(inplace)
    (23): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (24): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (25): ReLU(inplace)
    (26): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (27): ReLU(inplace)
    (28): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (29): ReLU(inplace)
    (30): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  )
  (classifier): Sequential(
    (0): Linear(in_features=25088, out_features=4096, bias=True)
    (1): ReLU(inplace)
    (2): Dropout(p=0.5)
    (3): Linear(in_features=4096, out_features=4096, bias=True)
    (4): ReLU(inplace)
    (5): Dropout(p=0.5)
    (6): Linear(in_features=4096, out_features=1000, bias=True)
  )
)
</pre>
<p>Since we're only going to change the last (classification) layer, it might be helpful to see how many inputs and outpts it has.</p>
<div class="highlight">
<pre><span></span>print(vgg16.classifier[6].in_features) 
print(vgg16.classifier[6].out_features) 
</pre></div>
<pre class="example">
4096
1000

</pre>
<p>So, the original model output 1,000 classes - we're going to need to change that to our five classes (eventually).</p>
<p>Freeze training for all "features" layers</p>
<div class="highlight">
<pre><span></span>for param in vgg16.features.parameters():
    param.requires_grad = False
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-orgf6e3be9">
<h2 id="orgf6e3be9">Final Classifier Layer</h2>
<div class="outline-text-2" id="text-orgf6e3be9">
<p>Once you have the pre-trained feature extractor, you just need to modify and/or add to the final, fully-connected classifier layers. In this case, we suggest that you replace the last layer in the vgg classifier group of layers.</p>
<p>This layer should see as input the number of features produced by the portion of the network that you are not changing, and produce an appropriate number of outputs for the flower classification task.</p>
<p>You can access any layer in a pretrained network by name and (sometimes) number, i.e. <code>vgg16.classifier[6]</code> is the sixth layer in a group of layers named "classifier".</p>
<div class="highlight">
<pre><span></span>classifier = nn.Sequential(OrderedDict([
    ("Fullly Connected Classifier", nn.Linear(in_features=4096, out_features=CLASS_COUNT, bias=True)),
]))
vgg16.classifier[6] = classifier
</pre></div>
<p>after completing your model, if GPU is available, move the model to GPU</p>
<div class="highlight">
<pre><span></span>vgg16.to(device)
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-org20d7575">
<h2 id="org20d7575">Specify <a href="http://pytorch.org/docs/stable/nn.html#loss-functions">Loss Function</a> and <a href="http://pytorch.org/docs/stable/optim.html">Optimizer</a></h2>
<div class="outline-text-2" id="text-org20d7575">
<p>Below we'll use cross-entropy loss and stochastic gradient descent with a small learning rate. Note that the optimizer accepts as input <i>only</i> the trainable parameters <code>vgg.classifier.parameters()</code>.</p>
</div>
<div class="outline-3" id="outline-container-org2f01ad4">
<h3 id="org2f01ad4">Specify Loss Function (Categorical Cross-Entropy)</h3>
<div class="outline-text-3" id="text-org2f01ad4">
<div class="highlight">
<pre><span></span>criterion = nn.CrossEntropyLoss()
</pre></div>
<p>specify optimizer (stochastic gradient descent) and learning rate = 0.001</p>
<div class="highlight">
<pre><span></span>optimizer = optimize.SGD(vgg16.classifier.parameters(), lr=0.001)
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgf14c475">
<h2 id="orgf14c475">Training</h2>
<div class="outline-text-2" id="text-orgf14c475">
<p>Here, we'll train the network.</p>
<p><b>Exercise:</b> So far we've been providing the training code for you. Here, I'm going to give you a bit more of a challenge and have you write the code to train the network. Of course, you'll be able to see my solution if you need help.</p>
<p>number of epochs to train the model</p>
<div class="highlight">
<pre><span></span>n_epochs = EPOCHS = 2
def train(model: nn.Module, epochs: int=EPOCHS, model_number: int=0,
          epoch_offset: int=1, print_every: int=10) -&gt; tuple:
    """Train, validate, and save the model
    This trains the model and validates it, saving the best 
    (based on validation loss) as =model_&lt;number&gt;_cifar.pth=

    Args:
     model: the network to train
     epochs: number of times to repeat training
     model_number: an identifier for the saved hyperparameters file
     epoch_offset: amount of epochs that have occurred previously
     print_every: how often to print output
    Returns:
     filename, training-loss, validation-loss, improvements: the outcomes for the training
    """
    optimizer = optimize.SGD(model.parameters(), lr=0.001)
    criterion = nn.CrossEntropyLoss()
    output_file = "model_{}_vgg.pth".format(model_number)
    training_losses = []
    validation_losses = []
    improvements = []
    valid_loss_min = numpy.Inf # track change in validation loss
    epoch_start = epoch_offset
    last_epoch = epoch_start + epochs + 1
    for epoch in range(epoch_start, last_epoch):

        # keep track of training and validation loss
        train_loss = 0.0
        valid_loss = 0.0

        model.train()
        for data, target in train_loader:
            # move tensors to GPU if CUDA is available            
            data, target = data.to(device), target.to(device)
            # clear the gradients of all optimized variables
            optimizer.zero_grad()
            # forward pass: compute predicted outputs by passing inputs to the model
            output = model(data)
            # calculate the batch loss
            loss = criterion(output, target)
            # backward pass: compute gradient of the loss with respect to model parameters
            loss.backward()
            # perform a single optimization step (parameter update)
            optimizer.step()
            # update training loss
            train_loss += loss.item() * data.size(0)

        model.eval()
        for data, target in valid_loader:
            # move tensors to GPU if CUDA is available
            data, target = data.to(device), target.to(device)
            # forward pass: compute predicted outputs by passing inputs to the model
            output = model(data)
            # calculate the batch loss
            loss = criterion(output, target)
            # update total validation loss 
            valid_loss += loss.item() * data.size(0)

        # calculate average losses
        train_loss = train_loss/len(train_loader.dataset)
        valid_loss = valid_loss/len(valid_loader.dataset)

        # print training/validation statistics 
        if not (epoch % print_every):
            print('Epoch: {} \tTraining Loss: {:.6f} \tValidation Loss: {:.6f}'.format(
                epoch, train_loss, valid_loss))
        training_losses.append(train_loss)
        validation_losses.append(valid_loss)
        # save model if validation loss has decreased
        if valid_loss &lt;= valid_loss_min:
            print('Validation loss decreased ({:.6f} --&gt; {:.6f}).  Saving model ...'.format(
            valid_loss_min,
            valid_loss))
            torch.save(model.state_dict(), output_file)
            valid_loss_min = valid_loss
            improvements.append(epoch - 1)
    return output_file, training_losses, validation_losses, improvements
</pre></div>
<div class="highlight">
<pre><span></span>def test(best_model):
    criterion = nn.CrossEntropyLoss()
    # track test loss
    test_loss = 0.0
    class_correct = list(0. for i in range(10))
    class_total = list(0. for i in range(10))

    best_model.to(device)
    best_model.eval()
    # iterate over test data
    for data, target in test_loader:
        # move tensors to GPU if CUDA is available
        data, target = data.to(device), target.to(device)
        # forward pass: compute predicted outputs by passing inputs to the model
        output = best_model(data)
        # calculate the batch loss
        loss = criterion(output, target)
        # update test loss 
        test_loss += loss.item() * data.size(0)
        # convert output probabilities to predicted class
        _, pred = torch.max(output, 1)    
        # compare predictions to true label
        correct_tensor = pred.eq(target.data.view_as(pred))
        correct = (
            numpy.squeeze(correct_tensor.numpy())
            if not train_on_gpu
            else numpy.squeeze(correct_tensor.cpu().numpy()))
        # calculate test accuracy for each object class
        for i in range(BATCH_SIZE):
            label = target.data[i]
            class_correct[label] += correct[i].item()
            class_total[label] += 1

    # average test loss
    test_loss = test_loss/len(test_loader.dataset)
    print('Test Loss: {:.6f}\n'.format(test_loss))

    for i in range(10):
        if class_total[i] &gt; 0:
            print('Test Accuracy of %5s: %2d%% (%2d/%2d)' % (
                classes[i], 100 * class_correct[i] / class_total[i],
                numpy.sum(class_correct[i]), numpy.sum(class_total[i])))
        else:
            print('Test Accuracy of %5s: N/A (no training examples)' % (classes[i]))

    print('\nTest Accuracy (Overall): %2d%% (%2d/%2d)' % (
        100. * numpy.sum(class_correct) / numpy.sum(class_total),
        numpy.sum(class_correct), numpy.sum(class_total)))
</pre></div>
<div class="highlight">
<pre><span></span>output_file, training_losses, validation_losses, improvements = train(vgg16, print_every=1)
</pre></div>
<div class="highlight">
<pre><span></span>training_losses = []
validation_losses = []
improvements = []
valid_loss_min = numpy.Inf # track change in validation loss
for epoch in range(1, 3):

    # keep track of training and validation loss
    train_loss = 0.0
    valid_loss = 0.0

    vgg16.train()
    for data, target in train_loader:
        # move tensors to GPU if CUDA is available            
        data, target = data.to(device), target.to(device)
        # clear the gradients of all optimized variables
        optimizer.zero_grad()
        # forward pass: compute predicted outputs by passing inputs to the model
        output = vgg16(data)
        # calculate the batch loss
        loss = criterion(output, target)
        # backward pass: compute gradient of the loss with respect to model parameters
        loss.backward()
        # perform a single optimization step (parameter update)
        optimizer.step()
        # update training loss
        train_loss += loss.item() * data.size(0)

    vgg16.eval()
    for data, target in valid_loader:
        # move tensors to GPU if CUDA is available
        data, target = data.to(device), target.to(device)
        # forward pass: compute predicted outputs by passing inputs to the model
        output = vgg16(data)
        # calculate the batch loss
        loss = criterion(output, target)
        # update total validation loss 
        valid_loss += loss.item() * data.size(0)

    # calculate average losses
    train_loss = train_loss/len(train_loader.dataset)
    valid_loss = valid_loss/len(valid_loader.dataset)

    # print training/validation statistics 
    print('Epoch: {} \tTraining Loss: {:.6f} \tValidation Loss: {:.6f}'.format(
        epoch, train_loss, valid_loss))
    training_losses.append(train_loss)
    validation_losses.append(valid_loss)
    # save model if validation loss has decreased
    if valid_loss &lt;= valid_loss_min:
        print('Validation loss decreased ({:.6f} --&gt; {:.6f}).  Saving model ...'.format(
        valid_loss_min,
        valid_loss))
        torch.save(vgg16.state_dict(), output_file)
        valid_loss_min = valid_loss
        improvements.append(epoch - 1)
</pre></div>
<p>test_loss = 0.0 class_correct = list(0. for i in range(5)) class_total = list(0. for i in range(5))</p>
<p>vgg16.eval() # eval mode</p>
<p>for data, target in test_loader:</p>
<p>if train_on_gpu: data, target = data.cuda(), target.cuda()</p>
<p>output = vgg16(data)</p>
<p>loss = criterion(output, target)</p>
<p>test_loss += loss.item()*data.size(0)</p>
<p>_, pred = torch.max(output, 1)</p>
<p>correct_tensor = pred.eq(target.data.view_as(pred)) correct = np.squeeze(correct_tensor.numpy()) if not train_on_gpu else np.squeeze(correct_tensor.cpu().numpy())</p>
<p>for i in range(batch_size): label = target.data[i] class_correct[label] += correct[i].item() class_total[label] += 1</p>
<p>test_loss = test_loss/len(test_loader.dataset) print('Test Loss: {:.6f}\n'.format(test_loss))</p>
<p>for i in range(5): if class_total[i] &gt; 0: print('Test Accuracy of %5s: %2d%% (%2d/%2d)' % ( classes[i], 100 * class_correct[i] / class_total[i], np.sum(class_correct[i]), np.sum(class_total[i]))) else: print('Test Accuracy of %5s: N/A (no training examples)' % (classes[i]))</p>
<p>print('\nTest Accuracy (Overall): %2d%% (%2d/%2d)' % (</p>
<ol class="org-ol">
<li>* np.sum(class_correct) / np.sum(class_total),</li>
</ol>
<p>np.sum(class_correct), np.sum(class_total)))</p>
<p>dataiter = iter(test_loader) images, labels = dataiter.next() images.numpy()</p>
<p>if train_on_gpu: images = images.cuda()</p>
<p>output = vgg16(images)</p>
<p>_, preds_tensor = torch.max(output, 1) preds = np.squeeze(preds_tensor.numpy()) if not train_on_gpu else np.squeeze(preds_tensor.cpu().numpy())</p>
<p>fig = plt.figure(figsize=(25, 4)) for idx in np.arange(20): ax = fig.add_subplot(2, 20/2, idx+1, xticks=[], yticks=[]) plt.imshow(np.transpose(images[idx], (1, 2, 0))) ax.set_title("{} ({})".format(classes[preds[idx]], classes[labels[idx]]), color=("green" if preds[idx]==labels[idx].item() else "red"))</p>
</div>
</div>
</div>
<aside class="postpromonav">
<nav>
<ul class="tags" itemprop="keywords">
<li><a class="tag p-category" href="/categories/cnn/" rel="tag">cnn</a></li>
<li><a class="tag p-category" href="/categories/exercise/" rel="tag">exercise</a></li>
<li><a class="tag p-category" href="/categories/transfer-learning/" rel="tag">transfer learning</a></li>
</ul>
<ul class="pager hidden-print">
<li class="previous"><a href="/posts/nano/cnn/convolutional-layers-in-pytorch/" rel="prev" title="Convolutional Layers in PyTorch">Previous post</a></li>
<li class="next"><a href="/posts/nano/cnn/weight-initialization/" rel="next" title="Weight Initialization">Next post</a></li>
</ul>
</nav>
</aside>
</article>
<!--End of body content-->
<footer id="footer">Contents © 2020 <a href="mailto:necromuralist@protonmail.com">Cloistered Monkey</a> - Powered by <a href="https://getnikola.com" rel="nofollow">Nikola</a></footer>
</div>
</div>
<script src="/assets/js/all-nocdn.js"></script>
<script>

    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
</script> 
</body>
</html>
