#+BEGIN_COMMENT
.. title: Siamese Networks: Evaluating the Model
.. slug: siamese-networks-evaluating-the-model
.. date: 2021-01-25 19:39:59 UTC-08:00
.. tags: 
.. category: 
.. link: 
.. description: 
.. type: text

#+END_COMMENT
* Raw
#+begin_example python
# # Part 4:  Evaluation  
# 
# <a name='4.1'></a>
# 
# ### 4.1 Evaluating your siamese network
# 
# In this section you will learn how to evaluate a Siamese network. You will first start by loading a pretrained model and then you will use it to predict. 

# In[ ]:


# Loading in the saved model
model = Siamese()
model.init_from_file('model.pkl.gz')


# <a name='4.2'></a>
# ### 4.2 Classify
# To determine the accuracy of the model, we will utilize the test set that was configured earlier. While in training we used only positive examples, the test data, Q1_test, Q2_test and y_test, is setup as pairs of questions, some of which are duplicates some are not. 
# This routine will run all the test question pairs through the model, compute the cosine simlarity of each pair, threshold it and compare the result to  y_test - the correct response from the data set. The results are accumulated to produce an accuracy.
# 
# 
# <a name='ex05'></a>
# ### Exercise 05
# 
# **Instructions**  
#  - Loop through the incoming data in batch_size chunks
#  - Use the data generator to load q1, q2 a batch at a time. **Don't forget to set shuffle=False!**
#  - copy a batch_size chunk of y into y_test
#  - compute v1, v2 using the model
#  - for each element of the batch
#         - compute the cos similarity of each pair of entries, v1[j],v2[j]
#         - determine if d > threshold
#         - increment accuracy if that result matches the expected results (y_test[j])
#  - compute the final accuracy and return
#  
# Due to some limitations of this environment, running classify multiple times may result in the kernel failing. If that happens *Restart Kernal & clear output* and then run from the top. During development, consider using a smaller set of data to reduce the number of calls to model(). 

# In[ ]:


# UNQ_C5 (UNIQUE CELL IDENTIFIER, DO NOT EDIT)
# GRADED FUNCTION: classify
def classify(test_Q1, test_Q2, y, threshold, model, vocab, data_generator=data_generator, batch_size=64):
    """Function to test the accuracy of the model.

    Args:
        test_Q1 (numpy.ndarray): Array of Q1 questions.
        test_Q2 (numpy.ndarray): Array of Q2 questions.
        y (numpy.ndarray): Array of actual target.
        threshold (float): Desired threshold.
        model (trax.layers.combinators.Parallel): The Siamese model.
        vocab (collections.defaultdict): The vocabulary used.
        data_generator (function): Data generator function. Defaults to data_generator.
        batch_size (int, optional): Size of the batches. Defaults to 64.

    Returns:
        float: Accuracy of the model.
    """
    accuracy = 0
    ### START CODE HERE (Replace instances of 'None' with your code) ###
    for i in range(0, len(test_Q1), batch_size):
        # Call the data generator (built in Ex 01) with shuffle=False using next()
        # use batch size chuncks of questions as Q1 & Q2 arguments of the data generator. e.g x[i:i + batch_size]
        # Hint: use `vocab['<PAD>']` for the `pad` argument of the data generator
        q1, q2 = None
        # use batch size chuncks of actual output targets (same syntax as example above)
        y_test = None
        # Call the model
        v1, v2 = None

        for j in range(batch_size):
            # take dot product to compute cos similarity of each pair of entries, v1[j], v2[j]
            # don't forget to transpose the second argument
            d = None
            # is d greater than the threshold?
            res = None
            # increment accurancy if y_test is equal `res`
            accuracy += None
    # compute accuracy using accuracy and total length of test questions
    accuracy = None
    ### END CODE HERE ###
    
    return accuracy


# In[ ]:


# this takes around 1 minute
accuracy = classify(Q1_test,Q2_test, y_test, 0.7, model, vocab, batch_size = 512) 
print("Accuracy", accuracy)


# **Expected Result**  
# Accuracy ~0.69

# <a name='5'></a>
# 

#+end_example  
