#+BEGIN_COMMENT
.. title: Classes and Subclasses
.. slug: classes-and-subclasses
.. date: 2020-12-20 21:13:13 UTC-08:00
.. tags: nlp,python,object-oriented programming
.. category: NLP
.. link: 
.. description: A review of classes and subclases in python.
.. type: text

#+END_COMMENT
#+OPTIONS: ^:{}
#+TOC: headlines 3
#+PROPERTY: header-args :session ~/.local/share/jupyter/runtime/kernel-cfe36b62-8d66-4503-9c19-11e8c6ffdb6e-ssh.json
#+BEGIN_SRC python :results none :exports none
%load_ext autoreload
%autoreload 2
#+END_SRC
* Classes and Subclasses
 In this notebook, I will show you the basics of classes and subclasses in Python. As you've seen in the lectures from this week, `Trax` uses layer classes as building blocks for deep learning models, so it is important to understand how classes and subclasses behave in order to be able to build custom layers when needed. 
 
 By completing this notebook, you will:
 
 - Be able to define classes and subclasses in Python
 - Understand how inheritance works in subclasses
 - Be able to work with instances

** Imports
#+begin_src python :results none
# from pypi
from expects import (
    equal,
    expect,
    raise_error
)
import attr
#+end_src
* Middle
** Part 1: Parameters, methods and instances
First, let's define a class =SomeClass=. 

#+begin_src python :results none
class SomeClass:
    x = None
#+end_src

=SomeClass=  has one parameter =x= without any value. You can think of parameters as the variables that every object assigned to a class will have. So, at this point, any object of class =My_Class= would have a variable =x= equal to =None=. To check this,  I'll create two instances of that class and get the value of =x= for both of them.

#+begin_src python :results output :exports both
instance_a= SomeClass()
instance_b= SomeClass()
print(f"Parameter x of instance_a: {instance_a.x}")
print(f"Parameter x of instance_b: {(instance_b.x)}")
#+end_src

#+RESULTS:
: Parameter x of instance_a: None
: Parameter x of instance_b: None

For an existing instance you can assign new values for any of its parameters. In the next cell, assign a value of =5= to the parameter =x= of =instance_a=.

#+begin_src python :results output :exports both
instance_a.x = 5
print(f"Parameter x of instance_a: {instance_a.x}")
#+end_src

#+RESULTS:
: Parameter x of instance_a: 5
*** The =__init__= method

When you want to assign values to the parameters of your class when an instance is created, it is necessary to define a special method: `__init__`. The `__init__` method is called when you create an instance of a class. It can have multiple arguments to initialize the paramenters of your instance. In the next cell I will define `My_Class` with an `__init__` method that takes the instance (`self`) and an argument `y` as inputs.

#+begin_src python :results none
@attr.s(auto_attribs=True)
class SomeClass: 
    x: int=None
#+end_src

#+begin_src python :results output :exports both
instance_c = SomeClass(10)
print(f"{instance_c}")
#+end_src

#+RESULTS:
: SomeClass(x=10)

*** The =__call__= method

Another important method is the =__call__= method. It is performed whenever you call an initialized instance of a class. It can have multiple arguments and you can define it to do whatever you want like

 - Change a parameter, 
 - Print a message,
 - Create new variables, etc.

#+begin_src python :results none
@attr.s(auto_attribs=True)
class SomeClass:
    x: int
    
    def __call__(self, z: int):
        self.x += z
        print(self.x)
#+end_src

#+begin_src python :results none
instance_d = SomeClass(5)
#+end_src

 And now, see what happens when =instance_d= is called with argument =10=.

#+begin_src python :results output :exports both
instance_d(10)
#+end_src

#+RESULTS:
: 15

Now, you are ready to complete the following cell so any instance from =SomeClass=:
 - Is initialized taking two arguments =y= and =z= and assigns them to =x_1= and =x_2=, respectively. And, 
 - When called, takes the values of the parameters =x_1= and =x_2=, sums them, prints  and returns the result.

#+begin_src python :results none
@attr.s(auto_attribs=True)
class SomeClass: 
    x_1: int
    x_2: int

    def __call__(self) -> int:
        result = self.x_1 + self.x_2 
        print(f"Addition of {self.x_1} and {self.x_2} is {result}")
        return result
#+end_src

Run the next cell to check your implementation. If everything is correct, you shouldn't get any errors.

#+begin_src python :results output :exports both
instance_e = SomeClass(x_1=10, x_2=15)

def test_class_definition():    
    expect(instance_e.x_1).to(equal(10))
    expect(instance_e.x_2).to(equal(15))
    expect(instance_e()).to(equal(25))
    return
    
test_class_definition()
#+end_src

#+RESULTS:
: Addition of 10 and 15 is 25

*** Custom methods

 In addition to the =__init__= and =__call__= methods, your classes can have custom-built methods to do whatever you want when called. To define a custom method, you have to indicate its input arguments, the instructions that you want it to perform and the values to return (if any). In the next cell, =My_Class= is defined with =my_method= that multiplies the values of =x_1= and =x_2=, sums that product with an input =w=, and returns the result.

#+begin_src python :results none
@attr.s(auto_attribs=True)
class SomeClass:
    x_1: int
    x_2: int
     
    def __call__(self) -> int:
        return self.x_1 - 2 * self.x_2 

    def some_method(self, w: int) -> int:
        return self.x_1 * self.x_2 + w
#+end_src

Create an instance =instance_f= of =My_Class= with any integer values that you want for =x_1= and =x_2=. For that instance, see the result of calling =My_method=, with an argument =w= equal to =16=.

#+begin_src python :results output :exports both
instance_f = SomeClass(1, 10)
print(f"Output of some_method: {instance_f.some_method(16)}")
#+end_src

#+RESULTS:
: Output of some_method: 26

As you can corroborate in the previous cell, to call a custom method =m=, with arguments =args=, for an instance =i= you must write =i.m(args)=. With that in mind, methods can call others within a class. In the following cell, try to define =new_method= which calls =my_method= with =v= as input argument. Try to do this on your own in the cell given below.

#+begin_src python :results none
@attr.s(auto_attribs=True)
class SomeClass: 
    x_1: int = None
    x_2: int = None

    def __call__(self) -> int:
        return self.x_1 - 2 * self.x_2 

    def some_method(self, w: int) -> int:
        return self.x_1 * self.x_2 + w

    def some_new_method(self, v: int) -> int:
        return self.some_method(v)
#+end_src

#+begin_src python :results output :exports both
instance_g = SomeClass(1, 10)
print(f"Output of some_method: {instance_g.some_method(16)}")
print(f"Output of some_new_method: {instance_g.some_new_method(16)}")
#+end_src

#+RESULTS:
: Output of some_method: 26
: Output of some_new_method: 26

** Part 2: Subclasses and Inheritance

=Trax= uses classes and subclasses to define layers. The base class in =Trax= is =layer=, which means that every layer from a deep learning model is defined as a subclass of the =layer= class. In this part of the notebook, you are going to see how subclasses work. To define a subclass =sub= from class =super=, you have to write =class sub(super):= and define any method and parameter that you want for your subclass. In the next cell, I define =sub_c= as a subclass of =My_Class= with only one method (=additional_method=).


#+begin_src python :results none
class SomeSub(SomeClass):
    def additional_method(self):
        print(self.x_1)
        return
#+end_src

*** Inheritance

 When you define a subclass =sub=, every method and parameter is inherited from =super= class, including the =__init__= and =__call__= methods. This means that any instance from =sub= can use the methods defined in =super=.  Run the following cell and see for yourself.

#+begin_src python :results output :exports both
instance_sub_a = SomeSub(1, 10)
print(f"Parameter x_1 of instance_sub_a: {instance_sub_a.x_1}")
print(f"Parameter x_2 of instance_sub_a: {instance_sub_a.x_2}")
print(f"Output of some_method of instance_sub_a: {instance_sub_a.some_method(16)}")
#+end_src

#+RESULTS:
: Parameter x_1 of instance_sub_a: 1
: Parameter x_2 of instance_sub_a: 10
: Output of my_method of instance_sub_a: 26

 As you can see, =sub_c= does not have an initialization method =__init__=, it is inherited from =My_class=. However, you can overwrite any method you want by defining it again in the subclass. For instance, in the next cell define a class =sub_c= with a redefined =my_Method= that multiplies =x_1= and =x_2= but does not add any additional argument.

#+begin_src python :results none
@attr.s(auto_attribs=True)
class SomeSub(SomeClass):
    def some_method(self):
        return self.x_1 * self.x_2 
#+end_src

To check your implementation run the following cell.

#+begin_src python :results output :exports both
test = SomeSub(3, 10)
actual = test.some_method()
expect(actual).to(equal(30))

print(f"Output of overridden my_method of test: {actual}")

def bad_call():
    test.some_method(16)
    
expect(bad_call).to(raise_error(TypeError))
#+end_src

#+RESULTS:
: Output of overridden my_method of test: 30

 In the next cell, two instances are created, one of =My_Class= and another one of =sub_c=. The instances are initialized with equal =x_1= and =x_2= parameters.

#+begin_src python :results output :exports both
y, z= 1, 10
instance_sub_a = SomeSub(y,z)
instance_a = SomeClass(y,z)
print(f"My_method for an instance of sub_c returns: {instance_sub_a.some_method()}")
print(f"My_method for an instance of My_Class returns: {instance_a.some_method(10)}")
#+end_src

#+RESULTS:
: My_method for an instance of sub_c returns: 10
: My_method for an instance of My_Class returns: 20

 As you can see, even though =sub_c= is a subclass from =My_Class= and both instances are initialized with the same values, =My_method= returns different results for each instance because you overwrote =My_method= for =sub_c=.

