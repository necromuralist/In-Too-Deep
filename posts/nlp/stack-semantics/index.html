<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>Stack Semantics | Neurotic Networking</title>
<link href="../../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta content="#5670d4" name="theme-color">
<meta content="Nikola (getnikola.com)" name="generator">
<link href="../../../rss.xml" hreflang="en" rel="alternate" title="RSS" type="application/rss+xml">
<link href="https://necromuralist.github.io/Neurotic-Networking/posts/nlp/stack-semantics/" rel="canonical"><!--[if lt IE 9]><script src="../../../assets/js/html5.js"></script><![endif]-->
<link href="../../../apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180">
<link href="../../../favicon-32x32.png" rel="icon" sizes="32x32" type="image/png">
<link href="../../../favicon-16x16.png" rel="icon" sizes="16x16" type="image/png">
<link href="../../../site.webmanifest" rel="manifest">
<meta content="Cloistered Monkey" name="author">
<link href="../bleu-score/" rel="prev" title="Bleu Score" type="text/html">
<link href="../neural-machine-translation/" rel="next" title="Neural Machine Translation" type="text/html">
<meta content="Neurotic Networking" property="og:site_name">
<meta content="Stack Semantics" property="og:title">
<meta content="https://necromuralist.github.io/Neurotic-Networking/posts/nlp/stack-semantics/" property="og:url">
<meta content="Table of Contents Stack Semantics in Trax Imports Middle The Serial Combinator is Stack Oriented. Defining addition Defining multiplication Implementing the computations using the Serial combin" property="og:description">
<meta content="article" property="og:type">
<meta content="2021-02-11T19:53:36-08:00" property="article:published_time">
<meta content="nlp" property="article:tag">
</head>
<body>
<a class="sr-only sr-only-focusable" href="#content">Skip to main content</a> <!-- Menubar -->
<nav class="navbar navbar-expand-md static-top mb-4 navbar-light bg-light">
<div class="container"><!-- This keeps the margins nice -->
 <a class="navbar-brand" href="../../../"><span id="blog-title">Neurotic Networking</span></a> <button aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-target="#bs-navbar" data-toggle="collapse" type="button"><span class="navbar-toggler-icon"></span></button>
<div class="collapse navbar-collapse" id="bs-navbar">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="../../../archive.html">Archive</a></li>
<li class="nav-item"><a class="nav-link" href="../../../categories/">Tags</a></li>
<li class="nav-item"><a class="nav-link" href="../../../rss.xml">RSS feed</a></li>
<li class="nav-item"><a class="nav-link" href="https://necromuralist.github.io/">Cloistered Monkey</a></li>
</ul>
<!-- Google custom search -->
<form action="https://www.google.com/search" class="navbar-form navbar-right" method="get" role="search">
<div class="form-group"><input class="form-control" name="q" placeholder="Search" type="text"></div>
<!-- 
<button type="submit" class="btn btn-primary">
        <span class="glyphicon glyphicon-search"></span>
</button>
-->
<input name="sitesearch" type="hidden" value="https://necromuralist.github.io/Neurotic-Networking/"></form>
<!-- End of custom search -->
<ul class="navbar-nav navbar-right">
<li class="nav-item"><a class="nav-link" href="index.org" id="sourcelink">Source</a></li>
</ul>
</div>
<!-- /.navbar-collapse --></div>
<!-- /.container --></nav>
<!-- End of Menubar -->
<div class="container" id="content" role="main">
<div class="body-content"><!--Body content-->
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title" itemprop="headline name"><a class="u-url" href=".">Stack Semantics</a></h1>
<div class="metadata">
<p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="." rel="bookmark"><time class="published dt-published" datetime="2021-02-11T19:53:36-08:00" itemprop="datePublished" title="2021-02-11 19:53">2021-02-11 19:53</time></a></p>
<p class="sourceline"><a class="sourcelink" href="index.org">Source</a></p>
</div>
</header>
<div class="e-content entry-content" itemprop="articleBody text">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org02a0ea4">Stack Semantics in Trax</a>
<ul>
<li><a href="#orgc69595a">Imports</a></li>
</ul>
</li>
<li><a href="#orgd17a421">Middle</a>
<ul>
<li><a href="#org885d93a">The Serial Combinator is Stack Oriented.</a>
<ul>
<li><a href="#orga09181a">Defining addition</a></li>
<li><a href="#orge4b8c63">Defining multiplication</a></li>
<li><a href="#org84deea6">Implementing the computations using the Serial combinator</a></li>
</ul>
</li>
<li><a href="#orgccc4c51">The tl.Select combinator in the context of the Serial combinator</a>
<ul>
<li><a href="#org68a8471">First example of tl.Select</a></li>
<li><a href="#org7f94067">Select Makes It More Like a Collection</a></li>
</ul>
</li>
<li><a href="#org214ed63">Another example of tl.Select</a></li>
<li><a href="#orgc86fae9">The tl.Residual combinator in the context of the Serial combinator</a>
<ul>
<li><a href="#orge6f8a01">tl.Residual</a></li>
<li><a href="#org4bba641">Modifying the network</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org02a0ea4">
<h2 id="org02a0ea4">Stack Semantics in Trax</h2>
<div class="outline-text-2" id="text-org02a0ea4">
<p>This will help in understanding how to use layers like <code>Select</code> and <code>Residual</code> which operate on elements in the stack. If you've taken a computer science class before, you will recall that a stack is a data structure that follows the Last In, First Out (LIFO) principle. That is, whatever is the latest element that is pushed into the stack will also be the first one to be popped out. If you're not yet familiar with stacks, then you may find this <a href="https://www.tutorialspoint.com/python_data_structure/python_stack.htm">short tutorial</a> useful. In a nutshell, all you really need to remember is it puts elements one on top of the other. You should be aware of what is on top of the stack to know which element you will be popping.</p>
</div>
<div class="outline-3" id="outline-container-orgc69595a">
<h3 id="orgc69595a">Imports</h3>
<div class="outline-text-3" id="text-orgc69595a">
<div class="highlight">
<pre><span></span><span class="c1"># pypi</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">trax</span> <span class="kn">import</span> <span class="n">fastmath</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">shapes</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgd17a421">
<h2 id="orgd17a421">Middle</h2>
<div class="outline-text-2" id="text-orgd17a421"></div>
<div class="outline-3" id="outline-container-org885d93a">
<h3 id="org885d93a">The Serial Combinator is Stack Oriented.</h3>
<div class="outline-text-3" id="text-org885d93a">
<p>To understand how stack-orientation works in <a href="https://trax-ml.readthedocs.io/en/latest/">Trax</a>, most times one will be using the <code>Serial</code> layer. We will define two simple <a href="https://trax-ml.readthedocs.io/en/latest/notebooks/layers_intro.html?highlight=fn#With-the-Fn-layer-creating-function.">Function layers</a>:</p>
<ol class="org-ol">
<li>Addition</li>
<li>Multiplication</li>
</ol>
<p>Suppose we want to make the simple calculation \((3 + 4) \times 15 + 3\). We'll use <code>Serial</code> to perform the calculations in the following order <code>3</code> <code>4</code> <code>add</code> <code>15</code> <code>mul</code> <code>3</code> <code>add</code>. The steps of the calculation are shown in the table below.</p>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Stack Operations</th>
<th class="org-right" scope="col">Stack</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Push(4)</td>
<td class="org-right">4</td>
</tr>
<tr>
<td class="org-left">Push(3)</td>
<td class="org-right">4 3</td>
</tr>
<tr>
<td class="org-left">Push(Add Pop() Pop())</td>
<td class="org-right">7</td>
</tr>
<tr>
<td class="org-left">Push(15)</td>
<td class="org-right">7 15</td>
</tr>
<tr>
<td class="org-left">Push(Mul Pop() Pop())</td>
<td class="org-right">105</td>
</tr>
<tr>
<td class="org-left">Push(3)</td>
<td class="org-right">105 3</td>
</tr>
<tr>
<td class="org-left">Push(Add() Pop() Pop())</td>
<td class="org-right">108</td>
</tr>
</tbody>
</table>
<p>The first column shows the operations made on the stack and the second column is what's on the stack. Moreover, the rightmost element in the second column represents the top of the stack (e.g. in the second row, <code>Push(3)</code> pushes <code>3 = on top of the stack and =4</code> is now under it).</p>
<p>After finishing the steps the stack contains 108 which is the answer to our simple computation.</p>
<p>From this, the following can be concluded: a stack-based layer has only one way to handle data, by taking one piece of data from atop the stack, called <i>popping</i>, and putting data back atop the stack, called <i>pushing</i>. Any expression that can be written conventionally, can be written this way and thus will be amenable to being interpreted by a stack-oriented layer like <code>Serial</code>.</p>
</div>
<div class="outline-4" id="outline-container-orga09181a">
<h4 id="orga09181a">Defining addition</h4>
<div class="outline-text-4" id="text-orga09181a">
<p>We're going to define a trax <a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html?highlight=Fn#trax.layers.base.Fn">function (FN)</a> for addition.</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">Addition</span><span class="p">():</span>
    <span class="n">layer_name</span> <span class="o">=</span> <span class="s2">"Addition"</span> 

    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

    <span class="k">return</span> <span class="n">layers</span><span class="o">.</span><span class="n">Fn</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
</pre></div>
<p>Test it out.</p>
<div class="highlight">
<pre><span></span><span class="n">add</span> <span class="o">=</span> <span class="n">Addition</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">add</span><span class="p">))</span>
</pre></div>
<pre class="example">
&lt;class 'trax.layers.base.PureLayer'&gt;
</pre>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">"name :"</span><span class="p">,</span> <span class="n">add</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"expected inputs :"</span><span class="p">,</span> <span class="n">add</span><span class="o">.</span><span class="n">n_in</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"promised outputs :"</span><span class="p">,</span> <span class="n">add</span><span class="o">.</span><span class="n">n_out</span><span class="p">)</span>
</pre></div>
<pre class="example">
name : Addition
expected inputs : 2
promised outputs : 1
</pre>
<div class="highlight">
<pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">add</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<pre class="example">
[3] + [4] = [7]
</pre></div>
</div>
<div class="outline-4" id="outline-container-orge4b8c63">
<h4 id="orge4b8c63">Defining multiplication</h4>
<div class="outline-text-4" id="text-orge4b8c63">
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">Multiplication</span><span class="p">():</span>
    <span class="n">layer_name</span> <span class="o">=</span> <span class="s2">"Multiplication"</span>

    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>

    <span class="k">return</span> <span class="n">layers</span><span class="o">.</span><span class="n">Fn</span><span class="p">(</span><span class="n">layer_name</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
</pre></div>
<p>Test it out.</p>
<div class="highlight">
<pre><span></span><span class="n">mul</span> <span class="o">=</span> <span class="n">Multiplication</span><span class="p">()</span>
</pre></div>
<p>The properties.</p>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">"name :"</span><span class="p">,</span> <span class="n">mul</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"expected inputs :"</span><span class="p">,</span> <span class="n">mul</span><span class="o">.</span><span class="n">n_in</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"promised outputs :"</span><span class="p">,</span> <span class="n">mul</span><span class="o">.</span><span class="n">n_out</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<pre class="example">
name : Multiplication
expected inputs : 2
promised outputs : 1 

</pre>
<p>Some Inputs.</p>
<div class="highlight">
<pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">7</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">15</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"x :"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"y :"</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
<pre class="example">
x : [7]
y : [15]
</pre>
<p>The Output</p>
<div class="highlight">
<pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">mul</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> * </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">mul</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<pre class="example">
[7] * [15] = [105]
</pre></div>
</div>
<div class="outline-4" id="outline-container-org84deea6">
<h4 id="org84deea6">Implementing the computations using the Serial combinator</h4>
<div class="outline-text-4" id="text-org84deea6">
<div class="highlight">
<pre><span></span><span class="n">serial</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Serial</span><span class="p">(</span>
    <span class="n">Addition</span><span class="p">(),</span> <span class="n">Multiplication</span><span class="p">(),</span> <span class="n">Addition</span><span class="p">()</span>
<span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">15</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span>

<span class="n">serial</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">shapes</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">inputs</span><span class="p">))</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"name :"</span><span class="p">,</span> <span class="n">serial</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"sublayers :"</span><span class="p">,</span> <span class="n">serial</span><span class="o">.</span><span class="n">sublayers</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"expected inputs :"</span><span class="p">,</span> <span class="n">serial</span><span class="o">.</span><span class="n">n_in</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"promised outputs :"</span><span class="p">,</span> <span class="n">serial</span><span class="o">.</span><span class="n">n_out</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<pre class="example" id="org67036b8">
Serial_in4[
  Addition_in2
  Multiplication_in2
  Addition_in2
] 

name : Serial
sublayers : [Addition_in2, Multiplication_in2, Addition_in2]
expected inputs : 4
promised outputs : 1 
</pre>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">inputs</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">serial</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<pre class="example">
(array([3]), array([4]), array([15]), array([3])) -&gt; [108]
</pre>
<p>The example with the two simple adition and multiplication functions that where coded together with the serial combinator show how stack semantics work in <code>Trax</code>.</p>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orgccc4c51">
<h3 id="orgccc4c51">The tl.Select combinator in the context of the Serial combinator</h3>
<div class="outline-text-3" id="text-orgccc4c51">
<p>Having understood how stack semantics work in <code>Trax</code>, we will demonstrate how the <a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html?highlight=select#trax.layers.combinators.Select">tl.Select</a> combinator works.</p>
</div>
<div class="outline-4" id="outline-container-org68a8471">
<h4 id="org68a8471">First example of tl.Select</h4>
<div class="outline-text-4" id="text-org68a8471">
<p>Suppose we want to make the simple calculation \((3 + 4) \times 3 + 4\). We can use <code>Select</code> to perform the calculations in the following manner:</p>
<ol class="org-ol">
<li>input <code>3</code> <code>4</code></li>
<li><code>tl.Select([0, 1, 0, 1])</code></li>
<li><code>add</code></li>
<li><code>mul</code></li>
<li><code>add</code>.</li>
</ol>
<p>The <code>tl.Select</code> requires a list or tuple of 0-based indices to select elements relative to the top of the stack. For our example, the top of the stack is <code>3</code> (which is at index 0) then <code>4</code> (index 1) and we us Select to copy the top two elements of the stack and then push all four elements back onto the stack which after the command executes will now contain <code>3</code> <code>4</code> <code>3</code> <code>4</code>. The steps of the calculation for our example are shown in the table below. As in the previous table each column shows the contents of the stack and the outputs after the operations are carried out.</p>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left">
<col class="org-left"></colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Stack Operations</th>
<th class="org-left" scope="col">Stack</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Push(4)</td>
<td class="org-left">4</td>
</tr>
<tr>
<td class="org-left">Push(3)</td>
<td class="org-left">4 3</td>
</tr>
<tr>
<td class="org-left">Push(Select([0, 1, 0, 1]))</td>
<td class="org-left">4 3 4 3</td>
</tr>
<tr>
<td class="org-left">Push(Add Pop() Pop())</td>
<td class="org-left">4 3 7</td>
</tr>
<tr>
<td class="org-left">Push(Mul Pop() Pop())</td>
<td class="org-left">4 21</td>
</tr>
<tr>
<td class="org-left">Push(Add Pop() Pop())</td>
<td class="org-left">25</td>
</tr>
</tbody>
</table>
<p>After processing all the inputs the stack contains 25 which is the result of the calculations.</p>
<div class="highlight">
<pre><span></span><span class="n">serial</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Serial</span><span class="p">(</span>
    <span class="n">layers</span><span class="o">.</span><span class="n">Select</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
    <span class="n">Addition</span><span class="p">(),</span>
    <span class="n">Multiplication</span><span class="p">(),</span>
    <span class="n">Addition</span><span class="p">()</span>
<span class="p">)</span>
</pre></div>
<p>Now we'll create the input.</p>
<div class="highlight">
<pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">]))</span>
<span class="n">serial</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">shapes</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"name :"</span><span class="p">,</span> <span class="n">serial</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"sublayers :"</span><span class="p">,</span> <span class="n">serial</span><span class="o">.</span><span class="n">sublayers</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"expected inputs :"</span><span class="p">,</span> <span class="n">serial</span><span class="o">.</span><span class="n">n_in</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"promised outputs :"</span><span class="p">,</span> <span class="n">serial</span><span class="o">.</span><span class="n">n_out</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<pre class="example" id="org39720ba">
Serial_in2[
  Select[0,1,0,1]_in2_out4
  Addition_in2
  Multiplication_in2
  Addition_in2
] 

name : Serial
sublayers : [Select[0,1,0,1]_in2_out4, Addition_in2, Multiplication_in2, Addition_in2]
expected inputs : 2
promised outputs : 1 
</pre>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">serial</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<pre class="example">
(array([3]), array([4])) -&gt; [25]
</pre></div>
</div>
<div class="outline-4" id="outline-container-org7f94067">
<h4 id="org7f94067">Select Makes It More Like a Collection</h4>
<div class="outline-text-4" id="text-org7f94067">
<p>Note that since you are passing in indices to Select, you aren't really using it like a stack, even if behind the scenes it's using push and pop.</p>
<div class="highlight">
<pre><span></span><span class="n">serial</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Serial</span><span class="p">(</span>
    <span class="n">layers</span><span class="o">.</span><span class="n">Select</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span>
    <span class="n">Addition</span><span class="p">(),</span>
    <span class="n">Multiplication</span><span class="p">(),</span>
    <span class="n">Addition</span><span class="p">()</span>
<span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">]))</span>
<span class="n">serial</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">shapes</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">serial</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<pre class="example">
(array([3]), array([4]), array([5])) -&gt; [41]
</pre>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">((</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
<pre class="example">
41
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org214ed63">
<h3 id="org214ed63">Another example of tl.Select</h3>
<div class="outline-text-3" id="text-org214ed63">
<p>Suppose we want to make the simple calculation \((3 + 4) \times 4\). We can use <code>Select</code> to perform the calculations in the following manner:</p>
<ol class="org-ol">
<li><code>4</code></li>
<li><code>3</code></li>
<li><code>tl.Select([0,1,0,1])</code></li>
<li><code>add</code></li>
<li><code>tl.Select([0], n_in=2)</code></li>
<li><code>mul</code></li>
</ol>
<p>The example is a bit contrived but it demonstrates the flexibility of the command. The second <code>tl.Select</code> pops two elements (specified in n_in) from the stack starting from index 0 (i.e. top of the stack). This means that <code>7</code> and <code>3 = will be popped out because ~n_in = 2~) but only =7</code> is placed back on top because it only selects <code>[0]</code>. As in the previous table each column shows the contents of the stack and the outputs after the operations are carried out.</p>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left">
<col class="org-left"></colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Stack Operations</th>
<th class="org-left" scope="col">Outputs</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Push(4)</td>
<td class="org-left">4</td>
</tr>
<tr>
<td class="org-left">Push(3)</td>
<td class="org-left">4 3</td>
</tr>
<tr>
<td class="org-left">Push(select([0, 1, 0, 1]))</td>
<td class="org-left">4 3 4 3</td>
</tr>
<tr>
<td class="org-left">Push(Add Pop() Pop())</td>
<td class="org-left">4 3 7</td>
</tr>
<tr>
<td class="org-left">Push(select([0], n_in=2))</td>
<td class="org-left">7</td>
</tr>
<tr>
<td class="org-left">Push(Mul Pop() Pop())</td>
<td class="org-left">28</td>
</tr>
</tbody>
</table>
<p>After processing all the inputs the stack contains 28 which is the answer we get above.</p>
<div class="highlight">
<pre><span></span><span class="n">serial</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Serial</span><span class="p">(</span>
    <span class="n">layers</span><span class="o">.</span><span class="n">Select</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
    <span class="n">Addition</span><span class="p">(),</span>
    <span class="n">layers</span><span class="o">.</span><span class="n">Select</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">n_in</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
    <span class="n">Multiplication</span><span class="p">()</span>
<span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">inputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">]))</span>
<span class="n">serial</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">shapes</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">inputs</span><span class="p">))</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"name :"</span><span class="p">,</span> <span class="n">serial</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"sublayers :"</span><span class="p">,</span> <span class="n">serial</span><span class="o">.</span><span class="n">sublayers</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"expected inputs :"</span><span class="p">,</span> <span class="n">serial</span><span class="o">.</span><span class="n">n_in</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"promised outputs :"</span><span class="p">,</span> <span class="n">serial</span><span class="o">.</span><span class="n">n_out</span><span class="p">)</span>
</pre></div>
<pre class="example" id="org89e6e27">
Serial_in2[
  Select[0,1,0,1]_in2_out4
  Addition_in2
  Select[0]_in2
  Multiplication_in2
] 

name : Serial
sublayers : [Select[0,1,0,1]_in2_out4, Addition_in2, Select[0]_in2, Multiplication_in2]
expected inputs : 2
promised outputs : 1
</pre>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">inputs</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">serial</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<pre class="example">
(array([3]), array([4])) -&gt; [28]
</pre>
<p>In summary, what Select does in this example is make a copy of the inputs in order to be used further along in the stack of operations.</p>
</div>
</div>
<div class="outline-3" id="outline-container-orgc86fae9">
<h3 id="orgc86fae9">The tl.Residual combinator in the context of the Serial combinator</h3>
<div class="outline-text-3" id="text-orgc86fae9"></div>
<div class="outline-4" id="outline-container-orge6f8a01">
<h4 id="orge6f8a01">tl.Residual</h4>
<div class="outline-text-4" id="text-orge6f8a01">
<p><a href="https://arxiv.org/pdf/1512.03385.pdf">Residual networks</a> (that link is to a research paper, this is <a href="https://en.wikipedia.org/wiki/Residual_neural_network">wikipedia</a>)are frequently used to make deep models easier to train. Trax already has a built in layer for this. The <a href="https://trax-ml.readthedocs.io/en/latest/trax.layers.html?highlight=residual#trax.layers.combinators.Residual">Residual layer</a> computes the element-wise <b>sum</b> of the <b>stack-top</b> input with the output of the layer series. Let's first see how it is used in the code below:</p>
<div class="highlight">
<pre><span></span><span class="n">serial</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Serial</span><span class="p">(</span>
    <span class="n">layers</span><span class="o">.</span><span class="n">Select</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
    <span class="n">layers</span><span class="o">.</span><span class="n">Residual</span><span class="p">(</span><span class="n">Addition</span><span class="p">())</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"name :"</span><span class="p">,</span> <span class="n">serial</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"expected inputs :"</span><span class="p">,</span> <span class="n">serial</span><span class="o">.</span><span class="n">n_in</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"promised outputs :"</span><span class="p">,</span> <span class="n">serial</span><span class="o">.</span><span class="n">n_out</span><span class="p">)</span>
</pre></div>
<pre class="example" id="org10fb53d">
Serial_in2_out3[
  Select[0,1,0,1]_in2_out4
  Serial_in2[
    Branch_in2_out2[
      None
      Addition_in2
    ]
    Add_in2
  ]
] 

name : Serial
expected inputs : 2
promised outputs : 3
</pre>
<p>Here, we use the Serial combinator to define our model. The inputs first goes through a <code>Select</code> layer, followed by a <code>Residual</code> layer which passes the <code>Fn: Addition()</code> layer as an argument. What this means is the <code>Residual</code> layer will take the stack top input at that point and add it to the output of the <code>Fn: Addition()</code> layer. You can picture it like the diagram the below, where <code>x1</code> and <code>x2</code> are the inputs to the model:</p>
<p>Now, let's try running our model with some sample inputs and see the result:</p>
<div class="highlight">
<pre><span></span><span class="n">x1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">x1</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="n">x2</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">serial</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<pre class="example">
[3] + [4] -&gt; (array([10]), array([3]), array([4]))
</pre>
<p>As you can see, the <code>Residual</code> layer remembers the stack top input (i.e. <code>3</code>) and adds it to the result of the <code>Fn: Addition()</code> layer (i.e. <code>3 + 4 = 7</code>). The output of <code>Residual(Addition()</code> is then <code>3 + 7 = 10</code> and is pushed onto the stack.</p>
<p>On a different note, you'll notice that the <code>Select</code> layer has 4 outputs but the <code>Fn: Addition()</code> layer only pops 2 inputs from the stack. This means the duplicate inputs (i.e. the 2 rightmost arrows of the <code>Select</code> outputs in the figure above) remain in the stack. This is why you still see it in the output of our simple serial network (i.e. <code>array([3]), array([4])</code>). This is useful if you want to use these duplicate inputs in another layer further down the network.</p>
</div>
</div>
<div class="outline-4" id="outline-container-org4bba641">
<h4 id="org4bba641">Modifying the network</h4>
<div class="outline-text-4" id="text-org4bba641">
<p>To strengthen your understanding, you can modify the network above and examine the outputs you get. For example, you can pass the <code>Fn: Multiplication()</code> layer instead in the <code>Residual</code> block:</p>
<div class="highlight">
<pre><span></span><span class="n">serial</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Serial</span><span class="p">(</span>
    <span class="n">layers</span><span class="o">.</span><span class="n">Select</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> 
    <span class="n">layers</span><span class="o">.</span><span class="n">Residual</span><span class="p">(</span><span class="n">Multiplication</span><span class="p">())</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">serial</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"name :"</span><span class="p">,</span> <span class="n">serial</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"expected inputs :"</span><span class="p">,</span> <span class="n">serial</span><span class="o">.</span><span class="n">n_in</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"promised outputs :"</span><span class="p">,</span> <span class="n">serial</span><span class="o">.</span><span class="n">n_out</span><span class="p">)</span>
</pre></div>
<pre class="example" id="orge993ccd">
Serial_in2_out3[
  Select[0,1,0,1]_in2_out4
  Serial_in2[
    Branch_in2_out2[
      None
      Multiplication_in2
    ]
    Add_in2
  ]
] 

name : Serial
expected inputs : 2
promised outputs : 3
</pre>
<p>This means you'll have a different output that will be added to the stack top input saved by the Residual block. The diagram becomes like this:</p>
<p>And you'll get <code>3 + (3 * 4) = 15</code> as output of the <code>Residual</code> block:</p>
<div class="highlight">
<pre><span></span><span class="n">x1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">])</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">serial</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">x1</span><span class="si">}</span><span class="s2"> * </span><span class="si">{</span><span class="n">x2</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">serial</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<pre class="example">
[3] * [4] -&gt; (array([15]), array([3]), array([4]))
</pre></div>
</div>
</div>
</div>
</div>
<aside class="postpromonav">
<nav>
<ul class="tags" itemprop="keywords">
<li><a class="tag p-category" href="../../../categories/nlp/" rel="tag">nlp</a></li>
</ul>
<ul class="pager hidden-print">
<li class="previous"><a href="../bleu-score/" rel="prev" title="Bleu Score">Previous post</a></li>
<li class="next"><a href="../neural-machine-translation/" rel="next" title="Neural Machine Translation">Next post</a></li>
</ul>
</nav>
</aside>
<script async id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
<script type="text/x-mathjax-config">

        MathJax.Hub.Config({tex2jax: {inlineMath: [['$latex ','$'], ['\\(','\\)']],},

        });
</script>
<link href="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js"></script>
<script>

    MathJax = {
        tex: {
            inlineMath: [['$','$'], ['\\(','\\)']],
            displayMath: [['$$','$$'], ['\\[','\\]']],
            processEscapes: true,
            processEnvironments: true,
        }
    }
</script>
<link href="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js"></script></article>
<!--End of body content-->
<footer id="footer"><a href="https://creativecommons.org/licenses/by/4.0/" rel="license"><img alt="Creative Commons License" id="license-image" src="https://licensebuttons.net/l/by/4.0/80x15.png" style="border-width:0"></a>This work is licensed under a <a href="http://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>. <a href="mailto:necromuralist@protonmail.com">Cloistered Monkey</a> - Powered by <a href="https://getnikola.com" rel="nofollow">Nikola</a></footer>
</div>
</div>
<script src="../../../assets/js/all-nocdn.js"></script>
<script>

    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
</script>
</body>
</html>
