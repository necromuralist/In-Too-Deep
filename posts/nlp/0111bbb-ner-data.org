#+BEGIN_COMMENT
.. title: NER: Data
.. slug: ner-data
.. date: 2021-01-13 15:00:14 UTC-08:00
.. tags: lstm,rnn,nlp,ner
.. category: NLP
.. link: 
.. description: Loading the data for the NER model.
.. type: text

#+END_COMMENT
#+OPTIONS: ^:{}
#+TOC: headlines 3
#+PROPERTY: header-args :session ~/.local/share/jupyter/runtime/kernel-709fde8b-8b91-427d-957f-760d2020bb80-ssh.json
#+BEGIN_SRC python :results none :exports none
%load_ext autoreload
%autoreload 2
#+END_SRC
* The Data
  - {{% lancelot title="The First Post" %}}named-entity-recognition{{% /lancelot %}}
  - {{% lancelot title="The Previous Post" %}}ner-pre-processing-the-data{{% /lancelot %}}
  - {{% lancelot title="The Next Post" %}}ner-building-the-model{{% /lancelot %}}

** Imports
#+begin_src python :results none
# this project
from neurotic.nlp.named_entity_recognition import NERData, TOKEN
#+end_src
** Set Up
#+begin_src python :results none
ner = NERData()

# to make the functions pass we need to use their names (initially)
vocab = vocabulary = ner.data.vocabulary
tag_map = tags = ner.data.tags
#+end_src
* Middle
** Reviewing The Dataset
As a review we can look at what's in the vocabulary.

#+begin_src python :results output :exports both
print(vocabulary["the"])
print(vocabulary[TOKEN.pad])
print(vocabulary["The"])
#+end_src

#+RESULTS:
: 9
: 35178
: 61

The vocabulary maps words in our vocabulary to unique integers. As you can see, we made it case-sensitive.

We also made a map for tags.

#+begin_src python :results output :exports both
for tag, index in tags.items():
    print(f" - {tag}: {index}")
#+end_src

#+RESULTS:
#+begin_example
 - O: 0
 - B-geo: 1
 - B-gpe: 2
 - B-per: 3
 - I-geo: 4
 - B-org: 5
 - I-org: 6
 - B-tim: 7
 - B-art: 8
 - I-art: 9
 - I-per: 10
 - I-gpe: 11
 - I-tim: 12
 - B-nat: 13
 - B-eve: 14
 - I-eve: 15
 - I-nat: 16
 - UNK: 17
#+end_example

| Prefix | Interpretation            |
|--------+---------------------------|
| B      | Token Begins an entity    |
| I      | Token is Inside an entity |

This is to help when you have multi-token entities. So if you had the name "Burt Reynolds", "Burt" would be tagged =B-per= and "Reynolds" would be tagged "I-per".

#+begin_src python :results output :exports both
print(f"The number of tags is {len(tag_map)}")
print(f"The vocabulary size is {len(vocab):,}")
print(f"The training size is {len(ner.data.data_sets.x_train):,}")
print(f"The validation size is {len(ner.data.data_sets.x_validate):,}")
print("The first training sentence is ")
print(f"'{' '.join(ner.data.raw_data_sets.x_train[0])}'")
print("Its corresponding label is")
print(f" '{' '.join(ner.data.raw_data_sets.y_train[0])}'")

print("The first training encoded sentence is ")
print(f"{ner.data.data_sets.x_train[0]}")
print("Its corresponding encoded label is")
print(f"{ner.data.data_sets.y_train[0]}")
#+end_src

#+RESULTS:
#+begin_example
The number of tags is 18
The vocabulary size is 35,180
The training size is 33,570
The validation size is 7,194
The first training sentence is 
'Opposition leader Michael Howard said he hopes the government in coming weeks will try to uncover possible security flaws exploited in the attacks .'
Its corresponding label is
 'O O B-per I-per O O O O O O O O O O O O O O O O O O O O'
The first training encoded sentence is 
[7848, 538, 5951, 6187, 172, 502, 2453, 9, 293, 11, 5306, 822, 141, 1962, 7, 26689, 1176, 686, 11905, 14806, 11, 9, 292, 21]
Its corresponding encoded label is
[0, 0, 3, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
#+end_example
** A Data Generator
 **Instructions:** Implement a data generator function that takes in `batch_size, x, y, pad, shuffle` where x is a large list of sentences, and y is a list of the tags associated with those sentences and pad is a pad value. Return a subset of those inputs in a tuple of two arrays `(X,Y)`. Each is an array of dimension (`batch_size, max_len`), where `max_len` is the length of the longest sentence *in that batch*. You will pad the X and Y examples with the pad argument. If `shuffle=True`, the data will be traversed in a random form.

 This code as an outer loop  
 ```
 while True:  
 ...  
 yield((X,Y))  
 ```

 runs continuously in the fashion of generators, pausing when yielding the next values. We will generate a batch_size output on each pass of this loop.    

 It has two inner loops. 
 1. The first stores in temporal lists the data samples to be included in the next batch, and finds the maximum length of the sentences contained in it. By adjusting the length to include only the size of the longest sentence in each batch, overall computation is reduced. 

 2. The second loop moves those inputs from the temporal list into NumPy arrays pre-filled with pad values.

 There are three slightly out of the ordinary features. 
 1. The first is the use of the NumPy `full` function to fill the NumPy arrays with a pad value. See [full function documentation](https://numpy.org/doc/1.18/reference/generated/numpy.full.html).
 
 2. The second is tracking the current location in the incoming lists of sentences. Generators variables hold their values between invocations, so we create an `index` variable, initialize to zero, and increment by one for each sample included in a batch. However, we do not use the `index` to access the positions of the list of sentences directly. Instead, we use it to select one index from a list of indexes. In this way, we can change the order in which we traverse our original list, keeping untouched our original list.  

 3. The third also relates to wrapping. Because `batch_size` and the length of the input lists are not aligned, gathering a batch_size group of inputs may involve wrapping back to the beginning of the input loop. In our approach, it is just enough to reset the `index` to 0. We can re-shuffle the list of indexes to produce different batches each time.

#+begin_src python :results none
# UNQ_C1 (UNIQUE CELL IDENTIFIER, DO NOT EDIT)
# GRADED FUNCTION: data_generator
def data_generator(batch_size, x, y, pad, shuffle=False, verbose=False):
    '''
      Input: 
        batch_size - integer describing the batch size
        x - list containing sentences where words are represented as integers
        y - list containing tags associated with the sentences
        shuffle - Shuffle the data order
        pad - an integer representing a pad character
        verbose - Print information during runtime
      Output:
        a tuple containing 2 elements:
        X - np.ndarray of dim (batch_size, max_len) of padded sentences
        Y - np.ndarray of dim (batch_size, max_len) of tags associated with the sentences in X
    '''
    
    # count the number of lines in data_lines
    num_lines = len(x)
    
    # create an array with the indexes of data_lines that can be shuffled
    lines_index = [*range(num_lines)]
    
    # shuffle the indexes if shuffle is set to True
    if shuffle:
        rnd.shuffle(lines_index)
    
    index = 0 # tracks current location in x, y
    while True:
        buffer_x = [0] * batch_size # Temporal array to store the raw x data for this batch
        buffer_y = [0] * batch_size # Temporal array to store the raw y data for this batch
                
  ### START CODE HERE (Replace instances of 'None' with your code) ###
        
        # Copy into the temporal buffers the sentences in x[index : index + batch_size] 
        # along with their corresponding labels y[index : index + batch_size]
        # Find maximum length of sentences in x[index : index + batch_size] for this batch. 
        # Reset the index if we reach the end of the data set, and shuffle the indexes if needed.
        max_len = 0
        for i in range(batch_size):
             # if the index is greater than or equal to the number of lines in x
            if index >= num_lines:
                # then reset the index to 0
                index = None
                # re-shuffle the indexes if shuffle is set to True
                if shuffle:
                    rnd.shuffle(None)
            
            # The current position is obtained using `lines_index[index]`
            # Store the x value at the current position into the buffer_x
            buffer_x[i] = None
            
            # Store the y value at the current position into the buffer_y
            buffer_y[i] = None
            
            lenx = None    #length of current x[]
            if lenx > max_len:
                max_len = None                   #max_len tracks longest x[]
            
            # increment index by one
            index += None


        # create X,Y, NumPy arrays of size (batch_size, max_len) 'full' of pad value
        X = None
        Y = None

        # copy values from lists to NumPy arrays. Use the buffered values
        for i in range(batch_size):
            # get the example (sentence as a tensor)
            # in `buffer_x` at the `i` index
            x_i = None
            
            # similarly, get the example's labels
            # in `buffer_y` at the `i` index
            y_i = None
            
            # Walk through each word in x_i
            for j in range(len(x_i)):
                # store the word in x_i at position j into X
                X[i, j] = None
                
                # store the label in y_i at position j into Y
                Y[i, j] = None

    ### END CODE HERE ###
        if verbose: print("index=", index)
        yield((X,Y))
#+end_src

#+begin_src python :results output :exports both
batch_size = 5
mini_sentences = t_sentences[0: 8]
mini_labels = t_labels[0: 8]
dg = data_generator(batch_size, mini_sentences, mini_labels, vocab["<PAD>"], shuffle=False, verbose=True)
X1, Y1 = next(dg)
X2, Y2 = next(dg)
print(Y1.shape, X1.shape, Y2.shape, X2.shape)
print(X1[0][:], "\n", Y1[0][:])
#+end_src

# **Expected output:**   
# ```
# index= 5
# index= 2
# (5, 30) (5, 30) (5, 30) (5, 30)
# [    0     1     2     3     4     5     6     7     8     9    10    11
#     12    13    14     9    15     1    16    17    18    19    20    21
#  35180 35180 35180 35180 35180 35180] 
#  [    0     0     0     0     0     0     1     0     0     0     0     0
#      1     0     0     0     0     0     2     0     0     0     0     0
#  35180 35180 35180 35180 35180 35180]  
# ```
