#+BEGIN_COMMENT
.. title: IMDB Reviews Tensorflow Dataset
.. slug: imdb-reviews-tensorflow-dataset
.. date: 2019-09-09 16:24:46 UTC-07:00
.. tags: nlp,sentiment,tensorflow
.. category: NLP
.. link: 
.. description: Using the Tensorflow IMDB Reviews data-set to train a Single-Layer LSTM Model.
.. type: text

#+END_COMMENT
#+OPTIONS: ^:{}
#+TOC: headlines 3
* Beginning
** Imports
*** PyPi
#+begin_src ipython :session imdb :results none

#+end_src
* Middle
* End
* Raw
#+begin_center
#!/usr/bin/env python
# coding: utf-8

# # Single Layer LSTM

# In[ ]:


from __future__ import absolute_import, division, print_function, unicode_literals


import tensorflow_datasets as tfds
import tensorflow as tf
print(tf.__version__)


# In[ ]:


# If the tf.__version__ is 1.x, please run this cell
#!pip install tensorflow==2.0.0-beta0


# In[ ]:


import tensorflow_datasets as tfds
import tensorflow as tf
print(tf.__version__)


# In[ ]:


# Get the data
dataset, info = tfds.load('imdb_reviews/subwords8k', with_info=True, as_supervised=True)
train_dataset, test_dataset = dataset['train'], dataset['test']


# In[ ]:


tokenizer = info.features['text'].encoder


# In[ ]:


BUFFER_SIZE = 10000
BATCH_SIZE = 64

train_dataset = train_dataset.shuffle(BUFFER_SIZE)
train_dataset = train_dataset.padded_batch(BATCH_SIZE, train_dataset.output_shapes)
test_dataset = test_dataset.padded_batch(BATCH_SIZE, test_dataset.output_shapes)


# In[ ]:


model = tf.keras.Sequential([
    tf.keras.layers.Embedding(tokenizer.vocab_size, 64),
    tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(64)),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(1, activation='sigmoid')
])


# In[ ]:


model.summary()


# In[ ]:


model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])


# In[ ]:


NUM_EPOCHS = 10
history = model.fit(train_dataset, epochs=NUM_EPOCHS, validation_data=test_dataset)


# In[ ]:


import matplotlib.pyplot as plt


def plot_graphs(history, string):
  plt.plot(history.history[string])
  plt.plot(history.history['val_'+string])
  plt.xlabel("Epochs")
  plt.ylabel(string)
  plt.legend([string, 'val_'+string])
  plt.show()


# In[ ]:


plot_graphs(history, 'accuracy')


# In[ ]:


plot_graphs(history, 'loss')


#+end_center
