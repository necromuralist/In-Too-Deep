<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>In Too Deep (Posts about CNN)</title><link>https://necromuralist.github.io/In-Too-Deep/</link><description></description><atom:link href="https://necromuralist.github.io/In-Too-Deep/categories/cat_cnn.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2019 &lt;a href="mailto:necromuralist@protonmail.com"&gt;Cloistered Monkey&lt;/a&gt; </copyright><lastBuildDate>Sun, 30 Jun 2019 17:58:08 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Dog and Cat Breed Classification (What's Your Pet?)</title><link>https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/#org99a2ccd"&gt;Departure&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/#orgb15860a"&gt;Imports&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/#orgec3de11"&gt;Some Setup&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/#org9dfa89d"&gt;Initiation&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/#orgeb139d1"&gt;Downloading the Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/#org3951348"&gt;Looking At the Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/#orgb05da73"&gt;Training: resnet34&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/#orgb74857c"&gt;Results&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/#org699e504"&gt;Unfreezing, fine-tuning, and learning rates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/#orgdc6aaef"&gt;Training: resnet50&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/#org1461419"&gt;Other Data Formats&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/#org4d5d7b2"&gt;Return&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org99a2ccd" class="outline-2"&gt;
&lt;h2 id="org99a2ccd"&gt;Departure&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org99a2ccd"&gt;
&lt;p&gt;
This is lesson one from the &lt;a href="https://www.fast.ai"&gt;fastai&lt;/a&gt; course &lt;a href="https://course.fast.ai/index.html"&gt;Practical Deep Learning for Coders, v3&lt;/a&gt;, which I assume is the third version of the course, and not a reference to a &lt;a href="https://www.wikiwand.com/en/Kamen_Rider_V3"&gt;Japanese television show&lt;/a&gt;. It uses the &lt;a href="http://www.fast.ai/2018/10/02/fastai-ai/"&gt;fastai V1 library&lt;/a&gt; which uses &lt;a href="https://hackernoon.com/pytorch-1-0-468332ba5163"&gt;Pytorch 1.0&lt;/a&gt; but is an &lt;a href="https://www.wikiwand.com/en/Convention_over_configuration"&gt;opinionated framework&lt;/a&gt; that bundles some sensible defaults so you don't have to spend as much time building the networks.
&lt;/p&gt;

&lt;p&gt;
The goal is to train a neural network to identify the breeds of cats and dogs based of photos of them. It uses the &lt;a href="http://www.robots.ox.ac.uk/~vgg/data/pets/"&gt;Oxford-IIT Pet Dataset&lt;/a&gt; which was created by researchers at Oxford University's &lt;a href="http://www.robots.ox.ac.uk/~vgg/"&gt;Visual Geometry Group&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb15860a" class="outline-3"&gt;
&lt;h3 id="orgb15860a"&gt;Imports&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb15860a"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org886cdbe" class="outline-4"&gt;
&lt;h4 id="org886cdbe"&gt;Python&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org886cdbe"&gt;
&lt;p&gt;
Other than the &lt;a href="https://docs.python.org/3.4/library/re.html"&gt;&lt;code&gt;re&lt;/code&gt;&lt;/a&gt; none of the python imports were part of the original lesson. I'm importing &lt;a href="https://docs.python.org/3/library/gc.html"&gt;gc&lt;/a&gt; to do garbage collection because the lesson starts with a smaller network and then changes to a larger one which caused my machine to run out of memory on the GPU. The rest of the imports are for settings and setup.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Namespace&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;partial&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pathlib&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Path&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;gc&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;re&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd20acde" class="outline-4"&gt;
&lt;h4 id="orgd20acde"&gt;PyPi&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgd20acde"&gt;
&lt;p&gt;
&lt;code&gt;fastai&lt;/code&gt; recommends using &lt;code&gt;*&lt;/code&gt; to import everything, but I'd like to know where everything comes from and not import something that might conflict with my naming conventions so I'm going to (at least try to) import things individually. Luckily, unlike some projects (I'm looking at you, &lt;a href="https://bokeh.pydata.org/en/latest/"&gt;bokeh&lt;/a&gt;), their site has a search feature so you can look things up to see which module they come from.
&lt;/p&gt;

&lt;p&gt;
I'll keep the &lt;code&gt;fast.ai&lt;/code&gt; stuff separate to maybe make it easier to reference what comes from where.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;fastai.datasets&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;untar_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;URLs&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;fastai.metrics&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;accuracy&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;error_rate&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;fastai.train&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;ClassificationInterpretation&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;fastai.vision.data&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;get_image_files&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="n"&gt;imagenet_stats&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="n"&gt;ImageDataBunch&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;fastai.vision.learner&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;cnn_learner&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;fastai.vision.models&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;resnet18&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;resnet34&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;resnet50&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;fastai.vision.transform&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;get_transforms&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
And the rest… 
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;dotenv&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;load_dotenv&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;ipyexperiments&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;IPyExperimentsPytorch&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;tabulate&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;tabulate&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;holoviews&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;matplotlib.pyplot&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;pyplot&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pandas&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;seaborn&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;torch&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org114078c" class="outline-4"&gt;
&lt;h4 id="org114078c"&gt;My Stuff&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org114078c"&gt;
&lt;p&gt;
This is just some convenience stuff wrapped around other people's code (my lite-version of opinionated code).
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;graeae.tables&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;CountPercentage&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;graeae.timers&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Timer&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;graeae.visualization&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;EmbedHoloview&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgec3de11" class="outline-3"&gt;
&lt;h3 id="orgec3de11"&gt;Some Setup&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgec3de11"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org39f6db2" class="outline-4"&gt;
&lt;h4 id="org39f6db2"&gt;Some Constants&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org39f6db2"&gt;
&lt;p&gt;
There's a lot of values scattered all over the place and I just wanted one place to keep track of them and maybe change them if needed.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Net&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Namespace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;random_seed&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;batch_size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;low_memory_batch_size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc7f1f97" class="outline-4"&gt;
&lt;h4 id="orgc7f1f97"&gt;The Random Seed&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgc7f1f97"&gt;
&lt;p&gt;
To make this reproducible I'll set the random seed in numpy.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;seed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Net&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random_seed&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org09ebd03" class="outline-4"&gt;
&lt;h4 id="org09ebd03"&gt;The Path&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org09ebd03"&gt;
&lt;p&gt;
This loads where I put the image data-set.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;load_dotenv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;".env"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;override&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;DATA_PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"OXFORD_PET_DATASET"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;expanduser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org4905c89" class="outline-4"&gt;
&lt;h4 id="org4905c89"&gt;Plotting&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org4905c89"&gt;
&lt;p&gt;
Although I'd prefer to plot things in HoloViews/bokeh, some of their stuff is too tightly bundled to make it easy (and the image plots maybe don't need to be interactive) so this sets up some formatting for the matplotlib plots.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgce006d6" class="outline-5"&gt;
&lt;h5 id="orgce006d6"&gt;Matplotlib&lt;/h5&gt;
&lt;div class="outline-text-5" id="text-orgce006d6"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;get_ipython&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run_line_magic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'matplotlib'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'inline'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;get_ipython&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run_line_magic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'config'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"InlineBackend.figure_format = 'retina'"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;seaborn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;style&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"whitegrid"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
	    &lt;span class="n"&gt;rc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;"axes.grid"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
		&lt;span class="s2"&gt;"font.family"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"sans-serif"&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
		&lt;span class="s2"&gt;"font.sans-serif"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"Open Sans"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Latin Modern Sans"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Lato"&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
		&lt;span class="s2"&gt;"figure.figsize"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)},&lt;/span&gt;
	    &lt;span class="n"&gt;font_scale&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge0431da" class="outline-5"&gt;
&lt;h5 id="orge0431da"&gt;The Bokeh&lt;/h5&gt;
&lt;div class="outline-text-5" id="text-orge0431da"&gt;
&lt;p&gt;
This sets up some stuff for the javascript-based plotting.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;holoviews&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extension&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"bokeh"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;SLUG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"dog-and-cat-breed-classification"&lt;/span&gt;
&lt;span class="n"&gt;OUTPUT_FOLDER&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"../../files/posts/fastai/"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;SLUG&lt;/span&gt;
&lt;span class="n"&gt;Embed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;partial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EmbedHoloview&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;folder_path&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;OUTPUT_FOLDER&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This is where I'm going to put the settings for the javascript-based plotting.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Plot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Namespace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;width&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;800&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge4ecf0e" class="outline-4"&gt;
&lt;h4 id="orge4ecf0e"&gt;The Timer&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orge4ecf0e"&gt;
&lt;p&gt;
This times how long things take so I can estimate how long it will take if I re-run cells. It also speaks a message so I can do something else and will know that the code is done running without having to watch the messages.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TIMER&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Timer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org39b406a" class="outline-4"&gt;
&lt;h4 id="org39b406a"&gt;Tabulate&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org39b406a"&gt;
&lt;p&gt;
This is to format tables in the org-mode format (since I'm running this in emacs org-babel).
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ORG_TABLE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;partial&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tabulate&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;headers&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"keys"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
		    &lt;span class="n"&gt;showindex&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
		    &lt;span class="n"&gt;tablefmt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"orgtbl"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9dfa89d" class="outline-2"&gt;
&lt;h2 id="org9dfa89d"&gt;Initiation&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9dfa89d"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgeb139d1" class="outline-3"&gt;
&lt;h3 id="orgeb139d1"&gt;Downloading the Data&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgeb139d1"&gt;
&lt;p&gt;
As I mentioned before, the data will be the &lt;a href="http://www.robots.ox.ac.uk/~vgg/data/pets/"&gt;Oxford-IIIT Pet Dataset&lt;/a&gt; by &lt;a href="http://www.robots.ox.ac.uk/~vgg/publications/2012/parkhi12a/parkhi12a.pdf"&gt;O. M. Parkhi et al., 2012&lt;/a&gt;. In the dataset there are twelve breeds of cat and twenty-five breeds of dog. When the researchers performed their experiments in 2012 the best accuracy they got was 59.21 %.
&lt;/p&gt;

&lt;p&gt;
The original lesson uses the &lt;a href="https://docs.fast.ai/datasets.html#untar_data"&gt;untar_data&lt;/a&gt; function to download the data-set.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;untar_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Help on function untar_data in module fastai.datasets:

untar_data(url: str, fname: Union[pathlib.Path, str] = None, dest: Union[pathlib.Path, str] = None, data=True, force_download=False) -&amp;gt; pathlib.Path
    Download `url` to `fname` if it doesn't exist, and un-tgz to folder `dest`.


&lt;/pre&gt;

&lt;p&gt;
This data set is 774 Megabytes and given my over-priced yet still incredibly slow CenturyLink speeds I found downloading it directly from the &lt;a href="https://course.fast.ai/datasets#image-classification"&gt;fastai datasets page&lt;/a&gt; a little more satisfactory, since the progress widget that runs during the download  when &lt;code&gt;untar_data&lt;/code&gt; downloads the dataset doesn't show up in emacs.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;DATA_PATH&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_dir&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DATA_PATH&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
/home/athena/data/datasets/images/oxford-iiit-pet

&lt;/pre&gt;

&lt;p&gt;
I didn't know it, but &lt;code&gt;Paths&lt;/code&gt; have an &lt;code&gt;ls&lt;/code&gt; method (so far as I could see this isn't in &lt;a href="https://docs.python.org/3/library/pathlib.html"&gt;python's documentation&lt;/a&gt;) which I mention because I found out because it was in the original lesson. This is nice because, well, it's easy to remember, but the way I'm using it &lt;code&gt;iterdir&lt;/code&gt; makes more sense.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;DATA_PATH&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iterdir&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;" - {path}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;/home/athena/data/datasets/images/oxford-iiit-pet/images_backup&lt;/li&gt;
&lt;li&gt;/home/athena/data/datasets/images/oxford-iiit-pet/README.org&lt;/li&gt;
&lt;li&gt;/home/athena/data/datasets/images/oxford-iiit-pet/images&lt;/li&gt;
&lt;li&gt;/home/athena/data/datasets/images/oxford-iiit-pet/annotations&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
Here's another trick I didn't know about, but learned from the lesson - instead of using the &lt;code&gt;joinpath&lt;/code&gt; method you can just use a forward-slash.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;path_to_annotations&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DATA_PATH&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s1"&gt;'annotations'&lt;/span&gt;
&lt;span class="n"&gt;path_to_images&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DATA_PATH&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s1"&gt;'images'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3951348" class="outline-3"&gt;
&lt;h3 id="org3951348"&gt;Looking At the Data&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org3951348"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0b7f88f" class="outline-4"&gt;
&lt;h4 id="org0b7f88f"&gt;Getting the Labels&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org0b7f88f"&gt;
&lt;p&gt;
Here's where we peek at our data set. The dataset is set up so that the breeds are used in the names of the image files. &lt;code&gt;fast.ai&lt;/code&gt; has a convenient classmethod named &lt;a href="https://docs.fast.ai/vision.data.html#ImageDataBunch.from_name_re"&gt;ImageDataBunch.from_name_re&lt;/a&gt; that will extract the labels from the filenames using a &lt;a href="https://docs.python.org/3.6/library/re.html"&gt;regular expression&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
Before we get to that, though, we can take a look at some file names using &lt;a href="https://docs.fast.ai/vision.data.html#get_image_files"&gt;get_image_files&lt;/a&gt;.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;file_names&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_image_files&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path_to_images&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;file_names&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;" - {path.name}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Boxer_20.jpg&lt;/li&gt;
&lt;li&gt;Saint_Bernard_195.jpg&lt;/li&gt;
&lt;li&gt;Saint_Bernard_133.jpg&lt;/li&gt;
&lt;li&gt;English_Cocker_Spaniel_43.jpg&lt;/li&gt;
&lt;li&gt;Pug_51.jpg&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
So it looks like the format is &lt;code&gt;&amp;lt;breed&amp;gt;_&amp;lt;index&amp;gt;.jpg&lt;/code&gt;. Later on we're going to use the labels when we inspect the model so next I'm going to make the standardize the file-name cases to be title-cased. 
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;UNDERSCORE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SPACE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"_"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;" "&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;file_names&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;extension&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;splitext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UNDERSCORE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SPACE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;file_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;extension&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SPACE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UNDERSCORE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;target&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;joinpath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file_name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rename&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;file_names&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_image_files&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path_to_images&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;file_names&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;" - {path.name}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Boxer_20.jpg&lt;/li&gt;
&lt;li&gt;Saint_Bernard_195.jpg&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Now I'll construct the pattern to match the file-name.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;is_not_a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"^"&lt;/span&gt;
&lt;span class="n"&gt;end_of_line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"$"&lt;/span&gt;
&lt;span class="n"&gt;one_or_more&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"+"&lt;/span&gt;
&lt;span class="n"&gt;digit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sa"&gt;r&lt;/span&gt;&lt;span class="s2"&gt;"\d"&lt;/span&gt;
&lt;span class="n"&gt;forward_slash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"/"&lt;/span&gt;
&lt;span class="n"&gt;character_class&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"[{}]"&lt;/span&gt;
&lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"({})"&lt;/span&gt;

&lt;span class="n"&gt;anything_but_a_slash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;character_class&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"{is_not_a}{forward_slash}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rf&lt;/span&gt;&lt;span class="s2"&gt;"{digit}{one_or_more}"&lt;/span&gt;
&lt;span class="n"&gt;label&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;'{anything_but_a_slash}{one_or_more}'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;file_extension&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;".jpg"&lt;/span&gt;

&lt;span class="n"&gt;expression&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rf&lt;/span&gt;&lt;span class="s1"&gt;'{forward_slash}{label}{UNDERSCORE}{index}{file_extension}{end_of_line}'&lt;/span&gt;
&lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"/home/athena/data/datasets/images/oxford-iiit-pet/images/Saint_Bernard_195.jpg"&lt;/span&gt;
&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;groups&lt;/span&gt;&lt;span class="p"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"Saint_Bernard"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The reason for the forward slash at the beginning of the expression is that we're passing in the entire path to each image, not just the name of the image.
&lt;/p&gt;

&lt;p&gt;
Now on to the &lt;code&gt;ImageDataBunch&lt;/code&gt;. Here's the arguments we need to pass in.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ImageDataBunch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_name_re&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Help on method from_name_re in module fastai.vision.data:

from_name_re(path: Union[pathlib.Path, str], fnames: Collection[pathlib.Path], pat: str, valid_pct: float = 0.2, **kwargs) method of builtins.type instance
    Create from list of `fnames` in `path` with re expression `pat`.

None

&lt;/pre&gt;

&lt;p&gt;
Okay, so let's get the labels.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ImageDataBunch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_name_re&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path_to_images&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
				   &lt;span class="n"&gt;file_names&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
				   &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
				   &lt;span class="n"&gt;ds_tfms&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;get_transforms&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; 
				   &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;224&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
				   &lt;span class="n"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Net&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;batch_size&lt;/span&gt;
				  &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;imagenet_stats&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
One of the arguments we passed in (&lt;code&gt;ds_tfms&lt;/code&gt;?) isn't particularly obviously named, unless you already know about applying transforms to images, but here's what we passed to it.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;get_transforms&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Help on function get_transforms in module fastai.vision.transform:

get_transforms(do_flip:bool=True, flip_vert:bool=False, max_rotate:float=10.0, max_zoom:float=1.1, max_lighting:float=0.2, max_warp:float=0.2, p_affine:float=0.75, p_lighting:float=0.75, xtra_tfms:Union[Collection[fastai.vision.image.Transform], NoneType]=None) -&amp;gt; Collection[fastai.vision.image.Transform]
    Utility func to easily create a list of flip, rotate, `zoom`, warp, lighting transforms.

None

&lt;/pre&gt;

&lt;p&gt;
&lt;a href="https://docs.fast.ai/vision.transform.html#get_transforms"&gt;get_transforms&lt;/a&gt; adds random changes to the images to augment the datasets for our training.
&lt;/p&gt;

&lt;p&gt;
We also added a call to &lt;a href="https://docs.fast.ai/vision.data.html#normalize"&gt;normalize&lt;/a&gt; which sets the mean and standard deviation of the images to match those of the images used to train the model that we're going to use (&lt;a href="https://arxiv.org/abs/1512.03385"&gt;ResNet&lt;/a&gt;).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org184c612" class="outline-4"&gt;
&lt;h4 id="org184c612"&gt;Looking at Some of the Images&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org184c612"&gt;
&lt;p&gt;
The &lt;a href="https://docs.fast.ai/basic_data.html#DataBunch.show_batch"&gt;show_batch&lt;/a&gt; method will plot some of the images in matplotlib. It retrieves them randomly so calling the method repeatedly will pull up different images. Unfortunately you can't pass in a figure or axes so it isn't easily configurable.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show_batch&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Help on method show_batch in module fastai.basic_data:

show_batch(rows:int=5, ds_type:fastai.basic_data.DatasetType=&amp;lt;DatasetType.Train: 1&amp;gt;, reverse:bool=False, **kwargs) -&amp;gt; None method of fastai.vision.data.ImageDataBunch instance
    Show a batch of data in `ds_type` on a few `rows`.


&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show_batch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;figsize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/show_batch.png" alt="show_batch.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
I'm guessing that the reason why so many images look "off" is because the of the data-transforms being added, and not that the photographers were horrible (or drunk). Why don't we look at the representation of the data bunch?
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
ImageDataBunch;

Train: LabelList (5912 items)
x: ImageList
Image (3, 224, 224),Image (3, 224, 224),Image (3, 224, 224),Image (3, 224, 224),Image (3, 224, 224)
y: CategoryList
Boxer,Saint_Bernard,Saint_Bernard,Ragdoll,Birman
Path: /home/athena/data/datasets/images/oxford-iiit-pet/images;

Valid: LabelList (1478 items)
x: ImageList
Image (3, 224, 224),Image (3, 224, 224),Image (3, 224, 224),Image (3, 224, 224),Image (3, 224, 224)
y: CategoryList
Siamese,British_Shorthair,English_Cocker_Spaniel,Newfoundland,Russian_Blue
Path: /home/athena/data/datasets/images/oxford-iiit-pet/images;

Test: None
&lt;/pre&gt;

&lt;p&gt;
So it looks like the &lt;code&gt;ImageDataBunch&lt;/code&gt; created a training and a validation set and each of the images has three channels and is 224 x 224 pixels.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb05da73" class="outline-3"&gt;
&lt;h3 id="orgb05da73"&gt;Training: resnet34&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb05da73"&gt;
&lt;p&gt;
Here's where we train the model, a &lt;a href="http://cs231n.github.io/convolutional-networks/"&gt;convolutional neural network&lt;/a&gt; in the back with a fully-connected network at the end.
&lt;/p&gt;

&lt;p&gt;
I'll use &lt;code&gt;fast.ai's&lt;/code&gt; &lt;a href="https://docs.fast.ai/vision.learner.html#cnn_learner"&gt;cnn_learner&lt;/a&gt; to load the data, pre-trained model (&lt;code&gt;resnet34&lt;/code&gt;), and the metric to use when training (&lt;a href="https://docs.fast.ai/metrics.html#error_rate"&gt;error_rate&lt;/a&gt;). If you look at the &lt;a href="https://github.com/fastai/fastai/blob/master/fastai/vision/models/__init__.py"&gt;fast ai code&lt;/a&gt; they are importing the &lt;code&gt;resnet34&lt;/code&gt; model from &lt;a href="https://pytorch.org/docs/stable/torchvision/models.html#id3"&gt;pytorch's torchvision&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
This next block sets up the &lt;a href="https://github.com/stas00/ipyexperiments/blob/master/docs/ipyexperiments.md"&gt;IPyExperiments&lt;/a&gt; which will delete all the variables that were created after it was created when it is deleted. This is to free up memory because the &lt;code&gt;resnet&lt;/code&gt; architecture takes up a lot of memory on the GPU.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;experiment&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IPyExperimentsPytorch&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org32740ad" class="outline-4"&gt;
&lt;h4 id="org32740ad"&gt;Experiment started with the Pytorch backend&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org32740ad"&gt;
&lt;p&gt;
Device: ID 0, GeForce GTX 1060 6GB (6069 RAM)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org6020b8f" class="outline-4"&gt;
&lt;h4 id="org6020b8f"&gt;Current state:&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org6020b8f"&gt;
&lt;p&gt;
RAM:    Used    Free   Total       Util
CPU:   2,375  58,710  64,336 MB   3.69% 
GPU:     916   5,153   6,069 MB  15.10% 
&lt;/p&gt;


&lt;p&gt;
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.000
･ CPU:          0          0      2,375 MB |
･ GPU:          0          0        916 MB |
&lt;/p&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;learn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cnn_learner&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;resnet34&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;metrics&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;error_rate&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:01.758
･ CPU:          0          0      2,551 MB |
･ GPU:        114          0      1,030 MB |

&lt;/pre&gt;

&lt;pre class="example"&gt;
Downloading: "https://download.pytorch.org/models/resnet34-333f7ec4.pth" to /home/athena/.torch/models/resnet34-333f7ec4.pth
87306240it [00:26, 3321153.99it/s]
&lt;/pre&gt;

&lt;p&gt;
As you can see, it downloaded the stored model parameters from pytorch. This is because I've never downloaded this particular model before - if you run it again it shouldn't need to re-download it. Since this is a &lt;a href="https://pytorch.org"&gt;pytorch&lt;/a&gt; model we can look at it's represetantion to see the architecture of the network.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Sequential(
  (0): Sequential(
    (0): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)
    (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
    (2): ReLU(inplace)
    (3): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False)
    (4): Sequential(
      (0): BasicBlock(
        (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu): ReLU(inplace)
        (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      )
      (1): BasicBlock(
        (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu): ReLU(inplace)
        (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      )
      (2): BasicBlock(
        (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu): ReLU(inplace)
        (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      )
    )
    (5): Sequential(
      (0): BasicBlock(
        (conv1): Conv2d(64, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)
        (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu): ReLU(inplace)
        (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (downsample): Sequential(
          (0): Conv2d(64, 128, kernel_size=(1, 1), stride=(2, 2), bias=False)
          (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        )
      )
      (1): BasicBlock(
        (conv1): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu): ReLU(inplace)
        (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      )
      (2): BasicBlock(
        (conv1): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu): ReLU(inplace)
        (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      )
      (3): BasicBlock(
        (conv1): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu): ReLU(inplace)
        (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      )
    )
    (6): Sequential(
      (0): BasicBlock(
        (conv1): Conv2d(128, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)
        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu): ReLU(inplace)
        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (downsample): Sequential(
          (0): Conv2d(128, 256, kernel_size=(1, 1), stride=(2, 2), bias=False)
          (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        )
      )
      (1): BasicBlock(
        (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu): ReLU(inplace)
        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      )
      (2): BasicBlock(
        (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu): ReLU(inplace)
        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      )
      (3): BasicBlock(
        (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu): ReLU(inplace)
        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      )
      (4): BasicBlock(
        (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu): ReLU(inplace)
        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      )
      (5): BasicBlock(
        (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu): ReLU(inplace)
        (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      )
    )
    (7): Sequential(
      (0): BasicBlock(
        (conv1): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)
        (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu): ReLU(inplace)
        (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (downsample): Sequential(
          (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False)
          (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        )
      )
      (1): BasicBlock(
        (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu): ReLU(inplace)
        (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      )
      (2): BasicBlock(
        (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu): ReLU(inplace)
        (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
        (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      )
    )
  )
  (1): Sequential(
    (0): AdaptiveConcatPool2d(
      (ap): AdaptiveAvgPool2d(output_size=1)
      (mp): AdaptiveMaxPool2d(output_size=1)
    )
    (1): Flatten()
    (2): BatchNorm1d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
    (3): Dropout(p=0.25)
    (4): Linear(in_features=1024, out_features=512, bias=True)
    (5): ReLU(inplace)
    (6): BatchNorm1d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
    (7): Dropout(p=0.5)
    (8): Linear(in_features=512, out_features=37, bias=True)
  )
)
&lt;/pre&gt;

&lt;p&gt;
That's a pretty big network, but the main thing to notice is the last layer, which has 37 &lt;code&gt;out_features&lt;/code&gt; which corresponds to the number of breeds we have in our data-set. If you were working directly with pytorch you'd have to remove the last layer and add it back yourself, but &lt;code&gt;fast.ai&lt;/code&gt; has done this for us.
&lt;/p&gt;

&lt;p&gt;
Now we need to train it using the &lt;a href="https://docs.fast.ai/train.html#fit_one_cycle"&gt;fit_one_cycle&lt;/a&gt; method. At first I thought 'one cycle' meant just one pass through the batches but according to the &lt;a href="https://docs.fast.ai/callbacks.one_cycle.html"&gt;documentation&lt;/a&gt;, this is a reference to a training method called the &lt;a href="https://sgugger.github.io/the-1cycle-policy.html"&gt;1Cycle Policy&lt;/a&gt; proposed by &lt;a href="https://arxiv.org/abs/1803.09820"&gt;Leslie N. Smith&lt;/a&gt; that changes the hyperparameters to make the model train faster.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TIMER&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mesasge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"Finished fitting the ResNet 34 Model."&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;TIMER&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fit_one_cycle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Started: 2019-04-21 18:18:45.894630
Ended: 2019-04-21 18:22:09.988508
Elapsed: 0:03:24.093878
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:03:24.095
･ CPU:          0          0      2,999 MB |
･ GPU:        151      3,322      1,182 MB |

&lt;/pre&gt;

&lt;p&gt;
Depending on how busy the computer is this takes two to three minutes when I run it. Next let's store the parameters for the trained model to disk.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;save&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'stage-1'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.145
･ CPU:          0          0      3,000 MB |
･ GPU:         -1          0      1,181 MB |

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb74857c" class="outline-3"&gt;
&lt;h3 id="orgb74857c"&gt;Results&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb74857c"&gt;
&lt;p&gt;
Let's look at how the model did. If I was running this in a jupyter notebook there would be a table output of the accuracy, but I'm not, and I can't find any documentation on how to get that myself, so, tough luck, then. We can look at some things after the fact, though - the &lt;a href="https://docs.fast.ai/train.html#ClassificationInterpretation"&gt;ClassificationInterpretation&lt;/a&gt; class contains methods to help look at how the model did.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;interpreter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ClassificationInterpretation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_learner&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The &lt;a href="https://docs.fast.ai/vision.learner.html#ClassificationInterpretation.top_losses"&gt;top_losses&lt;/a&gt; method returns a tuple of the highest losses along with the indices of the data that gave those losses. By default it actually gives all the losses sorted from largest to smallest, but you could pass in an integer to limit how much it returns.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;losses&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;indexes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;interpreter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;top_losses&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;losses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;indexes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;valid_ds&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;losses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;indexes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
tensor([7.1777e+00, 6.8882e+00, 5.8577e+00,  ..., 3.8147e-06, 3.8147e-06,
        1.9073e-06])
tensor([1298, 1418,  166,  ...,  735,  404,  291])
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.002
･ CPU:          0          0      3,000 MB |
･ GPU:          0          0      1,181 MB |

&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;holoviews&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Distribution&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;losses&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Loss Distribution"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
					   &lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Loss"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
					   &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Plot&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
					   &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Plot&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Embed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;file_name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"loss_distribution"&lt;/span&gt;&lt;span class="p"&gt;)()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;object type="text/html" data="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/loss_distribution.html" style="width:100%" height="800"&gt;
  &lt;p&gt;Figure Missing&lt;/p&gt;
&lt;/object&gt;

&lt;p&gt;
Although it looks like there are negative losses, that's just the way the distribution works out, it looks like most of the losses are around zero.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;losses&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;losses&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
tensor(7.1777)
tensor(1.9073e-06)
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.001
･ CPU:          0          0      3,000 MB |
･ GPU:          7          0      1,188 MB |

&lt;/pre&gt;

&lt;p&gt;
Here's a count of the losses when they are broken up into ten bins.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;bins&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pandas&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cut&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;losses&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tolist&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;bins&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value_counts&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reset_index&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bins&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;percentage&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;bins&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;total&lt;/span&gt;
&lt;span class="n"&gt;bins&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"percent"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;percentage&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ORG_TABLE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bins&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;headers&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Range Count Percent(%)"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;Range&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;Count&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;Percent(%)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;(-0.00718, 0.718]&lt;/td&gt;
&lt;td class="org-right"&gt;1349&lt;/td&gt;
&lt;td class="org-right"&gt;91.272&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;(0.718, 1.436]&lt;/td&gt;
&lt;td class="org-right"&gt;61&lt;/td&gt;
&lt;td class="org-right"&gt;4.1272&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;(1.436, 2.153]&lt;/td&gt;
&lt;td class="org-right"&gt;31&lt;/td&gt;
&lt;td class="org-right"&gt;2.09743&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;(2.153, 2.871]&lt;/td&gt;
&lt;td class="org-right"&gt;14&lt;/td&gt;
&lt;td class="org-right"&gt;0.947226&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;(2.871, 3.589]&lt;/td&gt;
&lt;td class="org-right"&gt;15&lt;/td&gt;
&lt;td class="org-right"&gt;1.01488&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;(3.589, 4.307]&lt;/td&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;td class="org-right"&gt;0.202977&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;(4.307, 5.024]&lt;/td&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;td class="org-right"&gt;0.135318&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;(5.024, 5.742]&lt;/td&gt;
&lt;td class="org-right"&gt;0&lt;/td&gt;
&lt;td class="org-right"&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;(5.742, 6.46]&lt;/td&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-right"&gt;0.067659&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;(6.46, 7.178]&lt;/td&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;td class="org-right"&gt;0.135318&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
It's not entirely clear to me how to interpret the losses - what does a loss of seven mean, exactly? -0.00744? But, anyway, it looks like the vast majority are less than one.
&lt;/p&gt;

&lt;p&gt;
Another thing we can do is plot the images that had the highest losses.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;interpreter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot_top_losses&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;figsize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/top_losses.png" alt="top_losses.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
It looks like the ones that had the most loss had some kind of weird flare effect applied to the image. Now that we've used it, maybe we can see how we're supposed to call &lt;code&gt;plot_top_losses&lt;/code&gt;.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;interpreter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot_top_losses&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Help on method _cl_int_plot_top_losses in module fastai.vision.learner:

_cl_int_plot_top_losses(k, largest=True, figsize=(12, 12), heatmap:bool=True, heatmap_thresh:int=16, return_fig:bool=None) -&amp;gt; Union[matplotlib.figure.Figure, NoneType] method of fastai.train.ClassificationInterpretation instance
    Show images in `top_losses` along with their prediction, actual, loss, and probability of actual class.

None

&lt;/pre&gt;

&lt;p&gt;
&lt;b&gt;Note:&lt;/b&gt; in the original notebook they were using a function called &lt;a href="https://github.com/fastai/fastai/blob/master/fastai/gen_doc/nbdoc.py#L126"&gt;doc&lt;/a&gt;, which tries to open another window and will thus hang when run in emacs. They &lt;i&gt;really&lt;/i&gt; want you to use jupyter.
&lt;/p&gt;

&lt;p&gt;
Next let's look at the &lt;a href="https://www.wikiwand.com/en/Confusion_matrix"&gt;confusion matrix&lt;/a&gt;.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;interpreter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot_confusion_matrix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;figsize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;dpi&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/confusion_matrix.png" alt="confusion_matrix.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
One way to interpret this is to look at the x-axis (the actual breed) and sweep vertically up to see the counts for the y-axis (what our model predicted it was). The diagonal cells from the top left to the bottom right is where the predicted matched the actual. In this case, the fact that almost all the counts are in the diagonal means our model did pretty well at predicting the breeds in the images.
&lt;/p&gt;

&lt;p&gt;
If you compare the images with the worst losses to the confusion matrix you'll notice that they don't seem to correlate with the worst performances overall - the worst losses were one-offs, probably due to the flare effect. The most confused was the &lt;i&gt;Ragdoll&lt;/i&gt; being confused for a &lt;i&gt;Birman&lt;/i&gt;, but, as noted in the lecture, &lt;a href="https://pets.thenest.com/birman-vs-ragdoll-cat-11758.html"&gt;distinguishing them is hard for people too&lt;/a&gt;. 
&lt;/p&gt;

&lt;p&gt;
Here's the breeds that were the hardest for the model to predict.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ORG_TABLE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;interpreter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;most_confused&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;min_val&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; 
		&lt;span class="n"&gt;headers&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Actual Predicted Count"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;Actual&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;Predicted&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;Count&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;American_Pit_Bull_Terrier&lt;/td&gt;
&lt;td class="org-left"&gt;Staffordshire_Bull_Terrier&lt;/td&gt;
&lt;td class="org-right"&gt;10&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Staffordshire_Bull_Terrier&lt;/td&gt;
&lt;td class="org-left"&gt;American_Pit_Bull_Terrier&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;American_Bulldog&lt;/td&gt;
&lt;td class="org-left"&gt;Staffordshire_Bull_Terrier&lt;/td&gt;
&lt;td class="org-right"&gt;4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Bengal&lt;/td&gt;
&lt;td class="org-left"&gt;Egyptian_Mau&lt;/td&gt;
&lt;td class="org-right"&gt;4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;American_Pit_Bull_Terrier&lt;/td&gt;
&lt;td class="org-left"&gt;American_Bulldog&lt;/td&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Miniature_Pinscher&lt;/td&gt;
&lt;td class="org-left"&gt;Chihuahua&lt;/td&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Ragdoll&lt;/td&gt;
&lt;td class="org-left"&gt;Birman&lt;/td&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Samoyed&lt;/td&gt;
&lt;td class="org-left"&gt;Great_Pyrenees&lt;/td&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
It doesn't look too bad, actually, other that the first few entries, maybe.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org699e504" class="outline-3"&gt;
&lt;h3 id="org699e504"&gt;Unfreezing, fine-tuning, and learning rates&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org699e504"&gt;
&lt;p&gt;
So, this is what we get with a straight off-the-shelf setup from &lt;code&gt;fast.ai&lt;/code&gt;, but we want more, don't we? Let's &lt;a href="https://docs.fast.ai/basic_train.html#Learner.unfreeze"&gt;&lt;b&gt;unfreeze&lt;/b&gt;&lt;/a&gt; the model (allow the entire model's weights to be trained) and train some more.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unfreeze&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Since we are using a pre-trained model we normally freeze all but the last layer to do transfer learning, by unfreezing the model we'll train all the layers to our dataset.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TIMER&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"Finished training the unfrozen model."&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;TIMER&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fit_one_cycle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Started: 2019-04-21 18:29:47.149628
Ended: 2019-04-21 18:30:28.689325
Elapsed: 0:00:41.539697
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:41.541
･ CPU:          0          0      3,010 MB |
･ GPU:        694      1,923      1,883 MB |

&lt;/pre&gt;

&lt;p&gt;
Now we save the parameters to disk again.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;save&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'stage-1'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Now we're going to use the &lt;a href="https://docs.fast.ai/callbacks.lr_finder.html"&gt;lr_find&lt;/a&gt; method to find the best learning rate.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TIMER&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"Finished finding the best learning rate."&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;TIMER&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lr_find&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Started: 2019-04-21 18:31:02.961941
LR Finder is complete, type {learner_name}.recorder.plot() to see the graph.
Ended: 2019-04-21 18:31:29.892324
Elapsed: 0:00:26.930383
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:26.931
･ CPU:          0          0      3,010 MB |
･ GPU:        339      1,646      2,218 MB |

&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;recorder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/learning.png" alt="learning.png"&gt;
&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;
So, it's kind of hard to see the exact number, but you can see that somewhere around a learning rate of 0.0001 we get a good loss and then after that the loss starts to go way up.
&lt;/p&gt;

&lt;p&gt;
So next we're going to re-train it using an interval that hopefully gives us the best loss.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unfreeze&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;TIMER&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fit_one_cycle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_lr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;slice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1e-6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;1e-4&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Started: 2019-04-21 18:34:11.748741
None
Ended: 2019-04-21 18:35:34.827655
Elapsed: 0:01:23.078914
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:01:23.083
･ CPU:          0          0      3,011 MB |
･ GPU:          9      1,634      2,231 MB |

&lt;/pre&gt;

&lt;p&gt;
Now the experiment is over so let's free up some memory.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;experiment&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.000
･ CPU:          0          0      3,011 MB |
･ GPU:        -17          0      2,214 MB |
&lt;/p&gt;

&lt;p&gt;
IPyExperimentsPytorch: Finishing
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5f6170f" class="outline-4"&gt;
&lt;h4 id="org5f6170f"&gt;Experiment finished in 00:20:22 (elapsed wallclock time)&lt;/h4&gt;
&lt;/div&gt;

&lt;div id="outline-container-org604dbd4" class="outline-4"&gt;
&lt;h4 id="org604dbd4"&gt;Newly defined local variables:&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org604dbd4"&gt;
&lt;p&gt;
Deleted: bins, codecs, indexes, interpreter, learn, losses, percentage, total
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3e8f5c9" class="outline-4"&gt;
&lt;h4 id="org3e8f5c9"&gt;Circular ref objects gc collected during the experiment:&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org3e8f5c9"&gt;
&lt;p&gt;
cleared 12 objects (only temporary leakage)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7eed9f1" class="outline-4"&gt;
&lt;h4 id="org7eed9f1"&gt;Experiment memory:&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org7eed9f1"&gt;
&lt;p&gt;
RAM: Consumed       Reclaimed
CPU:      636        0 MB (  0.00%)
GPU:    1,297    1,308 MB (100.82%)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0f3f878" class="outline-4"&gt;
&lt;h4 id="org0f3f878"&gt;Current state:&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org0f3f878"&gt;
&lt;p&gt;
RAM:    Used    Free   Total       Util
CPU:   3,011  57,984  64,336 MB   4.68% 
GPU:     906   5,163   6,069 MB  14.93% 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdc6aaef" class="outline-3"&gt;
&lt;h3 id="orgdc6aaef"&gt;Training: resnet50&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgdc6aaef"&gt;
&lt;p&gt;
Okay, so we trained the &lt;code&gt;resnet34&lt;/code&gt; model, and although I haven't figured out how to tell exactly how well it's doing, it seems to be doing pretty well. Now it's time to try the &lt;code&gt;resnet50&lt;/code&gt; model, which has pretty much the same architecture but more layers. This means it should do better, but it also takes up a lot more memory.
&lt;/p&gt;


&lt;p&gt;
Even after deleting the old model I still run out of memory so I'm going to have to fall back to a smaller batch-size. 
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;experiment&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IPyExperimentsPytorch&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;

*** Experiment started with the Pytorch backend
Device: ID 0, GeForce GTX 1060 6GB (6069 RAM)


*** Current state:
RAM:    Used    Free   Total       Util
CPU:   3,011  57,984  64,336 MB   4.68% 
GPU:     906   5,163   6,069 MB  14.93% 


･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.000
･ CPU:          0          0      3,011 MB |
･ GPU:          0          0        906 MB |
&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ImageDataBunch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_name_re&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;path_to_images&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="n"&gt;file_names&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="n"&gt;expression&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="n"&gt;ds_tfms&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;get_transforms&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
    &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;299&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
    &lt;span class="n"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Net&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;low_memory_batch_size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;imagenet_stats&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Now I'll re-build the learner with the new pre-trained model.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;learn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cnn_learner&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;resnet50&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;metrics&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;error_rate&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lr_find&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;recorder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/learning_50.png" alt="learning_50.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
So with this learner we can see that there's a rapid drop in loss followed by a sudden spike in loss.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TIMER&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"Done fitting resnet 50"&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;TIMER&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fit_one_cycle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Started: 2019-04-21 18:42:03.987300
Ended: 2019-04-21 18:57:43.628598
Elapsed: 0:15:39.641298
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:15:39.643
･ CPU:          0          0      3,067 MB |
･ GPU:         17      4,474      1,117 MB |

&lt;/pre&gt;

&lt;p&gt;
Okay, so save the parameters again.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;save&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'stage-1-50'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Now we can try and unfreeze and re-train it.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TIMER&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"Finished training resnet 50 with the optimal learning rate."&lt;/span&gt;
&lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unfreeze&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;TIMER&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fit_one_cycle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_lr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;slice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1e-6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;1e-4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Started: 2019-04-21 18:58:22.070603
Ended: 2019-04-21 19:06:24.471347
Elapsed: 0:08:02.400744
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:08:02.406
･ CPU:          0          0      3,069 MB |
･ GPU:        259      4,586      1,376 MB |

&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;TIMER&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;metrics&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;validate&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Started: 2019-04-21 19:08:37.971400
Ended: 2019-04-21 19:08:49.648814
Elapsed: 0:00:11.677414
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:11.679
･ CPU:          0          0      3,069 MB |
･ GPU:         22        410      1,398 MB |

&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"Error Rate: {metrics[0]:.2f}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Error Rate: 0.15

&lt;/pre&gt;

&lt;p&gt;
Since it didn't improve let's go back to the previous model.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'stage-1-50'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;TIMER&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;metrics&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;validate&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;"Error Rate: {metrics[0]:.2f}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Started: 2019-04-21 19:09:19.655769
Ended: 2019-04-21 19:09:30.841289
Elapsed: 0:00:11.185520
Error Rate: 0.16
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:16.011
･ CPU:          1          1      3,069 MB |
･ GPU:        308        612      1,706 MB |

&lt;/pre&gt;
&lt;/div&gt;

&lt;div id="outline-container-org791539c" class="outline-4"&gt;
&lt;h4 id="org791539c"&gt;Interpreting the Result&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org791539c"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;interpreter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ClassificationInterpretation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_learner&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org109bfba" class="outline-5"&gt;
&lt;h5 id="org109bfba"&gt;The Most Confusing Breeds&lt;/h5&gt;
&lt;div class="outline-text-5" id="text-org109bfba"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ORG_TABLE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;interpreter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;most_confused&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;min_val&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
		&lt;span class="n"&gt;headers&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Actual Predicted Count"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;Actual&lt;/th&gt;
&lt;th scope="col" class="org-left"&gt;Predicted&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;Count&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;American_Pit_Bull_Terrier&lt;/td&gt;
&lt;td class="org-left"&gt;Staffordshire_Bull_Terrier&lt;/td&gt;
&lt;td class="org-right"&gt;6&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Bengal&lt;/td&gt;
&lt;td class="org-left"&gt;Egyptian_Mau&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Ragdoll&lt;/td&gt;
&lt;td class="org-left"&gt;Birman&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Staffordshire_Bull_Terrier&lt;/td&gt;
&lt;td class="org-left"&gt;American_Pit_Bull_Terrier&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;Bengal&lt;/td&gt;
&lt;td class="org-left"&gt;Abyssinian&lt;/td&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
It got fewer breeds with more than two wrong than the &lt;code&gt;resnet34&lt;/code&gt; model did, but both of them seem to have trouble telling an American Pit Bull Terrier from a Staffordshire Bull Terrier.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;experiment&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.000
･ CPU:          0          0      3,070 MB |
･ GPU:          0          0      1,706 MB |

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1461419" class="outline-3"&gt;
&lt;h3 id="org1461419"&gt;Other Data Formats&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1461419"&gt;
&lt;p&gt;
This is a look at other data sets.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org80ddf63" class="outline-4"&gt;
&lt;h4 id="org80ddf63"&gt;MNIST&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org80ddf63"&gt;
&lt;p&gt;
This is a set of handwritten digits. The originals are hosted on &lt;a href="http://yann.lecun.com/exdb/mnist/"&gt;yann.lecun.com&lt;/a&gt; but the &lt;a href="https://course.fast.ai/datasets#image-classification"&gt;fast.ai datasets page&lt;/a&gt; has the images converted from the original IDX format to the PNG format.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;experiment&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IPyExperimentsPytorch&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;

*** Experiment started with the Pytorch backend
Device: ID 0, GeForce GTX 1060 6GB (6069 RAM)


*** Current state:
RAM:    Used    Free   Total       Util
CPU:   3,070  57,254  64,336 MB   4.77% 
GPU:   1,706   4,363   6,069 MB  28.11% 


･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.097
･ CPU:          0          0      3,070 MB |
･ GPU:          0          0      1,706 MB |
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.043
･ CPU:          0          0      3,070 MB |
･ GPU:          0          0      1,706 MB |
&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;mnist_path_original&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;environ&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"MNIST"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;expanduser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;mnist_path_original&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_dir&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mnist_path_original&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
/home/athena/data/datasets/images/mnist_png
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.001
･ CPU:          0          0      3,070 MB |
･ GPU:          0          0      1,706 MB |
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.046
･ CPU:          0          0      3,070 MB |
･ GPU:          0          0      1,706 MB |

&lt;/pre&gt;

&lt;p&gt;
Now that we know it's there we can create a data bunch for it… Actually I tried it and found out that this is the wrong set (it throws an error for some reason), let's try it their way.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;URLs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MNIST_SAMPLE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;mnist_path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;untar_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;URLs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MNIST_SAMPLE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mnist_path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
http://files.fast.ai/data/examples/mnist_sample
/home/athena/.fastai/data/mnist_sample
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.309
･ CPU:          0          1      3,070 MB |
･ GPU:          0          0      1,706 MB |
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.379
･ CPU:          0          0      3,070 MB |
･ GPU:          0          0      1,706 MB |

&lt;/pre&gt;

&lt;p&gt;
Let's look at the difference. Here's what I downloaded.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;mnist_path_original&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iterdir&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;" - {path}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;/home/athena/data/datasets/images/mnist_png/testing&lt;/li&gt;
&lt;li&gt;/home/athena/data/datasets/images/mnist_png/README.org&lt;/li&gt;
&lt;li&gt;/home/athena/data/datasets/images/mnist_png/training&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.026
･ CPU:          0          0      3,070 MB |
･ GPU:          0          0      1,706 MB |
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.071
･ CPU:          0          0      3,070 MB |
･ GPU:          0          0      1,706 MB |
&lt;/p&gt;

&lt;p&gt;
And here's what they downloaded.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;mnist_path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iterdir&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="s2"&gt;" - {path}"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;i&gt;home/athena&lt;/i&gt;.fastai/data/mnist_sample/labels.csv&lt;/li&gt;
&lt;li&gt;&lt;i&gt;home/athena&lt;/i&gt;.fastai/data/mnist_sample/train&lt;/li&gt;
&lt;li&gt;&lt;i&gt;home/athena&lt;/i&gt;.fastai/data/mnist_sample/valid&lt;/li&gt;
&lt;li&gt;&lt;i&gt;home/athena&lt;/i&gt;.fastai/data/mnist_sample/models&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.043
･ CPU:          0          0      3,070 MB |
･ GPU:          0          0      1,706 MB |
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.090
･ CPU:          0          0      3,070 MB |
･ GPU:          0          0      1,706 MB |
&lt;/p&gt;

&lt;p&gt;
Maybe you need a &lt;code&gt;labels.csv&lt;/code&gt; file… I guess that's the point of this being in the "other formats" section.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;transforms&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_transforms&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;do_flip&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ImageDataBunch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_folder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mnist_path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ds_tfms&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;transforms&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
I don't know why the size is 26 in this case.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show_batch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;figsize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/mnist_batch.png" alt="mnist_batch.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Now to fit the model. This uses a smaller version of the resnet (18 layers) and the &lt;code&gt;accuracy&lt;/code&gt; metric. 
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;TIMER&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;learn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cnn_learner&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;resnet18&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;metrics&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;accuracy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;learn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Started: 2019-04-21 19:15:13.568995
Ended: 2019-04-21 19:15:44.806330
Elapsed: 0:00:31.237335
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:31.239
･ CPU:          0          0      3,075 MB |
･ GPU:         46      1,379      1,733 MB |
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:31.297
･ CPU:          0          0      3,075 MB |
･ GPU:         46      1,379      1,733 MB |

&lt;/pre&gt;


&lt;p&gt;
So, since the labels are so important, maybe we should look at them.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;labels&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pandas&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read_csv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mnist_path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s1"&gt;'labels.csv'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ORG_TABLE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;labels&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iloc&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col class="org-left"&gt;

&lt;col class="org-right"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;name&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;label&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;train/3/7463.png&lt;/td&gt;
&lt;td class="org-right"&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;train/3/21102.png&lt;/td&gt;
&lt;td class="org-right"&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;train/3/31559.png&lt;/td&gt;
&lt;td class="org-right"&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;train/3/46882.png&lt;/td&gt;
&lt;td class="org-right"&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;train/3/26209.png&lt;/td&gt;
&lt;td class="org-right"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Well, that's not realy revelatory.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ImageDataBunch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;from_csv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mnist_path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ds_tfms&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;transforms&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;28&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show_batch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;figsize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;classes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
[0, 1]
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.001
･ CPU:          0          0      3,080 MB |
･ GPU:          0          0      1,733 MB |
･ RAM:  △Consumed    △Peaked    Used Total | Exec time 0:00:00.047
･ CPU:          0          0      3,080 MB |
･ GPU:          0          0      1,733 MB |

&lt;/pre&gt;


&lt;p&gt;
So there are only two classes, presumably meaning that they are &lt;code&gt;3&lt;/code&gt; and &lt;code&gt;7&lt;/code&gt;.
&lt;/p&gt;

&lt;p&gt;
There's more examples of… something in the notebook, but they don't explain it so I'm just going to skip over the rest of it.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4d5d7b2" class="outline-2"&gt;
&lt;h2 id="org4d5d7b2"&gt;Return&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org4d5d7b2"&gt;
&lt;p&gt;
This last bit just let's me run the whole notebook and get a message when it's over.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TIMER&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"The Dog and cat breed classification buffer is done. Come check it out."&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;TIMER&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Started: 2019-04-21 10:43:46.858157
Ended: 2019-04-21 10:43:46.858197
Elapsed: 0:00:00.000040

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cnn</category><category>deep learning</category><category>fastai</category><guid>https://necromuralist.github.io/In-Too-Deep/posts/fastai/dog-and-cat-breed-classification/</guid><pubDate>Sat, 13 Apr 2019 23:14:46 GMT</pubDate></item><item><title>Weight Initialization</title><link>https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/#org594659f"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/#org3778049"&gt;Initial Weights and Observing Training Loss&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/#org5c5b90a"&gt;Dataset and Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/#org93693f9"&gt;Import Libraries and Load the Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/#orgab28388"&gt;Visualize Some Training Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/#org74eb8f0"&gt;Define the Model Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/#org914e008"&gt;Initialize Weights&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/#org4fd5786"&gt;Compare Model Behavior&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/#org8e0922c"&gt;General rule for setting weights&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/#org9c3f8a2"&gt;Normal Distribution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/#orgf5d273c"&gt;Automatic Initialization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/#org635213f"&gt;evaluate the behavior using helpers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org594659f" class="outline-2"&gt;
&lt;h2 id="org594659f"&gt;Introduction&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org594659f"&gt;
&lt;p&gt;
In this lesson, you'll learn how to find good initial weights for a neural network. Weight initialization happens once, when a model is created and before it trains. Having good initial weights can place the neural network close to the optimal solution. This allows the neural network to come to the best solution quicker. 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3778049" class="outline-2"&gt;
&lt;h2 id="org3778049"&gt;Initial Weights and Observing Training Loss&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3778049"&gt;
&lt;p&gt;
To see how different weights perform, we'll test on the same dataset and neural network. That way, we know that any changes in model behavior are due to the weights and not any changing data or model structure. 
 We'll instantiate at least two of the same models, with &lt;i&gt;different&lt;/i&gt; initial weights and see how the training loss decreases over time.
&lt;/p&gt;


&lt;p&gt;
Sometimes the differences in training loss, over time, will be large and other times, certain weights offer only small improvements.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5c5b90a" class="outline-2"&gt;
&lt;h2 id="org5c5b90a"&gt;Dataset and Model&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5c5b90a"&gt;
&lt;p&gt;
We'll train an MLP to classify images from the &lt;a href="https://github.com/zalandoresearch/fashion-mnist"&gt;Fashion-MNIST database&lt;/a&gt; to demonstrate the effect of different initial weights. As a reminder, the FashionMNIST dataset contains images of clothing types; &lt;code&gt;classes = ['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat', 'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']&lt;/code&gt;. The images are normalized so that their pixel values are in a range [0.0 - 1.0).  Run the cell below to download and load the dataset.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org93693f9" class="outline-2"&gt;
&lt;h2 id="org93693f9"&gt;Import Libraries and Load the &lt;a href="http://pytorch.org/docs/stable/torchvision/datasets.html"&gt;Data&lt;/a&gt;&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org93693f9"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc94c9c6" class="outline-3"&gt;
&lt;h3 id="orgc94c9c6"&gt;Imports&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgc94c9c6"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# python
from functools import partial
from typing import Collection, Tuple
# from pypi
from dotenv import load_dotenv
from sklearn.model_selection import train_test_split
from torch.utils.data.sampler import SubsetRandomSampler
from torchvision import datasets
import matplotlib.pyplot as pyplot
import numpy
import seaborn
import torch
import torch.nn as nn
import torch.nn.functional as F
import torchvision.transforms as transforms

# udacity
import nano.helpers as helpers

# this project
from neurotic.tangles.data_paths import DataPathTwo
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3b1c5ff" class="outline-3"&gt;
&lt;h3 id="org3b1c5ff"&gt;Load the Data&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org3b1c5ff"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# number of subprocesses to use for data loading
subprocesses = 0
# how many samples per batch to load
batch_size = 100
# percentage of training set to use as validation
VALIDATION_FRACTION = 0.2
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Convert the data to a  torch.FloatTensor.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;transform = transforms.ToTensor()
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;load_dotenv()
path = DataPathTwo(folder_key="FASHION")
print(path.folder)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
/home/brunhilde/datasets/FASHION

&lt;/pre&gt;

&lt;p&gt;
Choose the training and test datasets.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;train_data = datasets.FashionMNIST(root=path.folder, train=True,
				   download=True, transform=transform)
test_data = datasets.FashionMNIST(root=path.folder, train=False,
				  download=True, transform=transform)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-images-idx3-ubyte.gz
Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-labels-idx1-ubyte.gz
Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-images-idx3-ubyte.gz
Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-labels-idx1-ubyte.gz
Processing...
Done!
&lt;/pre&gt;

&lt;p&gt;
Obtain training indices that will be used for validation.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;indices = list(range(len(train_data)))
train_idx, valid_idx = train_test_split(
    indices,
    test_size=VALIDATION_FRACTION)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Define samplers for obtaining training and validation batches.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;train_sampler = SubsetRandomSampler(train_idx)
valid_sampler = SubsetRandomSampler(valid_idx)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Prepare data loaders (combine dataset and sampler).
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;train_loader = torch.utils.data.DataLoader(train_data, batch_size=batch_size,
					   sampler=train_sampler, num_workers=subprocesses)
valid_loader = torch.utils.data.DataLoader(train_data, batch_size=batch_size, 
					   sampler=valid_sampler, num_workers=subprocesses)
test_loader = torch.utils.data.DataLoader(test_data, batch_size=batch_size, 
					  num_workers=subprocesses)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;classes = ['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat', 
    'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgab28388" class="outline-2"&gt;
&lt;h2 id="orgab28388"&gt;Visualize Some Training Data&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgab28388"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;get_ipython().run_line_magic('matplotlib', 'inline')
get_ipython().run_line_magic('config', "InlineBackend.figure_format = 'retina'")
seaborn.set(style="whitegrid",
	    rc={"axes.grid": False,
		"font.family": ["sans-serif"],
		"font.sans-serif": ["Open Sans", "Latin Modern Sans", "Lato"],
		"figure.figsize": (10, 8)},
	    font_scale=1)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Obtain one batch of training images.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dataiter = iter(train_loader)
images, labels = dataiter.next()
images = images.numpy()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Plot the images in the batch, along with the corresponding labels.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fig = pyplot.figure(figsize=(12, 10))
fig.suptitle("Sample FASHION Images", weight="bold")
for idx in np.arange(20):
    ax = fig.add_subplot(2, 20/2, idx+1, xticks=[], yticks=[])
    ax.imshow(np.squeeze(images[idx]), cmap='gray')
    ax.set_title(classes[labels[idx]])
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/image_one.png" alt="image_one.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org74eb8f0" class="outline-2"&gt;
&lt;h2 id="org74eb8f0"&gt;Define the Model Architecture&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org74eb8f0"&gt;
&lt;p&gt;
We've defined the MLP that we'll use for classifying the dataset.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd9642f1" class="outline-3"&gt;
&lt;h3 id="orgd9642f1"&gt;Neural Network&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd9642f1"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;A 3 layer MLP with hidden dimensions of 256 and 128.&lt;/li&gt;
&lt;li&gt;This MLP accepts a flattened image (784-value long vector) as input and produces 10 class scores as output.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
We'll test the effect of different initial weights on this 3 layer neural network with ReLU activations and an Adam optimizer. The lessons you learn apply to other neural networks, including different activations and optimizers.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org914e008" class="outline-2"&gt;
&lt;h2 id="org914e008"&gt;Initialize Weights&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org914e008"&gt;
&lt;p&gt;
Let's start looking at some initial weights.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf7c84c2" class="outline-3"&gt;
&lt;h3 id="orgf7c84c2"&gt;All Zeros or Ones&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf7c84c2"&gt;
&lt;p&gt;
If you follow the principle of &lt;a href="https://en.wikipedia.org/wiki/Occam's_razor"&gt;Occam's razor&lt;/a&gt;, you might think setting all the weights to 0 or 1 would be the best solution.  This is not the case.
&lt;/p&gt;

&lt;p&gt;
With every weight the same, all the neurons at each layer are producing the same output.  This makes it hard to decide which weights to adjust.
&lt;/p&gt;

&lt;p&gt;
Let's compare the loss with all ones and all zero weights by defining two models with those constant weights.
&lt;/p&gt;

&lt;p&gt;
Below, we are using PyTorch's &lt;a href="https://pytorch.org/docs/stable/nn.html#torch-nn-init"&gt;nn.init&lt;/a&gt; to initialize each Linear layer with a constant weight. The init library provides a number of weight initialization functions that give you the ability to initialize the weights of each layer according to layer type.
&lt;/p&gt;

&lt;p&gt;
In the case below, we look at every layer/module in our model. If it is a Linear layer (as all three layers are for this MLP), then we initialize those layer weights to be a &lt;code&gt;constant_weight&lt;/code&gt; with &lt;code&gt;bias=0&lt;/code&gt; using the following code:
&lt;/p&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Linear&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;nn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constant_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;constant_weight&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;nn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constant_&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bias&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The &lt;code&gt;constant_weight&lt;/code&gt; is a value that you can pass in when you instantiate the model.
&lt;/p&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgbc89043" class="outline-4"&gt;
&lt;h4 id="orgbc89043"&gt;Define the NN architecture&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgbc89043"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;class Net(nn.Module):
    def __init__(self, hidden_1=256, hidden_2=128, constant_weight=None):
	super(Net, self).__init__()
	# linear layer (784 -&amp;gt; hidden_1)
	self.fc1 = nn.Linear(28 * 28, hidden_1)
	# linear layer (hidden_1 -&amp;gt; hidden_2)
	self.fc2 = nn.Linear(hidden_1, hidden_2)
	# linear layer (hidden_2 -&amp;gt; 10)
	self.fc3 = nn.Linear(hidden_2, 10)
	# dropout layer (p=0.2)
	self.dropout = nn.Dropout(0.2)

	# initialize the weights to a specified, constant value
	if(constant_weight is not None):
	    for m in self.modules():
		if isinstance(m, nn.Linear):
		    nn.init.constant_(m.weight, constant_weight)
		    nn.init.constant_(m.bias, 0)


    def forward(self, x):
	# flatten image input
	x = x.view(-1, 28 * 28)
	# add hidden layer, with relu activation function
	x = F.relu(self.fc1(x))
	# add dropout layer
	x = self.dropout(x)
	# add hidden layer, with relu activation function
	x = F.relu(self.fc2(x))
	# add dropout layer
	x = self.dropout(x)
	# add output layer
	x = self.fc3(x)
	return x
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org4fd5786" class="outline-2"&gt;
&lt;h2 id="org4fd5786"&gt;Compare Model Behavior&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org4fd5786"&gt;
&lt;p&gt;
Below, we are using &lt;code&gt;helpers.compare_init_weights&lt;/code&gt; to compare the training and validation loss for the two models we defined above, &lt;code&gt;model_0&lt;/code&gt; and &lt;code&gt;model_1&lt;/code&gt;.  This function takes in a list of models (each with different initial weights), the name of the plot to produce, and the training and validation dataset loaders. For each given model, it will plot the training loss for the first 100 batches and print out the validation accuracy after 2 training epochs. &lt;b&gt;Note: if you've used a small batch_size, you may want to increase the number of epochs here to better compare how models behave after seeing a few hundred images.&lt;/b&gt; 
&lt;/p&gt;

&lt;p&gt;
We plot the loss over the first 100 batches to better judge which model weights performed better at the start of training. &lt;b&gt;&lt;b&gt;I recommend that you take a look at the code in &lt;code&gt;helpers.py&lt;/code&gt; to look at the details behind how the models are trained, validated, and compared.&lt;/b&gt;&lt;/b&gt;
&lt;/p&gt;

&lt;p&gt;
Run the cell below to see the difference between weights of all zeros against all ones.
&lt;/p&gt;

&lt;p&gt;
Initialize two NN's with 0 and 1 constant weights.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model_0 = Net(constant_weight=0)
model_1 = Net(constant_weight=1)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Put them in list form to compare.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model_list = [(model_0, 'All Zeros'),
	      (model_1, 'All Ones')]
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ModelLabel = Tuple[nn.Module, str]
ModelLabels = Collection[ModelLabel]
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def plot_models(title:str, models_labels:ModelLabels):
    """Plots the models

    Args:
     title: the title for the plots
     models_labels: collections of model, plot-label tuples
    """
    figure, axe = pyplot.subplots()
    figure.suptitle(title, weight="bold")    
    axe.set_xlabel("Batches")
    axe.set_ylabel("Loss")

    for model, label in models_labels:
	loss, validation_accuracy = helpers._get_loss_acc(model, train_loader, valid_loader)
	axe.plot(loss[:100], label=label)
    legend = axe.legend()
    return
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Plot the loss over the first 100 batches.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;plot_models("All Zeros vs All Ones",
	    ((model_0, "All Zeros"),
	     (model_1, "All ones")))
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/zeros_ones.png" alt="zeros_ones.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
After 2 Epochs:
Validation Accuracy
    9.475% -- All Zeros
   10.175% -- All Ones
Training Loss
    2.304  -- All Zeros
  1914.703  -- All Ones
&lt;/pre&gt;

&lt;p&gt;
As you can see the accuracy is close to guessing for both zeros and ones, around 10%.
&lt;/p&gt;

&lt;p&gt;
The neural network is having a hard time determining which weights need to be changed, since the neurons have the same output for each layer.  To avoid neurons with the same output, let's use unique weights.  We can also randomly select these weights to avoid being stuck in a local minimum for each run.
&lt;/p&gt;

&lt;p&gt;
A good solution for getting these random weights is to sample from a uniform distribution.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga039f5b" class="outline-3"&gt;
&lt;h3 id="orga039f5b"&gt;Uniform Distribution&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga039f5b"&gt;
&lt;p&gt;
A &lt;a href="https://en.wikipedia.org/wiki/Uniform_distribution"&gt;uniform distribution&lt;/a&gt; has the equal probability of picking any number from a set of numbers. We'll be picking from a continuous distribution, so the chance of picking the same number is low. We'll use NumPy's &lt;code&gt;np.random.uniform&lt;/code&gt; function to pick random numbers from a uniform distribution.
&lt;/p&gt;

&lt;p&gt;
&lt;a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.uniform.html"&gt;&lt;code&gt;np.random_uniform(low=0.0, high=1.0, size=None)&lt;/code&gt;&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
Outputs random values from a uniform distribution.
&lt;/p&gt;

&lt;p&gt;
The generated values follow a uniform distribution in the range [low, high). The lower bound minval is included in the range, while the upper bound maxval is excluded.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;&lt;b&gt;low:&lt;/b&gt;&lt;/b&gt; The lower bound on the range of random values to generate. Defaults to 0.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;&lt;b&gt;high:&lt;/b&gt;&lt;/b&gt; The upper bound on the range of random values to generate. Defaults to 1.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;&lt;b&gt;size:&lt;/b&gt;&lt;/b&gt; An int or tuple of ints that specify the shape of the output array.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
We can visualize the uniform distribution by using a histogram. Let's map the values from &lt;code&gt;np.random_uniform(-3, 3, [1000])&lt;/code&gt; to a histogram using the &lt;code&gt;helper.hist_dist&lt;/code&gt; function. This will be &lt;code&gt;1000&lt;/code&gt; random float values from &lt;code&gt;-3&lt;/code&gt; to &lt;code&gt;3&lt;/code&gt;, excluding the value &lt;code&gt;3&lt;/code&gt;.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;figure, axe = pyplot.subplots()
figure.suptitle("Random Uniform", weight="bold")
data = numpy.random.uniform(-3, 3, [1000])
grid = seaborn.distplot(data)
#helpers.hist_dist('Random Uniform (low=-3, high=3)', )
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/uniform_distribution.png" alt="uniform_distribution.png"&gt;
&lt;/p&gt;
&lt;/div&gt;




&lt;p&gt;
Now that you understand the uniform function, let's use PyTorch's &lt;code&gt;nn.init&lt;/code&gt; to apply it to a model's initial weights.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3d3c1f5" class="outline-3"&gt;
&lt;h3 id="org3d3c1f5"&gt;Uniform Initialization, Baseline&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org3d3c1f5"&gt;
&lt;p&gt;
Let's see how well the neural network trains using a uniform weight initialization, where &lt;code&gt;low=0.0&lt;/code&gt; and &lt;code&gt;high=1.0&lt;/code&gt;. Below, I'll show you another way (besides in the Net class code) to initialize the weights of a network. To define weights outside of the model definition, you can:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Define a function that assigns weights by the type of network layer, &lt;b&gt;then&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;Apply those weights to an initialized model using &lt;code&gt;model.apply(fn)&lt;/code&gt;, which applies a function to each model layer.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
This time, we'll use &lt;code&gt;weight.data.uniform_&lt;/code&gt; to initialize the weights of our model, directly.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def weights_init_uniform(m: nn.Module, start=0.0, stop=1.0) -&amp;gt; None:
    """takes in a module and applies the specified weight initialization

    Args:
     m: A model instance
    """
    classname = m.__class__.__name__
    # for every Linear layer in a model..
    if classname.startswith('Linear'):
	# apply a uniform distribution to the weights and a bias=0
	m.weight.data.uniform_(start, stop)
	m.bias.data.fill_(0)
    return
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbc12664" class="outline-4"&gt;
&lt;h4 id="orgbc12664"&gt;Create A New Model With These Weights&lt;/h4&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1f18296" class="outline-4"&gt;
&lt;h4 id="org1f18296"&gt;Evaluate Behavior&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org1f18296"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model_uniform = Net()
model_uniform.apply(weights_init_uniform)
plot_models("Uniform Baseline", ((model_uniform, "UNIFORM WEIGHTS"),))
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/uniform_weights.png" alt="uniform_weights.png"&gt;
&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;
The loss graph is showing the neural network is learning, which it didn't with all zeros or all ones. We're headed in the right direction!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8e0922c" class="outline-2"&gt;
&lt;h2 id="org8e0922c"&gt;General rule for setting weights&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8e0922c"&gt;
&lt;p&gt;
The general rule for setting the weights in a neural network is to set them to be close to zero without being too small. A good practice is to start your weights in the range of \([-y, y]\) where \(y=1/\sqrt{n}\) (\(n\) is the number of inputs to a given neuron).
&lt;/p&gt;

&lt;p&gt;
Let's see if this holds true; let's create a baseline to compare with and center our uniform range over zero by shifting it over by 0.5.  This will give us the range [-0.5, 0.5).
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;weights_init_uniform_center = partial(weights_init_uniform, -0.5, 0.5)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org79736f6" class="outline-3"&gt;
&lt;h3 id="org79736f6"&gt;create a new model with these weights&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org79736f6"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model_centered = Net()
model_centered.apply(weights_init_uniform_center)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
Now let's create a distribution and model that uses the &lt;b&gt;&lt;b&gt;general rule&lt;/b&gt;&lt;/b&gt; for weight initialization; using the range \([-y, y]\), where \(y=1/\sqrt{n}\) .
&lt;/p&gt;

&lt;p&gt;
And finally, we'll compare the two models.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def weights_init_uniform_rule(m: nn.Module) -&amp;gt; None:
    """takes in a module and applies the specified weight initialization

    Args:
     m: Model instance
    """
    classname = m.__class__.__name__
    # for every Linear layer in a model..
    if classname.find('Linear') != -1:
	# get the number of the inputs
	n = m.in_features
	y = 1.0/numpy.sqrt(n)
	m.weight.data.uniform_(-y, y)
	m.bias.data.fill_(0)
    return
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model_rule = Net()
model_rule.apply(weights_init_uniform_rule)
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;plot_models("Uniform Centered vs General Rule", (
    (model_centered, 'Centered Weights [-0.5, 0.5)'), 
    (model_rule, 'General Rule [-y, y)'),
))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/general_rule.png" alt="general_rule.png"&gt;
This behavior is really promising! Not only is the loss decreasing, but it seems to do so very quickly for our uniform weights that follow the general rule; after only two epochs we get a fairly high validation accuracy and this should give you some intuition for why starting out with the right initial weights can really help your training process!
&lt;/p&gt;

&lt;p&gt;
Since the uniform distribution has the same chance to pick &lt;b&gt;any value&lt;/b&gt; in a range, what if we used a distribution that had a higher chance of picking numbers closer to 0?  Let's look at the normal distribution.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9c3f8a2" class="outline-2"&gt;
&lt;h2 id="org9c3f8a2"&gt;Normal Distribution&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9c3f8a2"&gt;
&lt;p&gt;
Unlike the uniform distribution, the &lt;a href="https://en.wikipedia.org/wiki/Normal_distribution"&gt;normal distribution&lt;/a&gt; has a higher likelihood of picking number close to it's mean. To visualize it, let's plot values from NumPy's &lt;code&gt;np.random.normal&lt;/code&gt; function to a histogram.
&lt;/p&gt;

&lt;p&gt;
&lt;a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.normal.html"&gt;np.random.normal(loc=0.0, scale=1.0, size=None)&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
Outputs random values from a normal distribution.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;b&gt;&lt;b&gt;loc:&lt;/b&gt;&lt;/b&gt; The mean of the normal distribution.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;&lt;b&gt;scale:&lt;/b&gt;&lt;/b&gt; The standard deviation of the normal distribution.&lt;/li&gt;
&lt;li&gt;&lt;b&gt;&lt;b&gt;shape:&lt;/b&gt;&lt;/b&gt; The shape of the output array.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;figure, axe = pyplot.subplots()
figure.suptitle("Standard Normal Distribution", weight="bold")
grid = seaborn.distplot(numpy.random.normal(size=[1000]))
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/normal_distribution.png" alt="normal_distribution.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Let's compare the normal distribution against the previous, rule-based, uniform distribution.
&lt;/p&gt;

&lt;p&gt;
The normal distribution should have a mean of 0 and a standard deviation of \(y=1/\sqrt{n}\)
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def weights_init_normal(m: nn.Module) -&amp;gt; None:
    '''Takes in a module and initializes all linear layers with weight
       values taken from a normal distribution.'''

    classname = m.__class__.__name__
    if classname.startswith("Linear"):    
	m.weight.data.normal_(mean=0, std=1/numpy.sqrt(m.in_features))
	m.bias.data.fill_(0)
    return
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
create a new model with the rule-based, uniform weights
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model_uniform_rule = Net()
model_uniform_rule.apply(weights_init_uniform_rule)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
create a new model with the rule-based, NORMAL weights
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model_normal_rule = Net()
model_normal_rule.apply(weights_init_normal)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
compare the two models
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;plot_models('Uniform vs Normal',
	    ((model_uniform_rule, 'Uniform Rule [-y, y)'), 
	     (model_normal_rule, 'Normal Distribution')))
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/normal_vs_uniform.png" alt="normal_vs_uniform.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
The normal distribution gives us pretty similar behavior compared to the uniform distribution, in this case. This is likely because our network is so small; a larger neural network will pick more weight values from each of these distributions, magnifying the effect of both initialization styles. In general, a normal distribution will result in better performance for a model.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf5d273c" class="outline-2"&gt;
&lt;h2 id="orgf5d273c"&gt;Automatic Initialization&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf5d273c"&gt;
&lt;p&gt;
Let's quickly take a look at what happens &lt;b&gt;without any explicit weight initialization&lt;/b&gt;.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf34cb2b" class="outline-3"&gt;
&lt;h3 id="orgf34cb2b"&gt;Instantiate a model with &lt;span class="underline"&gt;no&lt;/span&gt; explicit weight initialization&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org635213f" class="outline-2"&gt;
&lt;h2 id="org635213f"&gt;evaluate the behavior using helpers&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org635213f"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model_normal_rule = Net()
model_normal_rule.apply(weights_init_normal)
model_default = Net()
model_rule = Net()
model_rule.apply(weights_init_uniform_rule)

plot_models("Default vs Normal vs General Rule", (
    (model_default, "Default"),
    (model_normal_rule, "Normal"),
    (model_rule, "General Rule")))
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/default.png" alt="default.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
They all sort of look the same at this point.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cnn</category><category>exercise</category><guid>https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/weight-initialization/</guid><pubDate>Mon, 17 Dec 2018 21:03:41 GMT</pubDate></item><item><title>CIFAR-10</title><link>https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/#orgaa64591"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/#org09b8281"&gt;Set Up&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/#orga4ed925"&gt;Visualize a Batch of Training Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/#orgaaa2b72"&gt;Define the Network Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/#org38a470f"&gt;Define a model with multiple convolutional layers, and define the feedforward network behavior.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/#org4941714"&gt;Output volume for a convolutional layer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/#orgee4917f"&gt;Specify Loss Function and Optimizer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/#org9c9cbbe"&gt;Train the Network&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/#org6e38a61"&gt;Load the Model with the Lowest Validation Loss&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/#orgb910f79"&gt;Test the Trained Network&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/#orgb32b8e5"&gt;Make it Easier&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/#org3635ad8"&gt;Take two&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/#orgd200933"&gt;Change the Training and Validation Sets&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgaa64591" class="outline-2"&gt;
&lt;h2 id="orgaa64591"&gt;Introduction&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgaa64591"&gt;
&lt;p&gt;
This is from &lt;a href="https://github.com/udacity/deep-learning-v2-pytorch.git"&gt;Udacity's Deep Learning Repository&lt;/a&gt; which supports their Deep Learning Nanodegree. This will use a &lt;b&gt;Convolutional Neural Network (CNN)&lt;/b&gt; to classify images from the &lt;a href="https://en.wikipedia.org/wiki/CIFAR-10"&gt;CIFAR-10&lt;/a&gt; data set.
&lt;/p&gt;

&lt;p&gt;
The images in this data set are small color images that fall into one of ten classes:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;airplane&lt;/li&gt;
&lt;li&gt;automobile&lt;/li&gt;
&lt;li&gt;bird&lt;/li&gt;
&lt;li&gt;cat&lt;/li&gt;
&lt;li&gt;deer&lt;/li&gt;
&lt;li&gt;dog&lt;/li&gt;
&lt;li&gt;frog&lt;/li&gt;
&lt;li&gt;horse&lt;/li&gt;
&lt;li&gt;ship&lt;/li&gt;
&lt;li&gt;truck&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
There is another description of it on the &lt;a href="https://www.cs.toronto.edu/~kriz/cifar.html"&gt;University of Toronto's&lt;/a&gt; page for it.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org09b8281" class="outline-2"&gt;
&lt;h2 id="org09b8281"&gt;Set Up&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org09b8281"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1c804d5" class="outline-3"&gt;
&lt;h3 id="org1c804d5"&gt;Imports&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1c804d5"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb5a11cf" class="outline-4"&gt;
&lt;h4 id="orgb5a11cf"&gt;From Python&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgb5a11cf"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from datetime import datetime
from pathlib import Path
from typing import Tuple
import os
import pickle
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc3a25f3" class="outline-4"&gt;
&lt;h4 id="orgc3a25f3"&gt;From PyPi&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgc3a25f3"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from dotenv import load_dotenv
from sklearn.model_selection import train_test_split
from torchvision import datasets
from torch.utils.data.sampler import SubsetRandomSampler
import matplotlib.pyplot as pyplot
import numpy
import seaborn
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optimize
import torchvision.transforms as transforms
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc863dfc" class="outline-4"&gt;
&lt;h4 id="orgc863dfc"&gt;This Project&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgc863dfc"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from neurotic.tangles.data_paths import DataPathTwo
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org6633d2d" class="outline-3"&gt;
&lt;h3 id="org6633d2d"&gt;Plotting&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org6633d2d"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;get_ipython().run_line_magic('matplotlib', 'inline')
get_ipython().run_line_magic('config', "InlineBackend.figure_format = 'retina'")
seaborn.set(style="whitegrid",
	    rc={"axes.grid": False,
		"font.family": ["sans-serif"],
		"font.sans-serif": ["Latin Modern Sans", "Lato"],
		"figure.figsize": (8, 6)},
	    font_scale=3)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb8c7b20" class="outline-3"&gt;
&lt;h3 id="orgb8c7b20"&gt;Test for &lt;a href="http://pytorch.org/docs/stable/cuda.html"&gt;CUDA&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb8c7b20"&gt;
&lt;p&gt;
The test-code uses the check later on so I'll save it to the &lt;code&gt;train_on_gpu&lt;/code&gt; variable.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if os.environ.get("USER") == "brunhilde":
    train_on_gpu = False
    device = torch.device("cpu")
else:
    train_on_gpu = torch.cuda.is_available()
    device = torch.device("cuda:0" if train_on_gpu else "cpu")
print("Using: {}".format(device))
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Using: cuda:0

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4a63aa9" class="outline-3"&gt;
&lt;h3 id="org4a63aa9"&gt;Load the &lt;a href="http://pytorch.org/docs/stable/torchvision/datasets.html"&gt;Data&lt;/a&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org4a63aa9"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# subprocesses to use
NUM_WORKERS = 0
# how many samples per batch to load
BATCH_SIZE = 20
# percentage of training set to use as validation
VALIDATION_FRACTION = 0.2

IMAGE_SIZE = 32
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Convert the data to a normalized &lt;code&gt;torch.FloatTensor&lt;/code&gt; using a pipeline. I'm also going to introduce some randomness to help the model generalize.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;means = deviations = (0.5, 0.5, 0.5)
train_transform = transforms.Compose([
    transforms.RandomRotation(30),
    transforms.RandomResizedCrop(IMAGE_SIZE),
    transforms.RandomHorizontalFlip(),
    transforms.ToTensor(),
    transforms.Normalize(means, deviations)
    ])
test_transforms = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize(means,
			 deviations)])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Choose the training and test datasets.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;load_dotenv()
path = DataPathTwo(folder_key="CIFAR")
print(path.folder)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
/home/hades/datasets/CIFAR

&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;training_data = datasets.CIFAR10(path.folder, train=True,
			      download=True, transform=train_transform)
test_data = datasets.CIFAR10(path.folder, train=False,
			     download=True, transform=test_transforms)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Files already downloaded and verified
Files already downloaded and verified

&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for item in path.folder.iterdir():
    print(item)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
/home/hades/datasets/CIFAR/cifar-10-batches-py
/home/hades/datasets/CIFAR/cifar-10-python.tar.gz

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org25bc7e2" class="outline-3"&gt;
&lt;h3 id="org25bc7e2"&gt;Obtain Training Indices For Validation&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org25bc7e2"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;indices = list(range(len(training_data)))
training_indices, validation_indices = train_test_split(
    indices,
    test_size=VALIDATION_FRACTION)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org70983a2" class="outline-3"&gt;
&lt;h3 id="org70983a2"&gt;Define Samplers For Training And Validation Batches&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org70983a2"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;train_sampler = SubsetRandomSampler(training_indices)
valid_sampler = SubsetRandomSampler(validation_indices)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org300d7b9" class="outline-3"&gt;
&lt;h3 id="org300d7b9"&gt;Prepare Data Loaders&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org300d7b9"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;train_loader = torch.utils.data.DataLoader(training_data, batch_size=BATCH_SIZE,
    sampler=train_sampler, num_workers=NUM_WORKERS)
valid_loader = torch.utils.data.DataLoader(training_data, batch_size=BATCH_SIZE, 
    sampler=valid_sampler, num_workers=NUM_WORKERS)
test_loader = torch.utils.data.DataLoader(test_data, batch_size=BATCH_SIZE, 
    num_workers=NUM_WORKERS)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org54c3e9c" class="outline-3"&gt;
&lt;h3 id="org54c3e9c"&gt;The Image Classes&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org54c3e9c"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;classes = ['airplane', 'automobile', 'bird', 'cat', 'deer',
	   'dog', 'frog', 'horse', 'ship', 'truck']
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga4ed925" class="outline-2"&gt;
&lt;h2 id="orga4ed925"&gt;Visualize a Batch of Training Data&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orga4ed925"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb42323a" class="outline-3"&gt;
&lt;h3 id="orgb42323a"&gt;helper function to un-normalize and display an image&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb42323a"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def imshow(img):
    img = img / 2 + 0.5  # unnormalize
    pyplot.imshow(numpy.transpose(img, (1, 2, 0)))  # convert from Tensor image
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org47f08b6" class="outline-3"&gt;
&lt;h3 id="org47f08b6"&gt;obtain one batch of training images&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org47f08b6"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dataiter = iter(train_loader)
images, labels = dataiter.next()
images = images.numpy() # convert images to numpy for display
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfea0211" class="outline-3"&gt;
&lt;h3 id="orgfea0211"&gt;plot the images in the batch, along with the corresponding labels&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgfea0211"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;figure = pyplot.figure(figsize=(25, 4))
# display 20 images
figure.suptitle("Batch Sample", weight="bold")
for idx in numpy.arange(20):
    ax = figure.add_subplot(2, 20/2, idx+1, xticks=[], yticks=[])
    imshow(images[idx])
    ax.set_title(classes[labels[idx]])
#pyplot.subplots_adjust(top=0.7)
pyplot.tight_layout(rect=[0, 0.03, 1, 0.95])
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/batch.png" alt="batch.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orga68c35b" class="outline-3"&gt;
&lt;h3 id="orga68c35b"&gt;View an Image in More Detail&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga68c35b"&gt;
&lt;p&gt;
Here, we look at the normalized red, green, and blue (RGB) color channels as three separate, grayscale intensity images.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;rgb_img = numpy.squeeze(images[3])
channels = ['red channel', 'green channel', 'blue channel']

fig = pyplot.figure(figsize = (36, 36)) 
for idx in numpy.arange(rgb_img.shape[0]):
    ax = fig.add_subplot(1, 3, idx + 1)
    img = rgb_img[idx]
    ax.imshow(img, cmap='gray')
    ax.set_title(channels[idx])
    width, height = img.shape
    thresh = img.max()/2.5
    for x in range(width):
	for y in range(height):
	    val = round(img[x][y],2) if img[x][y] !=0 else 0
	    ax.annotate(str(val), xy=(y,x),
		    horizontalalignment='center',
		    verticalalignment='center', size=8,
		    color='white' if img[x][y]&amp;lt;thresh else 'black')
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/rgb.png" alt="rgb.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgaaa2b72" class="outline-2"&gt;
&lt;h2 id="orgaaa2b72"&gt;Define the Network &lt;a href="http://pytorch.org/docs/stable/nn.html"&gt;Architecture&lt;/a&gt;&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgaaa2b72"&gt;
&lt;p&gt;
This time, you'll define a CNN architecture. Instead of an MLP, which used linear, fully-connected layers, you'll use the following:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://pytorch.org/docs/stable/nn.html#conv2d"&gt;Convolutional layers&lt;/a&gt;, which can be thought of as stack of filtered images.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pytorch.org/docs/stable/nn.html#maxpool2d"&gt;Maxpooling layers&lt;/a&gt;, which reduce the x-y size of an input, keeping only the most &lt;i&gt;active&lt;/i&gt; pixels from the previous layer.&lt;/li&gt;
&lt;li&gt;The usual Linear + Dropout layers to avoid overfitting and produce a 10-dim output.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org38a470f" class="outline-2"&gt;
&lt;h2 id="org38a470f"&gt;Define a model with multiple convolutional layers, and define the feedforward network behavior.&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org38a470f"&gt;
&lt;p&gt;
The more convolutional layers you include, the more complex patterns in color and shape a model can detect. It's suggested that your final model include 2 or 3 convolutional layers as well as linear layers + dropout in between to avoid overfitting. 
&lt;/p&gt;

&lt;p&gt;
It's good practice to look at existing research and implementations of related models as a starting point for defining your own models. You may find it useful to look at &lt;a href="https://github.com/pytorch/tutorials/blob/master/beginner_source/blitz/cifar10_tutorial.py"&gt;this PyTorch classification example&lt;/a&gt; or &lt;a href="https://github.com/keras-team/keras/blob/master/examples/cifar10_cnn.py"&gt;this, more complex Keras example&lt;/a&gt; to help decide on a final structure.
&lt;/p&gt;

&lt;p&gt;
This is taken from the &lt;a href="https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html#training-an-image-classifier"&gt;pytorch tutorial&lt;/a&gt;, with padding and dropout added. I also changed the kernel size to 3.
&lt;/p&gt;

&lt;p&gt;
See:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;a href="https://pytorch.org/docs/stable/nn.html?highlight=conv2d#torch.nn.Conv2d"&gt;Conv2d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pytorch.org/docs/stable/nn.html?highlight=nn%20maxpool#torch.nn.MaxPool2d"&gt;MaxPool2d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pytorch.org/docs/stable/nn.html#linear-layers"&gt;Linear&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pytorch.org/docs/stable/nn.html#dropout-layers"&gt;Dropout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pytorch.org/docs/stable/tensors.html?highlight=view#torch.Tensor.view"&gt;view&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;KERNEL_SIZE = 3
CHANNELS_IN = 3
CHANNELS_OUT_1 = 6
CHANNELS_OUT_2 = 16
CLASSES = 10
PADDING = 1
STRIDE = 1
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;convolutional_1 = nn.Conv2d(CHANNELS_IN, CHANNELS_OUT_1,
			    KERNEL_SIZE, 
			    stride=STRIDE, padding=PADDING)
pool = nn.MaxPool2d(2, 2)
convolutional_2 = nn.Conv2d(CHANNELS_OUT_1, CHANNELS_OUT_2,
			    KERNEL_SIZE,
			    stride=STRIDE, padding=PADDING)

c_no_padding_1 = nn.Conv2d(CHANNELS_IN, CHANNELS_OUT_1, KERNEL_SIZE)
c_no_padding_2 = nn.Conv2d(CHANNELS_OUT_1, CHANNELS_OUT_2, KERNEL_SIZE)
fully_connected_1 = nn.Linear(CHANNELS_OUT_2 * (KERNEL_SIZE + PADDING)**3, 120)
fully_connected_1A = nn.Linear(CHANNELS_OUT_2 * (KERNEL_SIZE)**2, 120)
fully_connected_2 = nn.Linear(120, 84)
fully_connected_3 = nn.Linear(84, CLASSES)
cnn_dropout = nn.Dropout(0.25)
connected_dropout = nn.Dropout(0.5)

dataiter = iter(train_loader)
images, labels = dataiter.next()
input_image = torch.Tensor(images)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print("Input Shape: {}".format(input_image.shape))
x = cnn_dropout(pool(F.relu(convolutional_1(input_image))))
print("Output 1: {}".format(x.shape))
x = cnn_dropout(pool(F.relu(convolutional_2(x))))
print("Output 2: {}".format(x.shape))
x = x.view(x.size()[0], -1)
print("reshaped: {}".format(x.shape))
x = connected_dropout(F.relu(fully_connected_1(x)))
print("Connected Shape: {}".format(x.shape))
x = F.relu(fully_connected_2(x))
print("Connected Shape 2: {}".format(x.shape))
x = fully_connected_3(x)
print("Connected Shape 3: {}".format(x.shape))
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Input Shape: torch.Size([20, 3, 32, 32])
Output 1: torch.Size([20, 6, 16, 16])
Output 2: torch.Size([20, 16, 8, 8])
reshaped: torch.Size([20, 1024])
Connected Shape: torch.Size([20, 120])
Connected Shape 2: torch.Size([20, 84])
Connected Shape 3: torch.Size([20, 10])

&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print("Input Shape: {}".format(input_image.shape))
x = cnn_dropout(pool(F.relu(c_no_padding_1(input_image))))
print("Output 1: {}".format(x.shape))
x = cnn_dropout(pool(F.relu(c_no_padding_2(x))))
print("Output 2: {}".format(x.shape))
x = x.view(-1, CHANNELS_OUT_2 * (KERNEL_SIZE)**2)
print("reshaped: {}".format(x.shape))
x = connected_dropout(F.relu(fully_connected_1A(x)))
print("Connected Shape: {}".format(x.shape))
x = F.relu(fully_connected_2(x))
print("Connected Shape 2: {}".format(x.shape))
x = fully_connected_3(x)
print("Connected Shape 3: {}".format(x.shape))
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Input Shape: torch.Size([20, 3, 32, 32])
Output 1: torch.Size([20, 6, 15, 15])
Output 2: torch.Size([20, 16, 6, 6])
reshaped: torch.Size([80, 144])
Connected Shape: torch.Size([80, 120])
Connected Shape 2: torch.Size([80, 84])
Connected Shape 3: torch.Size([80, 10])

&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;class CNN(nn.Module):
    """A convolutional neural network for CIFAR-10 images"""
    def __init__(self, filter_size=5) -&amp;gt; None:
	super().__init__()
	self.convolutional_1 = nn.Conv2d(CHANNELS_IN, CHANNELS_OUT_1,
					 KERNEL_SIZE, 
					 stride=STRIDE, padding=PADDING)
	self.pool = nn.MaxPool2d(2, 2)
	self.convolutional_2 = nn.Conv2d(CHANNELS_OUT_1, CHANNELS_OUT_2,
					 KERNEL_SIZE,
					 stride=STRIDE, padding=PADDING)
	self.fully_connected_1 = nn.Linear(CHANNELS_OUT_2 * (KERNEL_SIZE + PADDING)**3, 120)
	self.fully_connected_2 = nn.Linear(120, 84)
	self.fully_connected_3 = nn.Linear(84, CLASSES)
	self.cnn_dropout = nn.Dropout(0.25)
	self.connected_dropout = nn.Dropout(0.5)
	return

    def forward(self, x: torch.Tensor) -&amp;gt; torch.Tensor:
	"""Passes the image through the layers of the network

	Args:
	 image: CIFAR image to process
	"""
	x = self.cnn_dropout(self.pool(F.relu(self.convolutional_1(x))))
	x = self.cnn_dropout(self.pool(F.relu(self.convolutional_2(x))))
	# flatten to a vector
	x = x.view(x.size()[0], -1)
	x = self.connected_dropout(F.relu(self.fully_connected_1(x)))
	x = F.relu(self.fully_connected_2(x))
	return self.fully_connected_3(x)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model = CNN()
dataiter = iter(train_loader)
images, labels = dataiter.next()
print(images.shape)
print(labels.shape)
output = model(images)
print(output.shape)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
torch.Size([20, 3, 32, 32])
torch.Size([20])
torch.Size([20, 10])

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4941714" class="outline-2"&gt;
&lt;h2 id="org4941714"&gt;Output volume for a convolutional layer&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org4941714"&gt;
&lt;p&gt;
To compute the output size of a given convolutional layer we can perform the following calculation (taken from &lt;a href="http://cs231n.github.io/convolutional-networks/#layers"&gt;Stanford's cs231n course&lt;/a&gt;):
&lt;/p&gt;

&lt;p&gt;
We can compute the spatial size of the output volume as a function of the input volume size (W), the kernel/filter size (F), the stride with which they are applied (S), and the amount of zero padding used (P) on the border. The correct formula for calculating how many neurons define the output_W is given by &lt;code&gt;(W−F+2P)/S+1&lt;/code&gt;. 
&lt;/p&gt;

&lt;p&gt;
For example for a 7x7 input and a 3x3 filter with stride 1 and pad 0 we would get a 5x5 output. With stride 2 we would get a 3x3 output.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgee4917f" class="outline-2"&gt;
&lt;h2 id="orgee4917f"&gt;Specify &lt;a href="http://pytorch.org/docs/stable/nn.html#loss-functions"&gt;Loss Function&lt;/a&gt; and &lt;a href="http://pytorch.org/docs/stable/optim.html"&gt;Optimizer&lt;/a&gt;&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgee4917f"&gt;
&lt;p&gt;
Decide on a loss and optimization function that is best suited for this classification task. The linked code examples from above, may be a good starting point; &lt;a href="https://github.com/pytorch/tutorials/blob/master/beginner_source/blitz/cifar10_tutorial.py"&gt;this PyTorch classification example&lt;/a&gt; or &lt;a href="https://github.com/keras-team/keras/blob/master/examples/cifar10_cnn.py"&gt;this, more complex Keras example&lt;/a&gt;. Pay close attention to the value for &lt;b&gt;&lt;b&gt;learning rate&lt;/b&gt;&lt;/b&gt; as this value determines how your model converges to a small error.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;criterion = nn.CrossEntropyLoss()
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9c9cbbe" class="outline-2"&gt;
&lt;h2 id="org9c9cbbe"&gt;Train the Network&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9c9cbbe"&gt;
&lt;p&gt;
Remember to look at how the training and validation loss decreases over time; if the validation loss ever increases it indicates possible overfitting.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def train(model: nn.Module, epochs: int=10, model_number: int=0, 
	  epoch_offset: int=1, print_every: int=10) -&amp;gt; tuple:
    """Train, validate, and save the model
    This trains the model and validates it, saving the best 
    (based on validation loss) as =model_&amp;lt;number&amp;gt;_cifar.pth=

    Args:
     model: the network to train
     epochs: number of times to repeat training
     model_number: an identifier for the saved hyperparameters file
     epoch_offset: amount of epochs that have occurred previously
     print_every: how often to print output
    Returns:
     filename, training-loss, validation-loss, improvements: the outcomes for the training
    """
    optimizer = optimize.SGD(model.parameters(), lr=0.001, momentum=0.9)
    criterion = nn.CrossEntropyLoss()
    output_file = "model_{}_cifar.pth".format(model_number)
    training_losses = []
    validation_losses = []
    improvements = []
    valid_loss_min = numpy.Inf # track change in validation loss
    epoch_start = epoch_offset
    last_epoch = epoch_start + epochs + 1
    for epoch in range(epoch_start, last_epoch):

	# keep track of training and validation loss
	train_loss = 0.0
	valid_loss = 0.0

	model.train()
	for data, target in train_loader:
	    # move tensors to GPU if CUDA is available            
	    data, target = data.to(device), target.to(device)
	    # clear the gradients of all optimized variables
	    optimizer.zero_grad()
	    # forward pass: compute predicted outputs by passing inputs to the model
	    output = model(data)
	    # calculate the batch loss
	    loss = criterion(output, target)
	    # backward pass: compute gradient of the loss with respect to model parameters
	    loss.backward()
	    # perform a single optimization step (parameter update)
	    optimizer.step()
	    # update training loss
	    train_loss += loss.item() * data.size(0)

	model.eval()
	for data, target in valid_loader:
	    # move tensors to GPU if CUDA is available
	    data, target = data.to(device), target.to(device)
	    # forward pass: compute predicted outputs by passing inputs to the model
	    output = model(data)
	    # calculate the batch loss
	    loss = criterion(output, target)
	    # update total validation loss 
	    valid_loss += loss.item() * data.size(0)

	# calculate average losses
	train_loss = train_loss/len(train_loader.dataset)
	valid_loss = valid_loss/len(valid_loader.dataset)

	# print training/validation statistics 
	if not (epoch % print_every):
	    print('Epoch: {} \tTraining Loss: {:.6f} \tValidation Loss: {:.6f}'.format(
		epoch, train_loss, valid_loss))
	training_losses.append(train_loss)
	validation_losses.append(valid_loss)
	# save model if validation loss has decreased
	if valid_loss &amp;lt;= valid_loss_min:
	    print('Validation loss decreased ({:.6f} --&amp;gt; {:.6f}).  Saving model ...'.format(
	    valid_loss_min,
	    valid_loss))
	    torch.save(model.state_dict(), output_file)
	    valid_loss_min = valid_loss
	    improvements.append(epoch - 1)
    return output_file, training_losses, validation_losses, improvements
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgacf93e7" class="outline-3"&gt;
&lt;h3 id="orgacf93e7"&gt;Pytorch Tutorial Model&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgacf93e7"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;EPOCHS = 250
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
This is only to avoid re-running the initial training and use the saved model. &lt;b&gt;Note:&lt;/b&gt; If you use DataParallel you need to save the model using &lt;code&gt;model.module.state_dict()&lt;/code&gt; in order to load it later without it. This won't matter if you always use it or never use it, but here I have a model that was trained on a GPU and I'm trying to extend the training with a computer whos GPU is too old for pytorch to use it, so it crashes unless I disable the DataParallel (because I didn't originally save it with &lt;code&gt;model.module.state_dict&lt;/code&gt;). 
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Note 2&lt;/b&gt;: But if you don't have it in DataParallel then don't use &lt;code&gt;model.module.state_dict&lt;/code&gt; because it won't have the &lt;code&gt;module&lt;/code&gt; attribute. 
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def train_and_pickle(model:nn.Module, epochs:int=EPOCHS,
		     model_number:int=2, print_every: int=10) -&amp;gt; dict:
    """Trains and pickles the outcomes of training"""
    path = Path("model_{}_outcomes.pkl".format(model_number))
    existed = False
    epoch_offset = 0
    if path.is_file():
	existed = True
	with path.open("rb") as reader:
	    outcomes = pickle.load(reader)
	    epoch_offset = len(outcomes["training_loss"])
	    model.load_state_dict(torch.load(
		outcome["hyperparameters_file"],
		map_location=device))
    filename, training_loss, validation_loss, improvements  = train(
	model,
	epochs=epochs,
	model_number=model_number,
	epoch_offset=epoch_offset,
	print_every=print_every,
	)

    if existed:
	outcomes["training_loss"] += outcomes["training_loss"]
	outcomes["validation_loss"] += outcomes["validation_loss"]
	outcomes["improvements"] += outcomes["improvements"]
    else:
	outcomes = dict(
	    hyperparameters_file=filename,
	    outcomes_pickle=path.name,
	    training_loss=training_loss,
	    validation_loss=validation_loss,
	    improvements=improvements,
	)
    with path.open("wb") as writer:
	pickle.dump(outcomes, writer)
    return outcomes
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def update_outcome(outcome: dict, new_outcome: dict) -&amp;gt; dict:
    """Updates the lists in the outcome

    Args:
     outcome: original output of train_and_pickle
     new_outcome: new output of train_and_pickle

    Returns:
     outcome: updated outcome
    """
    for key in ("training_loss", "validation_loss", "improvements"):
	outcome[key] += new_outcome[key]
    return outcome
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9dea5ab" class="outline-3"&gt;
&lt;h3 id="org9dea5ab"&gt;First Model Training&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org9dea5ab"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model_2 = CNN()
model_2.to(device)
start = datetime.now()
outcome = train_and_pickle(
    model_2,
    epochs=100,
    model_number=2)
print("Elapsed: {}".format(datetime.now() - start))
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Epoch: 0 	Training Loss: 1.834230 	Validation Loss: 0.446434
Validation loss decreased (inf --&amp;gt; 0.446434).  Saving model ...
Epoch: 1 	Training Loss: 1.685185 	Validation Loss: 0.403314
Validation loss decreased (0.446434 --&amp;gt; 0.403314).  Saving model ...
Epoch: 2 	Training Loss: 1.602409 	Validation Loss: 0.389758
Validation loss decreased (0.403314 --&amp;gt; 0.389758).  Saving model ...
Epoch: 3 	Training Loss: 1.551087 	Validation Loss: 0.376669
Validation loss decreased (0.389758 --&amp;gt; 0.376669).  Saving model ...
Epoch: 4 	Training Loss: 1.524230 	Validation Loss: 0.371581
Validation loss decreased (0.376669 --&amp;gt; 0.371581).  Saving model ...
Epoch: 5 	Training Loss: 1.496748 	Validation Loss: 0.367056
Validation loss decreased (0.371581 --&amp;gt; 0.367056).  Saving model ...
Epoch: 6 	Training Loss: 1.479645 	Validation Loss: 0.359889
Validation loss decreased (0.367056 --&amp;gt; 0.359889).  Saving model ...
Epoch: 7 	Training Loss: 1.462357 	Validation Loss: 0.358887
Validation loss decreased (0.359889 --&amp;gt; 0.358887).  Saving model ...
Epoch: 8 	Training Loss: 1.454448 	Validation Loss: 0.353885
Validation loss decreased (0.358887 --&amp;gt; 0.353885).  Saving model ...
Epoch: 9 	Training Loss: 1.442392 	Validation Loss: 0.349046
Validation loss decreased (0.353885 --&amp;gt; 0.349046).  Saving model ...
Epoch: 10 	Training Loss: 1.435758 	Validation Loss: 0.345204
Validation loss decreased (0.349046 --&amp;gt; 0.345204).  Saving model ...
Epoch: 11 	Training Loss: 1.428880 	Validation Loss: 0.344610
Validation loss decreased (0.345204 --&amp;gt; 0.344610).  Saving model ...
Epoch: 12 	Training Loss: 1.420400 	Validation Loss: 0.343866
Validation loss decreased (0.344610 --&amp;gt; 0.343866).  Saving model ...
Epoch: 13 	Training Loss: 1.409974 	Validation Loss: 0.341221
Validation loss decreased (0.343866 --&amp;gt; 0.341221).  Saving model ...
Epoch: 14 	Training Loss: 1.400003 	Validation Loss: 0.340469
Validation loss decreased (0.341221 --&amp;gt; 0.340469).  Saving model ...
Epoch: 15 	Training Loss: 1.396430 	Validation Loss: 0.338332
Validation loss decreased (0.340469 --&amp;gt; 0.338332).  Saving model ...
Epoch: 16 	Training Loss: 1.396793 	Validation Loss: 0.338963
Epoch: 17 	Training Loss: 1.391945 	Validation Loss: 0.337340
Validation loss decreased (0.338332 --&amp;gt; 0.337340).  Saving model ...
Epoch: 18 	Training Loss: 1.383872 	Validation Loss: 0.335848
Validation loss decreased (0.337340 --&amp;gt; 0.335848).  Saving model ...
Epoch: 19 	Training Loss: 1.371348 	Validation Loss: 0.335116
Validation loss decreased (0.335848 --&amp;gt; 0.335116).  Saving model ...
Epoch: 20 	Training Loss: 1.374097 	Validation Loss: 0.330697
Validation loss decreased (0.335116 --&amp;gt; 0.330697).  Saving model ...
Epoch: 21 	Training Loss: 1.373342 	Validation Loss: 0.334281
Epoch: 22 	Training Loss: 1.366379 	Validation Loss: 0.331197
Epoch: 23 	Training Loss: 1.366043 	Validation Loss: 0.332052
Epoch: 24 	Training Loss: 1.359814 	Validation Loss: 0.328743
Validation loss decreased (0.330697 --&amp;gt; 0.328743).  Saving model ...
Epoch: 25 	Training Loss: 1.359745 	Validation Loss: 0.328860
Epoch: 26 	Training Loss: 1.353130 	Validation Loss: 0.329480
Epoch: 27 	Training Loss: 1.352457 	Validation Loss: 0.329386
Epoch: 28 	Training Loss: 1.348608 	Validation Loss: 0.331024
Epoch: 29 	Training Loss: 1.346584 	Validation Loss: 0.325815
Validation loss decreased (0.328743 --&amp;gt; 0.325815).  Saving model ...
Epoch: 30 	Training Loss: 1.341498 	Validation Loss: 0.332342
Epoch: 31 	Training Loss: 1.339088 	Validation Loss: 0.325358
Validation loss decreased (0.325815 --&amp;gt; 0.325358).  Saving model ...
Epoch: 32 	Training Loss: 1.347376 	Validation Loss: 0.326178
Epoch: 33 	Training Loss: 1.342424 	Validation Loss: 0.331979
Epoch: 34 	Training Loss: 1.339343 	Validation Loss: 0.324638
Validation loss decreased (0.325358 --&amp;gt; 0.324638).  Saving model ...
Epoch: 35 	Training Loss: 1.332784 	Validation Loss: 0.322740
Validation loss decreased (0.324638 --&amp;gt; 0.322740).  Saving model ...
Epoch: 36 	Training Loss: 1.335403 	Validation Loss: 0.324083
Epoch: 37 	Training Loss: 1.332313 	Validation Loss: 0.334746
Epoch: 38 	Training Loss: 1.329136 	Validation Loss: 0.324193
Epoch: 39 	Training Loss: 1.327429 	Validation Loss: 0.327056
Epoch: 40 	Training Loss: 1.328106 	Validation Loss: 0.327257
Epoch: 41 	Training Loss: 1.330462 	Validation Loss: 0.321711
Validation loss decreased (0.322740 --&amp;gt; 0.321711).  Saving model ...
Epoch: 42 	Training Loss: 1.326317 	Validation Loss: 0.324698
Epoch: 43 	Training Loss: 1.325379 	Validation Loss: 0.324895
Epoch: 44 	Training Loss: 1.322629 	Validation Loss: 0.322434
Epoch: 45 	Training Loss: 1.320261 	Validation Loss: 0.326130
Epoch: 46 	Training Loss: 1.316204 	Validation Loss: 0.325013
Epoch: 47 	Training Loss: 1.315747 	Validation Loss: 0.324042
Epoch: 48 	Training Loss: 1.313305 	Validation Loss: 0.324592
Epoch: 49 	Training Loss: 1.313723 	Validation Loss: 0.318290
Validation loss decreased (0.321711 --&amp;gt; 0.318290).  Saving model ...
Epoch: 50 	Training Loss: 1.313054 	Validation Loss: 0.320845
Epoch: 51 	Training Loss: 1.316062 	Validation Loss: 0.321215
Epoch: 52 	Training Loss: 1.316187 	Validation Loss: 0.319871
Epoch: 53 	Training Loss: 1.312232 	Validation Loss: 0.324769
Epoch: 54 	Training Loss: 1.315246 	Validation Loss: 0.321788
Epoch: 55 	Training Loss: 1.307923 	Validation Loss: 0.318943
Epoch: 56 	Training Loss: 1.316049 	Validation Loss: 0.324919
Epoch: 57 	Training Loss: 1.310584 	Validation Loss: 0.319344
Epoch: 58 	Training Loss: 1.305451 	Validation Loss: 0.320848
Epoch: 59 	Training Loss: 1.309900 	Validation Loss: 0.322148
Epoch: 60 	Training Loss: 1.306200 	Validation Loss: 0.323148
Epoch: 61 	Training Loss: 1.303626 	Validation Loss: 0.322406
Epoch: 62 	Training Loss: 1.304654 	Validation Loss: 0.322471
Epoch: 63 	Training Loss: 1.302740 	Validation Loss: 0.322596
Epoch: 64 	Training Loss: 1.306964 	Validation Loss: 0.323696
Epoch: 65 	Training Loss: 1.301964 	Validation Loss: 0.319375
Epoch: 66 	Training Loss: 1.302925 	Validation Loss: 0.320327
Epoch: 67 	Training Loss: 1.302062 	Validation Loss: 0.319882
Epoch: 68 	Training Loss: 1.299821 	Validation Loss: 0.318813
Epoch: 69 	Training Loss: 1.298885 	Validation Loss: 0.325837
Epoch: 70 	Training Loss: 1.303130 	Validation Loss: 0.320493
Epoch: 71 	Training Loss: 1.301353 	Validation Loss: 0.321375
Epoch: 72 	Training Loss: 1.294933 	Validation Loss: 0.315513
Validation loss decreased (0.318290 --&amp;gt; 0.315513).  Saving model ...
Epoch: 73 	Training Loss: 1.303322 	Validation Loss: 0.322531
Epoch: 74 	Training Loss: 1.298327 	Validation Loss: 0.323503
Epoch: 75 	Training Loss: 1.298817 	Validation Loss: 0.318616
Epoch: 76 	Training Loss: 1.296895 	Validation Loss: 0.323739
Epoch: 77 	Training Loss: 1.301932 	Validation Loss: 0.325410
Epoch: 78 	Training Loss: 1.291901 	Validation Loss: 0.327083
Epoch: 79 	Training Loss: 1.295766 	Validation Loss: 0.317765
Epoch: 80 	Training Loss: 1.295147 	Validation Loss: 0.316187
Epoch: 81 	Training Loss: 1.294392 	Validation Loss: 0.318913
Epoch: 82 	Training Loss: 1.290720 	Validation Loss: 0.320984
Epoch: 83 	Training Loss: 1.296386 	Validation Loss: 0.322005
Epoch: 84 	Training Loss: 1.294445 	Validation Loss: 0.319135
Epoch: 85 	Training Loss: 1.288677 	Validation Loss: 0.317673
Epoch: 86 	Training Loss: 1.292154 	Validation Loss: 0.318644
Epoch: 87 	Training Loss: 1.292221 	Validation Loss: 0.317595
Epoch: 88 	Training Loss: 1.295039 	Validation Loss: 0.319856
Epoch: 89 	Training Loss: 1.289999 	Validation Loss: 0.320703
Epoch: 90 	Training Loss: 1.290199 	Validation Loss: 0.317269
Epoch: 91 	Training Loss: 1.289213 	Validation Loss: 0.318887
Epoch: 92 	Training Loss: 1.284553 	Validation Loss: 0.320420
Epoch: 93 	Training Loss: 1.292121 	Validation Loss: 0.319414
Epoch: 94 	Training Loss: 1.281610 	Validation Loss: 0.314129
Validation loss decreased (0.315513 --&amp;gt; 0.314129).  Saving model ...
Epoch: 95 	Training Loss: 1.292147 	Validation Loss: 0.317541
Epoch: 96 	Training Loss: 1.288869 	Validation Loss: 0.316178
Epoch: 97 	Training Loss: 1.284419 	Validation Loss: 0.326122
Epoch: 98 	Training Loss: 1.292448 	Validation Loss: 0.314851
Epoch: 99 	Training Loss: 1.287391 	Validation Loss: 0.315212
Epoch: 100 	Training Loss: 1.285748 	Validation Loss: 0.320298
Elapsed: 1:26:31.644031
&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pickle_path = Path("model_2_outcomes.pkl")
with pickle_path.open("rb") as reader:
    outcome = pickle.load(reader)
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model_2 = CNN()
model_2.to(device)
start = datetime.now()
model_2.load_state_dict(torch.load(outcome["hyperparameters_file"],
				   map_location=device))
outcome_2 = train_and_pickle(model_2, epochs=200, model_number=2)
outcome = update_outcome(outcome, outcome_2)
print("Elapsed: {}".format(datetime.now() - start))
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Epoch: 101 	Training Loss: 1.293572 	Validation Loss: 0.323292
Validation loss decreased (inf --&amp;gt; 0.323292).  Saving model ...
Epoch: 102 	Training Loss: 1.286175 	Validation Loss: 0.316041
Validation loss decreased (0.323292 --&amp;gt; 0.316041).  Saving model ...
Epoch: 103 	Training Loss: 1.292286 	Validation Loss: 0.318805
Epoch: 104 	Training Loss: 1.287122 	Validation Loss: 0.318283
Epoch: 105 	Training Loss: 1.285004 	Validation Loss: 0.316454
Epoch: 106 	Training Loss: 1.288655 	Validation Loss: 0.328694
Epoch: 107 	Training Loss: 1.286483 	Validation Loss: 0.311118
Validation loss decreased (0.316041 --&amp;gt; 0.311118).  Saving model ...
Epoch: 108 	Training Loss: 1.286722 	Validation Loss: 0.322617
Epoch: 109 	Training Loss: 1.281688 	Validation Loss: 0.317284
Epoch: 110 	Training Loss: 1.286374 	Validation Loss: 0.316699
Epoch: 111 	Training Loss: 1.285399 	Validation Loss: 0.315800
Epoch: 112 	Training Loss: 1.283735 	Validation Loss: 0.321917
Epoch: 113 	Training Loss: 1.283596 	Validation Loss: 0.311436
Epoch: 114 	Training Loss: 1.285218 	Validation Loss: 0.314240
Epoch: 115 	Training Loss: 1.282439 	Validation Loss: 0.315108
Epoch: 116 	Training Loss: 1.282893 	Validation Loss: 0.317056
Epoch: 117 	Training Loss: 1.282942 	Validation Loss: 0.313947
Epoch: 118 	Training Loss: 1.287284 	Validation Loss: 0.316639
Epoch: 119 	Training Loss: 1.285622 	Validation Loss: 0.321113
Epoch: 120 	Training Loss: 1.284308 	Validation Loss: 0.319277
Epoch: 121 	Training Loss: 1.282111 	Validation Loss: 0.314455
Epoch: 122 	Training Loss: 1.283129 	Validation Loss: 0.313159
Epoch: 123 	Training Loss: 1.284335 	Validation Loss: 0.322168
Epoch: 124 	Training Loss: 1.278320 	Validation Loss: 0.318971
Epoch: 125 	Training Loss: 1.281218 	Validation Loss: 0.313987
Epoch: 126 	Training Loss: 1.279132 	Validation Loss: 0.328925
Epoch: 127 	Training Loss: 1.279555 	Validation Loss: 0.316594
Epoch: 128 	Training Loss: 1.273169 	Validation Loss: 0.315559
Epoch: 129 	Training Loss: 1.277613 	Validation Loss: 0.319802
Epoch: 130 	Training Loss: 1.280081 	Validation Loss: 0.322822
Epoch: 131 	Training Loss: 1.281299 	Validation Loss: 0.317239
Epoch: 132 	Training Loss: 1.280862 	Validation Loss: 0.317907
Epoch: 133 	Training Loss: 1.280196 	Validation Loss: 0.323627
Epoch: 134 	Training Loss: 1.278056 	Validation Loss: 0.315584
Epoch: 135 	Training Loss: 1.271644 	Validation Loss: 0.317295
Epoch: 136 	Training Loss: 1.276935 	Validation Loss: 0.325810
Epoch: 137 	Training Loss: 1.279832 	Validation Loss: 0.320269
Epoch: 138 	Training Loss: 1.276127 	Validation Loss: 0.320572
Epoch: 139 	Training Loss: 1.276283 	Validation Loss: 0.319130
Epoch: 140 	Training Loss: 1.274293 	Validation Loss: 0.324264
Epoch: 141 	Training Loss: 1.276226 	Validation Loss: 0.318521
Epoch: 142 	Training Loss: 1.273648 	Validation Loss: 0.317698
Epoch: 143 	Training Loss: 1.280384 	Validation Loss: 0.318762
Epoch: 144 	Training Loss: 1.271613 	Validation Loss: 0.321056
Epoch: 145 	Training Loss: 1.279159 	Validation Loss: 0.319677
Epoch: 146 	Training Loss: 1.277133 	Validation Loss: 0.313412
Epoch: 147 	Training Loss: 1.273115 	Validation Loss: 0.316693
Epoch: 148 	Training Loss: 1.276824 	Validation Loss: 0.324270
Epoch: 149 	Training Loss: 1.271500 	Validation Loss: 0.317610
Epoch: 150 	Training Loss: 1.274339 	Validation Loss: 0.319794
Epoch: 151 	Training Loss: 1.276326 	Validation Loss: 0.316618
Epoch: 152 	Training Loss: 1.274265 	Validation Loss: 0.317560
Epoch: 153 	Training Loss: 1.273693 	Validation Loss: 0.315664
Epoch: 154 	Training Loss: 1.271308 	Validation Loss: 0.314383
Epoch: 155 	Training Loss: 1.275785 	Validation Loss: 0.311731
Epoch: 156 	Training Loss: 1.269926 	Validation Loss: 0.317802
Epoch: 157 	Training Loss: 1.272163 	Validation Loss: 0.326034
Epoch: 158 	Training Loss: 1.272792 	Validation Loss: 0.323937
Epoch: 159 	Training Loss: 1.270623 	Validation Loss: 0.314596
Epoch: 160 	Training Loss: 1.274752 	Validation Loss: 0.318708
Epoch: 161 	Training Loss: 1.269636 	Validation Loss: 0.315447
Epoch: 162 	Training Loss: 1.268630 	Validation Loss: 0.318611
Epoch: 163 	Training Loss: 1.269201 	Validation Loss: 0.321739
Epoch: 164 	Training Loss: 1.268440 	Validation Loss: 0.318679
Epoch: 165 	Training Loss: 1.267896 	Validation Loss: 0.317043
Epoch: 166 	Training Loss: 1.268580 	Validation Loss: 0.319146
Epoch: 167 	Training Loss: 1.275538 	Validation Loss: 0.317928
Epoch: 168 	Training Loss: 1.268560 	Validation Loss: 0.323980
Epoch: 169 	Training Loss: 1.268632 	Validation Loss: 0.313479
Epoch: 170 	Training Loss: 1.264794 	Validation Loss: 0.318113
Epoch: 171 	Training Loss: 1.270822 	Validation Loss: 0.313195
Epoch: 172 	Training Loss: 1.267813 	Validation Loss: 0.317769
Epoch: 173 	Training Loss: 1.270347 	Validation Loss: 0.315005
Epoch: 174 	Training Loss: 1.266662 	Validation Loss: 0.314660
Epoch: 175 	Training Loss: 1.268849 	Validation Loss: 0.319801
Epoch: 176 	Training Loss: 1.271820 	Validation Loss: 0.320086
Epoch: 177 	Training Loss: 1.273374 	Validation Loss: 0.318641
Epoch: 178 	Training Loss: 1.265961 	Validation Loss: 0.314708
Epoch: 179 	Training Loss: 1.271811 	Validation Loss: 0.322507
Epoch: 180 	Training Loss: 1.263662 	Validation Loss: 0.323136
Epoch: 181 	Training Loss: 1.269750 	Validation Loss: 0.314223
Epoch: 182 	Training Loss: 1.269853 	Validation Loss: 0.321011
Epoch: 183 	Training Loss: 1.267138 	Validation Loss: 0.313789
Epoch: 184 	Training Loss: 1.271545 	Validation Loss: 0.321742
Epoch: 185 	Training Loss: 1.268025 	Validation Loss: 0.316022
Epoch: 186 	Training Loss: 1.272954 	Validation Loss: 0.324468
Epoch: 187 	Training Loss: 1.267895 	Validation Loss: 0.314698
Epoch: 188 	Training Loss: 1.266716 	Validation Loss: 0.318999
Epoch: 189 	Training Loss: 1.263130 	Validation Loss: 0.319963
Epoch: 190 	Training Loss: 1.270730 	Validation Loss: 0.319453
Epoch: 191 	Training Loss: 1.265955 	Validation Loss: 0.314691
Epoch: 192 	Training Loss: 1.267399 	Validation Loss: 0.321611
Epoch: 193 	Training Loss: 1.264792 	Validation Loss: 0.320243
Epoch: 194 	Training Loss: 1.262446 	Validation Loss: 0.314628
Epoch: 195 	Training Loss: 1.262605 	Validation Loss: 0.312932
Epoch: 196 	Training Loss: 1.265456 	Validation Loss: 0.313259
Epoch: 197 	Training Loss: 1.269357 	Validation Loss: 0.311136
Epoch: 198 	Training Loss: 1.262179 	Validation Loss: 0.312693
Epoch: 199 	Training Loss: 1.266902 	Validation Loss: 0.313880
Epoch: 200 	Training Loss: 1.265160 	Validation Loss: 0.312400
Epoch: 201 	Training Loss: 1.266844 	Validation Loss: 0.316210
Epoch: 202 	Training Loss: 1.264941 	Validation Loss: 0.317070
Epoch: 203 	Training Loss: 1.267308 	Validation Loss: 0.321297
Epoch: 204 	Training Loss: 1.265302 	Validation Loss: 0.318993
Epoch: 205 	Training Loss: 1.265829 	Validation Loss: 0.313469
Epoch: 206 	Training Loss: 1.261570 	Validation Loss: 0.321749
Epoch: 207 	Training Loss: 1.266412 	Validation Loss: 0.310708
Validation loss decreased (0.311118 --&amp;gt; 0.310708).  Saving model ...
Epoch: 208 	Training Loss: 1.266944 	Validation Loss: 0.318451
Epoch: 209 	Training Loss: 1.265850 	Validation Loss: 0.315396
Epoch: 210 	Training Loss: 1.264065 	Validation Loss: 0.315393
Epoch: 211 	Training Loss: 1.258434 	Validation Loss: 0.315945
Epoch: 212 	Training Loss: 1.262104 	Validation Loss: 0.317880
Epoch: 213 	Training Loss: 1.266053 	Validation Loss: 0.326606
Epoch: 214 	Training Loss: 1.264815 	Validation Loss: 0.317249
Epoch: 215 	Training Loss: 1.265139 	Validation Loss: 0.319844
Epoch: 216 	Training Loss: 1.266425 	Validation Loss: 0.320103
Epoch: 217 	Training Loss: 1.265218 	Validation Loss: 0.313683
Epoch: 218 	Training Loss: 1.261013 	Validation Loss: 0.316373
Epoch: 219 	Training Loss: 1.262247 	Validation Loss: 0.313101
Epoch: 220 	Training Loss: 1.264393 	Validation Loss: 0.314501
Epoch: 221 	Training Loss: 1.264149 	Validation Loss: 0.315623
Epoch: 222 	Training Loss: 1.259319 	Validation Loss: 0.318756
Epoch: 223 	Training Loss: 1.258570 	Validation Loss: 0.319732
Epoch: 224 	Training Loss: 1.259029 	Validation Loss: 0.311516
Epoch: 225 	Training Loss: 1.266348 	Validation Loss: 0.314770
Epoch: 226 	Training Loss: 1.259851 	Validation Loss: 0.321516
Epoch: 227 	Training Loss: 1.262397 	Validation Loss: 0.314634
Epoch: 228 	Training Loss: 1.258319 	Validation Loss: 0.314885
Epoch: 229 	Training Loss: 1.257705 	Validation Loss: 0.313776
Epoch: 230 	Training Loss: 1.265772 	Validation Loss: 0.317983
Epoch: 231 	Training Loss: 1.256625 	Validation Loss: 0.315058
Epoch: 232 	Training Loss: 1.259640 	Validation Loss: 0.315233
Epoch: 233 	Training Loss: 1.257951 	Validation Loss: 0.312612
Epoch: 234 	Training Loss: 1.259246 	Validation Loss: 0.318067
Epoch: 235 	Training Loss: 1.254118 	Validation Loss: 0.319640
Epoch: 236 	Training Loss: 1.261764 	Validation Loss: 0.323842
Epoch: 237 	Training Loss: 1.257337 	Validation Loss: 0.312940
Epoch: 238 	Training Loss: 1.261468 	Validation Loss: 0.312802
Epoch: 239 	Training Loss: 1.256006 	Validation Loss: 0.317805
Epoch: 240 	Training Loss: 1.259415 	Validation Loss: 0.313486
Epoch: 241 	Training Loss: 1.256178 	Validation Loss: 0.314875
Epoch: 242 	Training Loss: 1.256519 	Validation Loss: 0.313054
Epoch: 243 	Training Loss: 1.255753 	Validation Loss: 0.310222
Validation loss decreased (0.310708 --&amp;gt; 0.310222).  Saving model ...
Epoch: 244 	Training Loss: 1.258942 	Validation Loss: 0.329567
Epoch: 245 	Training Loss: 1.258942 	Validation Loss: 0.311769
Epoch: 246 	Training Loss: 1.262446 	Validation Loss: 0.313582
Epoch: 247 	Training Loss: 1.261230 	Validation Loss: 0.318076
Epoch: 248 	Training Loss: 1.261161 	Validation Loss: 0.314736
Epoch: 249 	Training Loss: 1.259770 	Validation Loss: 0.313956
Epoch: 250 	Training Loss: 1.256420 	Validation Loss: 0.312800
Epoch: 251 	Training Loss: 1.262006 	Validation Loss: 0.316093
Epoch: 252 	Training Loss: 1.259628 	Validation Loss: 0.314459
Epoch: 253 	Training Loss: 1.255323 	Validation Loss: 0.320948
Epoch: 254 	Training Loss: 1.251152 	Validation Loss: 0.312966
Epoch: 255 	Training Loss: 1.263651 	Validation Loss: 0.324031
Epoch: 256 	Training Loss: 1.258022 	Validation Loss: 0.317772
Epoch: 257 	Training Loss: 1.260936 	Validation Loss: 0.316249
Epoch: 258 	Training Loss: 1.257661 	Validation Loss: 0.318002
Epoch: 259 	Training Loss: 1.253739 	Validation Loss: 0.317531
Epoch: 260 	Training Loss: 1.259165 	Validation Loss: 0.318186
Epoch: 261 	Training Loss: 1.255523 	Validation Loss: 0.315747
Epoch: 262 	Training Loss: 1.260258 	Validation Loss: 0.323450
Epoch: 263 	Training Loss: 1.256247 	Validation Loss: 0.315790
Epoch: 264 	Training Loss: 1.256523 	Validation Loss: 0.322588
Epoch: 265 	Training Loss: 1.256251 	Validation Loss: 0.316159
Epoch: 266 	Training Loss: 1.254540 	Validation Loss: 0.317133
Epoch: 267 	Training Loss: 1.256788 	Validation Loss: 0.320573
Epoch: 268 	Training Loss: 1.261198 	Validation Loss: 0.326142
Epoch: 269 	Training Loss: 1.255286 	Validation Loss: 0.311760
Epoch: 270 	Training Loss: 1.256038 	Validation Loss: 0.320824
Epoch: 271 	Training Loss: 1.252561 	Validation Loss: 0.313171
Epoch: 272 	Training Loss: 1.257770 	Validation Loss: 0.318307
Epoch: 273 	Training Loss: 1.254161 	Validation Loss: 0.309804
Validation loss decreased (0.310222 --&amp;gt; 0.309804).  Saving model ...
Epoch: 274 	Training Loss: 1.256829 	Validation Loss: 0.318989
Epoch: 275 	Training Loss: 1.264886 	Validation Loss: 0.317026
Epoch: 276 	Training Loss: 1.250972 	Validation Loss: 0.315094
Epoch: 277 	Training Loss: 1.255500 	Validation Loss: 0.324168
Epoch: 278 	Training Loss: 1.253158 	Validation Loss: 0.321396
Epoch: 279 	Training Loss: 1.258170 	Validation Loss: 0.320225
Epoch: 280 	Training Loss: 1.258867 	Validation Loss: 0.318569
Epoch: 281 	Training Loss: 1.254345 	Validation Loss: 0.316465
Epoch: 282 	Training Loss: 1.255778 	Validation Loss: 0.314160
Epoch: 283 	Training Loss: 1.254325 	Validation Loss: 0.313069
Epoch: 284 	Training Loss: 1.253357 	Validation Loss: 0.328138
Epoch: 285 	Training Loss: 1.251017 	Validation Loss: 0.316133
Epoch: 286 	Training Loss: 1.252227 	Validation Loss: 0.316984
Epoch: 287 	Training Loss: 1.253182 	Validation Loss: 0.313943
Epoch: 288 	Training Loss: 1.250671 	Validation Loss: 0.318114
Epoch: 289 	Training Loss: 1.255845 	Validation Loss: 0.316618
Epoch: 290 	Training Loss: 1.255237 	Validation Loss: 0.312792
Epoch: 291 	Training Loss: 1.262059 	Validation Loss: 0.314828
Epoch: 292 	Training Loss: 1.255877 	Validation Loss: 0.318905
Epoch: 293 	Training Loss: 1.254416 	Validation Loss: 0.314216
Epoch: 294 	Training Loss: 1.253497 	Validation Loss: 0.314790
Epoch: 295 	Training Loss: 1.255368 	Validation Loss: 0.321991
Epoch: 296 	Training Loss: 1.257793 	Validation Loss: 0.317706
Epoch: 297 	Training Loss: 1.251250 	Validation Loss: 0.316808
Epoch: 298 	Training Loss: 1.252172 	Validation Loss: 0.315334
Epoch: 299 	Training Loss: 1.251001 	Validation Loss: 0.314154
Epoch: 300 	Training Loss: 1.252786 	Validation Loss: 0.320209
Epoch: 301 	Training Loss: 1.257268 	Validation Loss: 0.319915
Elapsed: 1:15:46.335776
&lt;/pre&gt;

&lt;p&gt;
It seems to be improving, but really slowly.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;test(model_2)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Test Loss: 1.307058

Test Accuracy of airplane: 57% (572/1000)
Test Accuracy of automobile: 73% (735/1000)
Test Accuracy of  bird: 26% (266/1000)
Test Accuracy of   cat: 35% (357/1000)
Test Accuracy of  deer: 52% (525/1000)
Test Accuracy of   dog: 19% (193/1000)
Test Accuracy of  frog: 79% (798/1000)
Test Accuracy of horse: 59% (598/1000)
Test Accuracy of  ship: 81% (810/1000)
Test Accuracy of truck: 49% (494/1000)

Test Accuracy (Overall): 53% (5348/10000)
&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model_2 = CNN()
model_2.to(device)
start = datetime.now()
model_2.load_state_dict(torch.load(outcome["hyperparameters_file"],
				   map_location=device))
outcome_2 = train_and_pickle(model_2, epochs=200, model_number=2)
outcome = update_outcome(outcome, outcome_2)
print("Elapsed: {}".format(datetime.now() - start))
model_2.load_state_dict(torch.load(outcome["hyperparameters_file"],
				   map_location=device))

test(model_2)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Epoch: 202 	Training Loss: 1.256388 	Validation Loss: 0.313784
Validation loss decreased (inf --&amp;gt; 0.313784).  Saving model ...
Epoch: 203 	Training Loss: 1.258825 	Validation Loss: 0.317360
Epoch: 204 	Training Loss: 1.256599 	Validation Loss: 0.316243
Epoch: 205 	Training Loss: 1.253339 	Validation Loss: 0.322061
Epoch: 206 	Training Loss: 1.260164 	Validation Loss: 0.319589
Epoch: 207 	Training Loss: 1.252303 	Validation Loss: 0.318219
Epoch: 208 	Training Loss: 1.257676 	Validation Loss: 0.326530
Epoch: 209 	Training Loss: 1.258256 	Validation Loss: 0.322288
Epoch: 210 	Training Loss: 1.257436 	Validation Loss: 0.316848
Epoch: 211 	Training Loss: 1.256364 	Validation Loss: 0.313047
Validation loss decreased (0.313784 --&amp;gt; 0.313047).  Saving model ...
Epoch: 212 	Training Loss: 1.259785 	Validation Loss: 0.321005
Epoch: 213 	Training Loss: 1.254453 	Validation Loss: 0.307325
Validation loss decreased (0.313047 --&amp;gt; 0.307325).  Saving model ...
Epoch: 214 	Training Loss: 1.254806 	Validation Loss: 0.320826
Epoch: 215 	Training Loss: 1.252779 	Validation Loss: 0.320929
Epoch: 216 	Training Loss: 1.252038 	Validation Loss: 0.320515
Epoch: 217 	Training Loss: 1.252444 	Validation Loss: 0.317522
Epoch: 218 	Training Loss: 1.254665 	Validation Loss: 0.313467
Epoch: 219 	Training Loss: 1.255900 	Validation Loss: 0.315710
Epoch: 220 	Training Loss: 1.252430 	Validation Loss: 0.321523
Epoch: 221 	Training Loss: 1.256561 	Validation Loss: 0.310884
Epoch: 222 	Training Loss: 1.255160 	Validation Loss: 0.309861
Epoch: 223 	Training Loss: 1.254754 	Validation Loss: 0.319757
Epoch: 224 	Training Loss: 1.255497 	Validation Loss: 0.318309
Epoch: 225 	Training Loss: 1.260697 	Validation Loss: 0.314599
Epoch: 226 	Training Loss: 1.253136 	Validation Loss: 0.318721
Epoch: 227 	Training Loss: 1.257839 	Validation Loss: 0.312620
Epoch: 228 	Training Loss: 1.248965 	Validation Loss: 0.320385
Epoch: 229 	Training Loss: 1.251453 	Validation Loss: 0.318191
Epoch: 230 	Training Loss: 1.252814 	Validation Loss: 0.324980
Epoch: 231 	Training Loss: 1.256732 	Validation Loss: 0.318312
Epoch: 232 	Training Loss: 1.251452 	Validation Loss: 0.319930
Epoch: 233 	Training Loss: 1.251726 	Validation Loss: 0.311095
Epoch: 234 	Training Loss: 1.250112 	Validation Loss: 0.318118
Epoch: 235 	Training Loss: 1.255064 	Validation Loss: 0.311329
Epoch: 236 	Training Loss: 1.250156 	Validation Loss: 0.322847
Epoch: 237 	Training Loss: 1.249897 	Validation Loss: 0.310835
Epoch: 238 	Training Loss: 1.251495 	Validation Loss: 0.322079
Epoch: 239 	Training Loss: 1.247715 	Validation Loss: 0.321563
Epoch: 240 	Training Loss: 1.248373 	Validation Loss: 0.328171
Epoch: 241 	Training Loss: 1.250492 	Validation Loss: 0.321683
Epoch: 242 	Training Loss: 1.255231 	Validation Loss: 0.313710
Epoch: 243 	Training Loss: 1.247742 	Validation Loss: 0.318332
Epoch: 244 	Training Loss: 1.251414 	Validation Loss: 0.315995
Epoch: 245 	Training Loss: 1.258454 	Validation Loss: 0.317433
Epoch: 246 	Training Loss: 1.253335 	Validation Loss: 0.317605
Epoch: 247 	Training Loss: 1.253148 	Validation Loss: 0.316049
Epoch: 248 	Training Loss: 1.251510 	Validation Loss: 0.312951
Epoch: 249 	Training Loss: 1.251977 	Validation Loss: 0.321403
Epoch: 250 	Training Loss: 1.256146 	Validation Loss: 0.320409
Epoch: 251 	Training Loss: 1.248189 	Validation Loss: 0.317272
Epoch: 252 	Training Loss: 1.254679 	Validation Loss: 0.317682
Epoch: 253 	Training Loss: 1.253137 	Validation Loss: 0.317845
Epoch: 254 	Training Loss: 1.258417 	Validation Loss: 0.317278
Epoch: 255 	Training Loss: 1.253359 	Validation Loss: 0.319818
Epoch: 256 	Training Loss: 1.247390 	Validation Loss: 0.320857
Epoch: 257 	Training Loss: 1.255359 	Validation Loss: 0.317702
Epoch: 258 	Training Loss: 1.247608 	Validation Loss: 0.316204
Epoch: 259 	Training Loss: 1.249561 	Validation Loss: 0.312899
Epoch: 260 	Training Loss: 1.248591 	Validation Loss: 0.322027
Epoch: 261 	Training Loss: 1.248232 	Validation Loss: 0.316189
Epoch: 262 	Training Loss: 1.252761 	Validation Loss: 0.317912
Epoch: 263 	Training Loss: 1.246621 	Validation Loss: 0.317565
Epoch: 264 	Training Loss: 1.249730 	Validation Loss: 0.321344
Epoch: 265 	Training Loss: 1.253313 	Validation Loss: 0.317789
Epoch: 266 	Training Loss: 1.250943 	Validation Loss: 0.319828
Epoch: 267 	Training Loss: 1.248345 	Validation Loss: 0.319927
Epoch: 268 	Training Loss: 1.248811 	Validation Loss: 0.316677
Epoch: 269 	Training Loss: 1.250617 	Validation Loss: 0.311661
Epoch: 270 	Training Loss: 1.250927 	Validation Loss: 0.324976
Epoch: 271 	Training Loss: 1.246129 	Validation Loss: 0.321428
Epoch: 272 	Training Loss: 1.247270 	Validation Loss: 0.313739
Epoch: 273 	Training Loss: 1.252439 	Validation Loss: 0.314271
Epoch: 274 	Training Loss: 1.249031 	Validation Loss: 0.315256
Epoch: 275 	Training Loss: 1.248926 	Validation Loss: 0.318519
Epoch: 276 	Training Loss: 1.253851 	Validation Loss: 0.317292
Epoch: 277 	Training Loss: 1.248241 	Validation Loss: 0.312578
Epoch: 278 	Training Loss: 1.246958 	Validation Loss: 0.317017
Epoch: 279 	Training Loss: 1.247038 	Validation Loss: 0.317870
Epoch: 280 	Training Loss: 1.247711 	Validation Loss: 0.320040
Epoch: 281 	Training Loss: 1.250939 	Validation Loss: 0.319092
Epoch: 282 	Training Loss: 1.250168 	Validation Loss: 0.318878
Epoch: 283 	Training Loss: 1.249140 	Validation Loss: 0.323233
Epoch: 284 	Training Loss: 1.247192 	Validation Loss: 0.320423
Epoch: 285 	Training Loss: 1.248637 	Validation Loss: 0.321254
Epoch: 286 	Training Loss: 1.246468 	Validation Loss: 0.322253
Epoch: 287 	Training Loss: 1.247990 	Validation Loss: 0.316660
Epoch: 288 	Training Loss: 1.245704 	Validation Loss: 0.327530
Epoch: 289 	Training Loss: 1.244317 	Validation Loss: 0.316667
Epoch: 290 	Training Loss: 1.247457 	Validation Loss: 0.316587
Epoch: 291 	Training Loss: 1.244423 	Validation Loss: 0.323431
Epoch: 292 	Training Loss: 1.245140 	Validation Loss: 0.319670
Epoch: 293 	Training Loss: 1.247903 	Validation Loss: 0.315965
Epoch: 294 	Training Loss: 1.248071 	Validation Loss: 0.314560
Epoch: 295 	Training Loss: 1.244779 	Validation Loss: 0.321430
Epoch: 296 	Training Loss: 1.250301 	Validation Loss: 0.314018
Epoch: 297 	Training Loss: 1.251302 	Validation Loss: 0.316015
Epoch: 298 	Training Loss: 1.253560 	Validation Loss: 0.315506
Epoch: 299 	Training Loss: 1.246812 	Validation Loss: 0.323061
Epoch: 300 	Training Loss: 1.248937 	Validation Loss: 0.315299
Epoch: 301 	Training Loss: 1.248918 	Validation Loss: 0.318701
Epoch: 302 	Training Loss: 1.247325 	Validation Loss: 0.315778
Epoch: 303 	Training Loss: 1.241974 	Validation Loss: 0.315274
Epoch: 304 	Training Loss: 1.250347 	Validation Loss: 0.315380
Epoch: 305 	Training Loss: 1.244912 	Validation Loss: 0.316511
Epoch: 306 	Training Loss: 1.247815 	Validation Loss: 0.317746
Epoch: 307 	Training Loss: 1.250566 	Validation Loss: 0.314758
Epoch: 308 	Training Loss: 1.249454 	Validation Loss: 0.317377
Epoch: 309 	Training Loss: 1.249325 	Validation Loss: 0.316275
Epoch: 310 	Training Loss: 1.248658 	Validation Loss: 0.319433
Epoch: 311 	Training Loss: 1.244979 	Validation Loss: 0.312409
Epoch: 312 	Training Loss: 1.250389 	Validation Loss: 0.319627
Epoch: 313 	Training Loss: 1.245450 	Validation Loss: 0.318461
Epoch: 314 	Training Loss: 1.247308 	Validation Loss: 0.318554
Epoch: 315 	Training Loss: 1.247195 	Validation Loss: 0.316582
Epoch: 316 	Training Loss: 1.244136 	Validation Loss: 0.318103
Epoch: 317 	Training Loss: 1.249054 	Validation Loss: 0.319848
Epoch: 318 	Training Loss: 1.248777 	Validation Loss: 0.323786
Epoch: 319 	Training Loss: 1.247198 	Validation Loss: 0.315047
Epoch: 320 	Training Loss: 1.251294 	Validation Loss: 0.318657
Epoch: 321 	Training Loss: 1.249177 	Validation Loss: 0.337516
Epoch: 322 	Training Loss: 1.247499 	Validation Loss: 0.326684
Epoch: 323 	Training Loss: 1.246539 	Validation Loss: 0.319658
Epoch: 324 	Training Loss: 1.248925 	Validation Loss: 0.313511
Epoch: 325 	Training Loss: 1.243196 	Validation Loss: 0.315549
Epoch: 326 	Training Loss: 1.244999 	Validation Loss: 0.321060
Epoch: 327 	Training Loss: 1.248777 	Validation Loss: 0.317293
Epoch: 328 	Training Loss: 1.248694 	Validation Loss: 0.317218
Epoch: 329 	Training Loss: 1.251560 	Validation Loss: 0.317921
Epoch: 330 	Training Loss: 1.252284 	Validation Loss: 0.317201
Epoch: 331 	Training Loss: 1.246083 	Validation Loss: 0.321029
Epoch: 332 	Training Loss: 1.244893 	Validation Loss: 0.316990
Epoch: 333 	Training Loss: 1.240543 	Validation Loss: 0.317590
Epoch: 334 	Training Loss: 1.246393 	Validation Loss: 0.325721
Epoch: 335 	Training Loss: 1.248191 	Validation Loss: 0.320632
Epoch: 336 	Training Loss: 1.241560 	Validation Loss: 0.324130
Epoch: 337 	Training Loss: 1.243119 	Validation Loss: 0.318852
Epoch: 338 	Training Loss: 1.242660 	Validation Loss: 0.319926
Epoch: 339 	Training Loss: 1.249028 	Validation Loss: 0.315266
Epoch: 340 	Training Loss: 1.244741 	Validation Loss: 0.324272
Epoch: 341 	Training Loss: 1.244523 	Validation Loss: 0.318710
Epoch: 342 	Training Loss: 1.241070 	Validation Loss: 0.319939
Epoch: 343 	Training Loss: 1.244101 	Validation Loss: 0.321822
Epoch: 344 	Training Loss: 1.239239 	Validation Loss: 0.315630
Epoch: 345 	Training Loss: 1.245509 	Validation Loss: 0.318808
Epoch: 346 	Training Loss: 1.245012 	Validation Loss: 0.320597
Epoch: 347 	Training Loss: 1.251397 	Validation Loss: 0.318575
Epoch: 348 	Training Loss: 1.240546 	Validation Loss: 0.313607
Epoch: 349 	Training Loss: 1.245582 	Validation Loss: 0.317309
Epoch: 350 	Training Loss: 1.240588 	Validation Loss: 0.319662
Epoch: 351 	Training Loss: 1.241194 	Validation Loss: 0.316204
Epoch: 352 	Training Loss: 1.243081 	Validation Loss: 0.321423
Epoch: 353 	Training Loss: 1.244287 	Validation Loss: 0.316278
Epoch: 354 	Training Loss: 1.248997 	Validation Loss: 0.322080
Epoch: 355 	Training Loss: 1.243133 	Validation Loss: 0.314357
Epoch: 356 	Training Loss: 1.240463 	Validation Loss: 0.317619
Epoch: 357 	Training Loss: 1.249085 	Validation Loss: 0.317623
Epoch: 358 	Training Loss: 1.244508 	Validation Loss: 0.316843
Epoch: 359 	Training Loss: 1.252762 	Validation Loss: 0.317262
Epoch: 360 	Training Loss: 1.246585 	Validation Loss: 0.321501
Epoch: 361 	Training Loss: 1.240622 	Validation Loss: 0.318065
Epoch: 362 	Training Loss: 1.246144 	Validation Loss: 0.317386
Epoch: 363 	Training Loss: 1.246127 	Validation Loss: 0.314560
Epoch: 364 	Training Loss: 1.244285 	Validation Loss: 0.318059
Epoch: 365 	Training Loss: 1.244826 	Validation Loss: 0.317295
Epoch: 366 	Training Loss: 1.244527 	Validation Loss: 0.313897
Epoch: 367 	Training Loss: 1.244683 	Validation Loss: 0.325274
Epoch: 368 	Training Loss: 1.245969 	Validation Loss: 0.325050
Epoch: 369 	Training Loss: 1.245889 	Validation Loss: 0.317678
Epoch: 370 	Training Loss: 1.240173 	Validation Loss: 0.321540
Epoch: 371 	Training Loss: 1.244970 	Validation Loss: 0.318374
Epoch: 372 	Training Loss: 1.242400 	Validation Loss: 0.322875
Epoch: 373 	Training Loss: 1.245613 	Validation Loss: 0.319608
Epoch: 374 	Training Loss: 1.243773 	Validation Loss: 0.322040
Epoch: 375 	Training Loss: 1.243070 	Validation Loss: 0.320554
Epoch: 376 	Training Loss: 1.245695 	Validation Loss: 0.321315
Epoch: 377 	Training Loss: 1.245310 	Validation Loss: 0.321394
Epoch: 378 	Training Loss: 1.240203 	Validation Loss: 0.316470
Epoch: 379 	Training Loss: 1.245251 	Validation Loss: 0.317234
Epoch: 380 	Training Loss: 1.250027 	Validation Loss: 0.330051
Epoch: 381 	Training Loss: 1.243686 	Validation Loss: 0.322005
Epoch: 382 	Training Loss: 1.243251 	Validation Loss: 0.315280
Epoch: 383 	Training Loss: 1.243953 	Validation Loss: 0.326072
Epoch: 384 	Training Loss: 1.245808 	Validation Loss: 0.316741
Epoch: 385 	Training Loss: 1.242827 	Validation Loss: 0.315943
Epoch: 386 	Training Loss: 1.244012 	Validation Loss: 0.310488
Epoch: 387 	Training Loss: 1.245015 	Validation Loss: 0.314874
Epoch: 388 	Training Loss: 1.244292 	Validation Loss: 0.317309
Epoch: 389 	Training Loss: 1.250823 	Validation Loss: 0.313929
Epoch: 390 	Training Loss: 1.248937 	Validation Loss: 0.314966
Epoch: 391 	Training Loss: 1.249134 	Validation Loss: 0.321290
Epoch: 392 	Training Loss: 1.246164 	Validation Loss: 0.316047
Epoch: 393 	Training Loss: 1.249995 	Validation Loss: 0.318678
Epoch: 394 	Training Loss: 1.240377 	Validation Loss: 0.327256
Epoch: 395 	Training Loss: 1.247659 	Validation Loss: 0.317254
Epoch: 396 	Training Loss: 1.238285 	Validation Loss: 0.314723
Epoch: 397 	Training Loss: 1.245013 	Validation Loss: 0.324809
Epoch: 398 	Training Loss: 1.247650 	Validation Loss: 0.330501
Epoch: 399 	Training Loss: 1.250368 	Validation Loss: 0.318667
Epoch: 400 	Training Loss: 1.246211 	Validation Loss: 0.323798
Epoch: 401 	Training Loss: 1.239634 	Validation Loss: 0.322877
Epoch: 402 	Training Loss: 1.248236 	Validation Loss: 0.321464
Elapsed: 1:17:57.592411
Test Loss: 1.336450

Test Accuracy of airplane: 55% (553/1000)
Test Accuracy of automobile: 58% (583/1000)
Test Accuracy of  bird: 23% (234/1000)
Test Accuracy of   cat: 30% (307/1000)
Test Accuracy of  deer: 36% (365/1000)
Test Accuracy of   dog: 25% (257/1000)
Test Accuracy of  frog: 88% (880/1000)
Test Accuracy of horse: 69% (694/1000)
Test Accuracy of  ship: 76% (766/1000)
Test Accuracy of truck: 61% (611/1000)

Test Accuracy (Overall): 52% (5250/10000)
&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model_2 = CNN()
model_2.to(device)
start = datetime.now()
model_2.load_state_dict(torch.load(outcome["hyperparameters_file"],
				   map_location=device))
outcome_2 = train_and_pickle(model_2, epochs=200, model_number=2)
outcome = update_outcome(outcome, outcome_2)
print("Elapsed: {}".format(datetime.now() - start))
model_2.load_state_dict(torch.load(outcome["hyperparameters_file"],
				   map_location=device))
test(model_2)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Epoch: 400 	Training Loss: 1.085763 	Validation Loss: 0.282825
Validation loss decreased (inf --&amp;gt; 0.282825).  Saving model ...
Epoch: 401 	Training Loss: 1.094224 	Validation Loss: 0.282336
Validation loss decreased (0.282825 --&amp;gt; 0.282336).  Saving model ...
Epoch: 402 	Training Loss: 1.090027 	Validation Loss: 0.283988
Epoch: 403 	Training Loss: 1.088251 	Validation Loss: 0.282374
Epoch: 404 	Training Loss: 1.088617 	Validation Loss: 0.280398
Validation loss decreased (0.282336 --&amp;gt; 0.280398).  Saving model ...
Epoch: 405 	Training Loss: 1.092081 	Validation Loss: 0.280428
Epoch: 406 	Training Loss: 1.091815 	Validation Loss: 0.278766
Validation loss decreased (0.280398 --&amp;gt; 0.278766).  Saving model ...
Epoch: 407 	Training Loss: 1.088024 	Validation Loss: 0.281447
Epoch: 408 	Training Loss: 1.094500 	Validation Loss: 0.283386
Epoch: 409 	Training Loss: 1.089597 	Validation Loss: 0.281148
Epoch: 410 	Training Loss: 1.091652 	Validation Loss: 0.283893
Epoch: 411 	Training Loss: 1.087357 	Validation Loss: 0.281366
Epoch: 412 	Training Loss: 1.091122 	Validation Loss: 0.286320
Epoch: 413 	Training Loss: 1.089693 	Validation Loss: 0.282684
Epoch: 414 	Training Loss: 1.088109 	Validation Loss: 0.284077
Epoch: 415 	Training Loss: 1.087701 	Validation Loss: 0.280002
Epoch: 416 	Training Loss: 1.085328 	Validation Loss: 0.282377
Epoch: 417 	Training Loss: 1.089087 	Validation Loss: 0.282623
Epoch: 418 	Training Loss: 1.086825 	Validation Loss: 0.278291
Validation loss decreased (0.278766 --&amp;gt; 0.278291).  Saving model ...
Epoch: 419 	Training Loss: 1.086601 	Validation Loss: 0.282585
Epoch: 420 	Training Loss: 1.082824 	Validation Loss: 0.282660
Epoch: 421 	Training Loss: 1.089363 	Validation Loss: 0.281838
Epoch: 422 	Training Loss: 1.087070 	Validation Loss: 0.279197
Epoch: 423 	Training Loss: 1.084032 	Validation Loss: 0.281605
Epoch: 424 	Training Loss: 1.087307 	Validation Loss: 0.281069
Epoch: 425 	Training Loss: 1.090275 	Validation Loss: 0.286235
Epoch: 426 	Training Loss: 1.084863 	Validation Loss: 0.286024
Epoch: 427 	Training Loss: 1.086919 	Validation Loss: 0.283765
Epoch: 428 	Training Loss: 1.087431 	Validation Loss: 0.287237
Epoch: 429 	Training Loss: 1.084115 	Validation Loss: 0.279592
Epoch: 430 	Training Loss: 1.093677 	Validation Loss: 0.283081
Epoch: 431 	Training Loss: 1.090348 	Validation Loss: 0.281837
Epoch: 432 	Training Loss: 1.088213 	Validation Loss: 0.277247
Validation loss decreased (0.278291 --&amp;gt; 0.277247).  Saving model ...
Epoch: 433 	Training Loss: 1.089605 	Validation Loss: 0.278821
Epoch: 434 	Training Loss: 1.085192 	Validation Loss: 0.276951
Validation loss decreased (0.277247 --&amp;gt; 0.276951).  Saving model ...
Epoch: 435 	Training Loss: 1.085776 	Validation Loss: 0.281023
Epoch: 436 	Training Loss: 1.086465 	Validation Loss: 0.283929
Epoch: 437 	Training Loss: 1.087985 	Validation Loss: 0.282887
Epoch: 438 	Training Loss: 1.086791 	Validation Loss: 0.278656
Epoch: 439 	Training Loss: 1.087146 	Validation Loss: 0.284559
Epoch: 440 	Training Loss: 1.086268 	Validation Loss: 0.284008
Epoch: 441 	Training Loss: 1.074737 	Validation Loss: 0.282008
Epoch: 442 	Training Loss: 1.090836 	Validation Loss: 0.280691
Epoch: 443 	Training Loss: 1.086444 	Validation Loss: 0.283169
Epoch: 444 	Training Loss: 1.083751 	Validation Loss: 0.277424
Epoch: 445 	Training Loss: 1.084478 	Validation Loss: 0.282735
Epoch: 446 	Training Loss: 1.087853 	Validation Loss: 0.279917
Epoch: 447 	Training Loss: 1.087905 	Validation Loss: 0.278547
Epoch: 448 	Training Loss: 1.083655 	Validation Loss: 0.284014
Epoch: 449 	Training Loss: 1.085713 	Validation Loss: 0.284066
Epoch: 450 	Training Loss: 1.082967 	Validation Loss: 0.283472
Epoch: 451 	Training Loss: 1.087737 	Validation Loss: 0.281544
Epoch: 452 	Training Loss: 1.084897 	Validation Loss: 0.283131
Epoch: 453 	Training Loss: 1.085416 	Validation Loss: 0.283956
Epoch: 454 	Training Loss: 1.079511 	Validation Loss: 0.284032
Epoch: 455 	Training Loss: 1.081187 	Validation Loss: 0.277546
Epoch: 456 	Training Loss: 1.081564 	Validation Loss: 0.283062
Epoch: 457 	Training Loss: 1.090161 	Validation Loss: 0.277227
Epoch: 458 	Training Loss: 1.082555 	Validation Loss: 0.281654
Epoch: 459 	Training Loss: 1.084783 	Validation Loss: 0.282357
Epoch: 460 	Training Loss: 1.086960 	Validation Loss: 0.283228
Epoch: 461 	Training Loss: 1.088104 	Validation Loss: 0.283043
Epoch: 462 	Training Loss: 1.079098 	Validation Loss: 0.280849
Epoch: 463 	Training Loss: 1.077743 	Validation Loss: 0.279460
Epoch: 464 	Training Loss: 1.080590 	Validation Loss: 0.281254
Epoch: 465 	Training Loss: 1.083514 	Validation Loss: 0.280558
Epoch: 466 	Training Loss: 1.089853 	Validation Loss: 0.277356
Epoch: 467 	Training Loss: 1.080071 	Validation Loss: 0.279764
Epoch: 468 	Training Loss: 1.083149 	Validation Loss: 0.280320
Epoch: 469 	Training Loss: 1.086154 	Validation Loss: 0.278509
Epoch: 470 	Training Loss: 1.075413 	Validation Loss: 0.277589
Epoch: 471 	Training Loss: 1.090838 	Validation Loss: 0.284972
Epoch: 472 	Training Loss: 1.083023 	Validation Loss: 0.280417
Epoch: 473 	Training Loss: 1.078518 	Validation Loss: 0.279890
Epoch: 474 	Training Loss: 1.081342 	Validation Loss: 0.282047
Epoch: 475 	Training Loss: 1.082641 	Validation Loss: 0.277632
Epoch: 476 	Training Loss: 1.077731 	Validation Loss: 0.282896
Epoch: 477 	Training Loss: 1.074824 	Validation Loss: 0.278524
Epoch: 478 	Training Loss: 1.081040 	Validation Loss: 0.282670
Epoch: 479 	Training Loss: 1.078880 	Validation Loss: 0.281313
Epoch: 480 	Training Loss: 1.077215 	Validation Loss: 0.280679
Epoch: 481 	Training Loss: 1.081206 	Validation Loss: 0.278332
Epoch: 482 	Training Loss: 1.084885 	Validation Loss: 0.278158
Epoch: 483 	Training Loss: 1.075072 	Validation Loss: 0.277820
Epoch: 484 	Training Loss: 1.081011 	Validation Loss: 0.284402
Epoch: 485 	Training Loss: 1.081351 	Validation Loss: 0.281961
Epoch: 486 	Training Loss: 1.083745 	Validation Loss: 0.279679
Epoch: 487 	Training Loss: 1.081245 	Validation Loss: 0.280318
Epoch: 488 	Training Loss: 1.075557 	Validation Loss: 0.278577
Epoch: 489 	Training Loss: 1.079408 	Validation Loss: 0.278910
Epoch: 490 	Training Loss: 1.082496 	Validation Loss: 0.280904
Epoch: 491 	Training Loss: 1.078611 	Validation Loss: 0.277847
Epoch: 492 	Training Loss: 1.087269 	Validation Loss: 0.280784
Epoch: 493 	Training Loss: 1.080308 	Validation Loss: 0.280509
Epoch: 494 	Training Loss: 1.079977 	Validation Loss: 0.280467
Epoch: 495 	Training Loss: 1.071035 	Validation Loss: 0.277071
Epoch: 496 	Training Loss: 1.081492 	Validation Loss: 0.279537
Epoch: 497 	Training Loss: 1.076939 	Validation Loss: 0.277763
Epoch: 498 	Training Loss: 1.076834 	Validation Loss: 0.277170
Epoch: 499 	Training Loss: 1.077066 	Validation Loss: 0.281241
Epoch: 500 	Training Loss: 1.078915 	Validation Loss: 0.278007
Elapsed: 1:41:06.408824
&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;test(model_2)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Test Loss: 1.336450

Test Accuracy of airplane: 55% (553/1000)
Test Accuracy of automobile: 58% (583/1000)
Test Accuracy of  bird: 23% (234/1000)
Test Accuracy of   cat: 30% (307/1000)
Test Accuracy of  deer: 36% (365/1000)
Test Accuracy of   dog: 25% (257/1000)
Test Accuracy of  frog: 88% (880/1000)
Test Accuracy of horse: 69% (694/1000)
Test Accuracy of  ship: 76% (766/1000)
Test Accuracy of truck: 61% (611/1000)

Test Accuracy (Overall): 52% (5250/10000)
&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;figure, axe = pyplot.subplots()
figure.suptitle("Filter Size 5 Training/Validation Loss", weight="bold")
x = numpy.arange(len(training_loss_2))
axe.plot(x, training_loss_2, label="Training")
axe.plot(x, validation_loss_2, label="Validation")
axe.set_xlabel("Epoch")
axe.set_ylabel("Cross-Entropy Loss")
labeled = False
for improvement in improvements_2:
    label = "_" if labeled else "Model Improved"
    axe.axvline(improvement, color='r', linestyle='--', label=label)
    labeled = True
legend = axe.legend()
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/model_2_training.png" alt="model_2_training.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
It looks like the model from the Pytorch tutorial starts to overfit after the 15th epoch (by count, not index).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0e77efe" class="outline-3"&gt;
&lt;h3 id="org0e77efe"&gt;Udacity Model&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0e77efe"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model_1 = CNN(3)
model_1.to(device)
filename_1, training_loss_1, validation_loss_1, improvements_1  = train(model_1, epochs=30, model_number=1)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Epoch: 1 	Training Loss: 1.764122 	Validation Loss: 0.408952
Validation loss decreased (inf --&amp;gt; 0.408952).  Saving model ...
Epoch: 2 	Training Loss: 1.586364 	Validation Loss: 0.383241
Validation loss decreased (0.408952 --&amp;gt; 0.383241).  Saving model ...
Epoch: 3 	Training Loss: 1.519929 	Validation Loss: 0.371740
Validation loss decreased (0.383241 --&amp;gt; 0.371740).  Saving model ...
Epoch: 4 	Training Loss: 1.488349 	Validation Loss: 0.362653
Validation loss decreased (0.371740 --&amp;gt; 0.362653).  Saving model ...
Epoch: 5 	Training Loss: 1.455125 	Validation Loss: 0.358624
Validation loss decreased (0.362653 --&amp;gt; 0.358624).  Saving model ...
Epoch: 6 	Training Loss: 1.431836 	Validation Loss: 0.353852
Validation loss decreased (0.358624 --&amp;gt; 0.353852).  Saving model ...
Epoch: 7 	Training Loss: 1.406383 	Validation Loss: 0.351643
Validation loss decreased (0.353852 --&amp;gt; 0.351643).  Saving model ...
Epoch: 8 	Training Loss: 1.396167 	Validation Loss: 0.342488
Validation loss decreased (0.351643 --&amp;gt; 0.342488).  Saving model ...
Epoch: 9 	Training Loss: 1.374800 	Validation Loss: 0.344513
Epoch: 10 	Training Loss: 1.365321 	Validation Loss: 0.339705
Validation loss decreased (0.342488 --&amp;gt; 0.339705).  Saving model ...
Epoch: 11 	Training Loss: 1.350646 	Validation Loss: 0.334100
Validation loss decreased (0.339705 --&amp;gt; 0.334100).  Saving model ...
Epoch: 12 	Training Loss: 1.336463 	Validation Loss: 0.342720
Epoch: 13 	Training Loss: 1.327740 	Validation Loss: 0.329569
Validation loss decreased (0.334100 --&amp;gt; 0.329569).  Saving model ...
Epoch: 14 	Training Loss: 1.318054 	Validation Loss: 0.330011
Epoch: 15 	Training Loss: 1.318000 	Validation Loss: 0.331113
Epoch: 16 	Training Loss: 1.307698 	Validation Loss: 0.325177
Validation loss decreased (0.329569 --&amp;gt; 0.325177).  Saving model ...
Epoch: 17 	Training Loss: 1.300564 	Validation Loss: 0.324221
Validation loss decreased (0.325177 --&amp;gt; 0.324221).  Saving model ...
Epoch: 18 	Training Loss: 1.298909 	Validation Loss: 0.323380
Validation loss decreased (0.324221 --&amp;gt; 0.323380).  Saving model ...
Epoch: 19 	Training Loss: 1.284629 	Validation Loss: 0.317989
Validation loss decreased (0.323380 --&amp;gt; 0.317989).  Saving model ...
Epoch: 20 	Training Loss: 1.284566 	Validation Loss: 0.316856
Validation loss decreased (0.317989 --&amp;gt; 0.316856).  Saving model ...
Epoch: 21 	Training Loss: 1.276280 	Validation Loss: 0.320113
Epoch: 22 	Training Loss: 1.274713 	Validation Loss: 0.320777
Epoch: 23 	Training Loss: 1.267952 	Validation Loss: 0.317876
Epoch: 24 	Training Loss: 1.270328 	Validation Loss: 0.311076
Validation loss decreased (0.316856 --&amp;gt; 0.311076).  Saving model ...
Epoch: 25 	Training Loss: 1.258179 	Validation Loss: 0.313508
Epoch: 26 	Training Loss: 1.253091 	Validation Loss: 0.314421
Epoch: 27 	Training Loss: 1.254100 	Validation Loss: 0.312774
Epoch: 28 	Training Loss: 1.244802 	Validation Loss: 0.311225
Epoch: 29 	Training Loss: 1.242637 	Validation Loss: 0.310512
Validation loss decreased (0.311076 --&amp;gt; 0.310512).  Saving model ...
Epoch: 30 	Training Loss: 1.245316 	Validation Loss: 0.311031
&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;figure, axe = pyplot.subplots()
figure.suptitle("Filter Size 3 Training/Validation Loss", weight="bold")
x = numpy.arange(len(training_loss_1))
axe.plot(x, training_loss_1, label="Training")
axe.plot(x, validation_loss_1, label="Validation")
axe.set_xlabel("Epoch")
axe.set_ylabel("Cross-Entropy Loss")
labeled = False
for improvement in improvements_1:
    label = "_" if labeled else "Model Improved"
    axe.axvline(improvement, color='r', linestyle='--', label=label)
    labeled = True
legend = axe.legend()
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/model_1_training.png" alt="model_1_training.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
So it looks like there isn't much difference between the models, but the filter size of 3 did slightly better.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6e38a61" class="outline-2"&gt;
&lt;h2 id="org6e38a61"&gt;Load the Model with the Lowest Validation Loss&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org6e38a61"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model_2.load_state_dict(torch.load(outcome["hyperparameters_file"]))
best_model = model_2
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb910f79" class="outline-2"&gt;
&lt;h2 id="orgb910f79"&gt;Test the Trained Network&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb910f79"&gt;
&lt;p&gt;
Test your trained model on previously unseen data! A "good" result will be a CNN that gets around 70% (or more, try your best!) accuracy on these test images.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def test(best_model):
    criterion = nn.CrossEntropyLoss()
    # track test loss
    test_loss = 0.0
    class_correct = list(0. for i in range(10))
    class_total = list(0. for i in range(10))

    best_model.to(device)
    best_model.eval()
    # iterate over test data
    for data, target in test_loader:
	# move tensors to GPU if CUDA is available
	data, target = data.to(device), target.to(device)
	# forward pass: compute predicted outputs by passing inputs to the model
	output = best_model(data)
	# calculate the batch loss
	loss = criterion(output, target)
	# update test loss 
	test_loss += loss.item() * data.size(0)
	# convert output probabilities to predicted class
	_, pred = torch.max(output, 1)    
	# compare predictions to true label
	correct_tensor = pred.eq(target.data.view_as(pred))
	correct = (
	    numpy.squeeze(correct_tensor.numpy())
	    if not train_on_gpu
	    else numpy.squeeze(correct_tensor.cpu().numpy()))
	# calculate test accuracy for each object class
	for i in range(BATCH_SIZE):
	    label = target.data[i]
	    class_correct[label] += correct[i].item()
	    class_total[label] += 1

    # average test loss
    test_loss = test_loss/len(test_loader.dataset)
    print('Test Loss: {:.6f}\n'.format(test_loss))

    for i in range(10):
	if class_total[i] &amp;gt; 0:
	    print('Test Accuracy of %5s: %2d%% (%2d/%2d)' % (
		classes[i], 100 * class_correct[i] / class_total[i],
		numpy.sum(class_correct[i]), numpy.sum(class_total[i])))
	else:
	    print('Test Accuracy of %5s: N/A (no training examples)' % (classes[i]))

    print('\nTest Accuracy (Overall): %2d%% (%2d/%2d)' % (
	100. * numpy.sum(class_correct) / numpy.sum(class_total),
	numpy.sum(class_correct), numpy.sum(class_total)))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
dataiter = iter(test_loader)
images, labels = dataiter.next()
images.numpy()
&lt;/p&gt;

&lt;p&gt;
if train_on_gpu:
    images = images.cuda()
&lt;/p&gt;

&lt;p&gt;
output = model(images)
&lt;/p&gt;

&lt;p&gt;
_, preds_tensor = torch.max(output, 1)
preds = np.squeeze(preds_tensor.numpy()) if not train_on_gpu else np.squeeze(preds_tensor.cpu().numpy())
&lt;/p&gt;

&lt;p&gt;
fig = plt.figure(figsize=(25, 4))
for idx in np.arange(20):
    ax = fig.add_subplot(2, 20/2, idx+1, xticks=[], yticks=[])
    imshow(images[idx])
    ax.set_title("{} ({})".format(classes[preds[idx]], classes[labels[idx]]),
                 color=("green" if preds[idx]==labels[idx].item() else "red"))
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb32b8e5" class="outline-2"&gt;
&lt;h2 id="orgb32b8e5"&gt;Make it Easier&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgb32b8e5"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;means = deviations = (0.5, 0.5, 0.5)
train_transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize(means, deviations)
    ])
test_transforms = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize(means,
			 deviations)])
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;training_data = datasets.CIFAR10(path.folder, train=True,
			      download=True, transform=train_transform)
test_data = datasets.CIFAR10(path.folder, train=False,
			     download=True, transform=test_transforms)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Files already downloaded and verified
Files already downloaded and verified

&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;indices = list(range(len(training_data)))
training_indices, validation_indices = train_test_split(
    indices,
    test_size=VALIDATION_FRACTION)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;train_sampler = SubsetRandomSampler(training_indices)
valid_sampler = SubsetRandomSampler(validation_indices)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;train_loader = torch.utils.data.DataLoader(training_data, batch_size=BATCH_SIZE,
    sampler=train_sampler, num_workers=NUM_WORKERS)
valid_loader = torch.utils.data.DataLoader(training_data, batch_size=BATCH_SIZE, 
    sampler=valid_sampler, num_workers=NUM_WORKERS)
test_loader = torch.utils.data.DataLoader(test_data, batch_size=BATCH_SIZE, 
    num_workers=NUM_WORKERS)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def load_and_train(model_number:int=3, epochs:int=100) -&amp;gt; dict:
    """Load the model using hyperparameters in the dict

    Args:
     model_number: identifier for the model (and its pickles)
     epochs: how many times to repeat training

    Returns:
     outcome: trained model and outcome dict
    """
    model = CNN()
    model = model.to(device)
    start = datetime.now()
    outcome = train_and_pickle(
	model,
	epochs=epochs,
	model_number=model_number)
    model.load_state_dict(torch.load(outcome["hyperparameters_file"],
				     map_location=device))
    test(model)
    ended = datetime.now()
    print("Ended: {}".format(ended))
    print("Elapsed: {}".format(ended - start))
    return outcome
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model_3 = CNN()
model_3.to(device)
start = datetime.now()
outcome = train_and_pickle(
    model_3,
    epochs=100,
    model_number=3)
print("Elapsed: {}".format(datetime.now() - start))
model_3.load_state_dict(torch.load(outcome["hyperparameters_file"],
				   map_location=device))
test(model_3)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Epoch: 404 	Training Loss: 1.766535 	Validation Loss: 0.404297
Validation loss decreased (inf --&amp;gt; 0.404297).  Saving model ...
Epoch: 405 	Training Loss: 1.539740 	Validation Loss: 0.351437
Validation loss decreased (0.404297 --&amp;gt; 0.351437).  Saving model ...
Epoch: 406 	Training Loss: 1.408876 	Validation Loss: 0.327341
Validation loss decreased (0.351437 --&amp;gt; 0.327341).  Saving model ...
Epoch: 407 	Training Loss: 1.325226 	Validation Loss: 0.303032
Validation loss decreased (0.327341 --&amp;gt; 0.303032).  Saving model ...
Epoch: 408 	Training Loss: 1.260864 	Validation Loss: 0.291623
Validation loss decreased (0.303032 --&amp;gt; 0.291623).  Saving model ...
Epoch: 409 	Training Loss: 1.214102 	Validation Loss: 0.283056
Validation loss decreased (0.291623 --&amp;gt; 0.283056).  Saving model ...
Epoch: 410 	Training Loss: 1.178166 	Validation Loss: 0.275751
Validation loss decreased (0.283056 --&amp;gt; 0.275751).  Saving model ...
Epoch: 411 	Training Loss: 1.146879 	Validation Loss: 0.264309
Validation loss decreased (0.275751 --&amp;gt; 0.264309).  Saving model ...
Epoch: 412 	Training Loss: 1.121644 	Validation Loss: 0.258764
Validation loss decreased (0.264309 --&amp;gt; 0.258764).  Saving model ...
Epoch: 413 	Training Loss: 1.097969 	Validation Loss: 0.252846
Validation loss decreased (0.258764 --&amp;gt; 0.252846).  Saving model ...
Epoch: 414 	Training Loss: 1.078815 	Validation Loss: 0.250729
Validation loss decreased (0.252846 --&amp;gt; 0.250729).  Saving model ...
Epoch: 415 	Training Loss: 1.055899 	Validation Loss: 0.241823
Validation loss decreased (0.250729 --&amp;gt; 0.241823).  Saving model ...
Epoch: 416 	Training Loss: 1.041387 	Validation Loss: 0.238933
Validation loss decreased (0.241823 --&amp;gt; 0.238933).  Saving model ...
Epoch: 417 	Training Loss: 1.029270 	Validation Loss: 0.234940
Validation loss decreased (0.238933 --&amp;gt; 0.234940).  Saving model ...
Epoch: 418 	Training Loss: 1.016113 	Validation Loss: 0.232727
Validation loss decreased (0.234940 --&amp;gt; 0.232727).  Saving model ...
Epoch: 419 	Training Loss: 1.005521 	Validation Loss: 0.226466
Validation loss decreased (0.232727 --&amp;gt; 0.226466).  Saving model ...
Epoch: 420 	Training Loss: 0.992684 	Validation Loss: 0.226542
Epoch: 421 	Training Loss: 0.978596 	Validation Loss: 0.225691
Validation loss decreased (0.226466 --&amp;gt; 0.225691).  Saving model ...
Epoch: 422 	Training Loss: 0.976063 	Validation Loss: 0.228258
Epoch: 423 	Training Loss: 0.961974 	Validation Loss: 0.221933
Validation loss decreased (0.225691 --&amp;gt; 0.221933).  Saving model ...
Epoch: 424 	Training Loss: 0.954803 	Validation Loss: 0.220159
Validation loss decreased (0.221933 --&amp;gt; 0.220159).  Saving model ...
Epoch: 425 	Training Loss: 0.948879 	Validation Loss: 0.219641
Validation loss decreased (0.220159 --&amp;gt; 0.219641).  Saving model ...
Epoch: 426 	Training Loss: 0.945494 	Validation Loss: 0.220472
Epoch: 427 	Training Loss: 0.935160 	Validation Loss: 0.215726
Validation loss decreased (0.219641 --&amp;gt; 0.215726).  Saving model ...
Epoch: 428 	Training Loss: 0.928077 	Validation Loss: 0.215445
Validation loss decreased (0.215726 --&amp;gt; 0.215445).  Saving model ...
Epoch: 429 	Training Loss: 0.925603 	Validation Loss: 0.212353
Validation loss decreased (0.215445 --&amp;gt; 0.212353).  Saving model ...
Epoch: 430 	Training Loss: 0.921984 	Validation Loss: 0.208420
Validation loss decreased (0.212353 --&amp;gt; 0.208420).  Saving model ...
Epoch: 431 	Training Loss: 0.912180 	Validation Loss: 0.218620
Epoch: 432 	Training Loss: 0.909916 	Validation Loss: 0.208612
Epoch: 433 	Training Loss: 0.902665 	Validation Loss: 0.208177
Validation loss decreased (0.208420 --&amp;gt; 0.208177).  Saving model ...
Epoch: 434 	Training Loss: 0.899616 	Validation Loss: 0.210920
Epoch: 435 	Training Loss: 0.895718 	Validation Loss: 0.212328
Epoch: 436 	Training Loss: 0.883933 	Validation Loss: 0.204341
Validation loss decreased (0.208177 --&amp;gt; 0.204341).  Saving model ...
Epoch: 437 	Training Loss: 0.888972 	Validation Loss: 0.206792
Epoch: 438 	Training Loss: 0.878481 	Validation Loss: 0.204317
Validation loss decreased (0.204341 --&amp;gt; 0.204317).  Saving model ...
Epoch: 439 	Training Loss: 0.879559 	Validation Loss: 0.204447
Epoch: 440 	Training Loss: 0.871985 	Validation Loss: 0.203039
Validation loss decreased (0.204317 --&amp;gt; 0.203039).  Saving model ...
Epoch: 441 	Training Loss: 0.870123 	Validation Loss: 0.202717
Validation loss decreased (0.203039 --&amp;gt; 0.202717).  Saving model ...
Epoch: 442 	Training Loss: 0.870877 	Validation Loss: 0.201654
Validation loss decreased (0.202717 --&amp;gt; 0.201654).  Saving model ...
Epoch: 443 	Training Loss: 0.863020 	Validation Loss: 0.204858
Epoch: 444 	Training Loss: 0.861419 	Validation Loss: 0.202981
Epoch: 445 	Training Loss: 0.864864 	Validation Loss: 0.200853
Validation loss decreased (0.201654 --&amp;gt; 0.200853).  Saving model ...
Epoch: 446 	Training Loss: 0.859879 	Validation Loss: 0.202888
Epoch: 447 	Training Loss: 0.859062 	Validation Loss: 0.199505
Validation loss decreased (0.200853 --&amp;gt; 0.199505).  Saving model ...
Epoch: 448 	Training Loss: 0.853924 	Validation Loss: 0.196931
Validation loss decreased (0.199505 --&amp;gt; 0.196931).  Saving model ...
Epoch: 449 	Training Loss: 0.849512 	Validation Loss: 0.201266
Epoch: 450 	Training Loss: 0.845482 	Validation Loss: 0.196021
Validation loss decreased (0.196931 --&amp;gt; 0.196021).  Saving model ...
Epoch: 451 	Training Loss: 0.844360 	Validation Loss: 0.195308
Validation loss decreased (0.196021 --&amp;gt; 0.195308).  Saving model ...
Epoch: 452 	Training Loss: 0.844023 	Validation Loss: 0.197164
Epoch: 453 	Training Loss: 0.839186 	Validation Loss: 0.194882
Validation loss decreased (0.195308 --&amp;gt; 0.194882).  Saving model ...
Epoch: 454 	Training Loss: 0.838193 	Validation Loss: 0.198097
Epoch: 455 	Training Loss: 0.837155 	Validation Loss: 0.197095
Epoch: 456 	Training Loss: 0.831614 	Validation Loss: 0.195633
Epoch: 457 	Training Loss: 0.827912 	Validation Loss: 0.195327
Epoch: 458 	Training Loss: 0.830631 	Validation Loss: 0.192197
Validation loss decreased (0.194882 --&amp;gt; 0.192197).  Saving model ...
Epoch: 459 	Training Loss: 0.825767 	Validation Loss: 0.195351
Epoch: 460 	Training Loss: 0.824248 	Validation Loss: 0.192982
Epoch: 461 	Training Loss: 0.822047 	Validation Loss: 0.191864
Validation loss decreased (0.192197 --&amp;gt; 0.191864).  Saving model ...
Epoch: 462 	Training Loss: 0.824057 	Validation Loss: 0.191095
Validation loss decreased (0.191864 --&amp;gt; 0.191095).  Saving model ...
Epoch: 463 	Training Loss: 0.821909 	Validation Loss: 0.190179
Validation loss decreased (0.191095 --&amp;gt; 0.190179).  Saving model ...
Epoch: 464 	Training Loss: 0.820941 	Validation Loss: 0.193425
Epoch: 465 	Training Loss: 0.820359 	Validation Loss: 0.193750
Epoch: 466 	Training Loss: 0.815640 	Validation Loss: 0.194663
Epoch: 467 	Training Loss: 0.818372 	Validation Loss: 0.192682
Epoch: 468 	Training Loss: 0.817113 	Validation Loss: 0.192452
Epoch: 469 	Training Loss: 0.817581 	Validation Loss: 0.196727
Epoch: 470 	Training Loss: 0.809651 	Validation Loss: 0.190927
Epoch: 471 	Training Loss: 0.811329 	Validation Loss: 0.194151
Epoch: 472 	Training Loss: 0.806093 	Validation Loss: 0.192417
Epoch: 473 	Training Loss: 0.806517 	Validation Loss: 0.189602
Validation loss decreased (0.190179 --&amp;gt; 0.189602).  Saving model ...
Epoch: 474 	Training Loss: 0.807954 	Validation Loss: 0.191487
Epoch: 475 	Training Loss: 0.807010 	Validation Loss: 0.191636
Epoch: 476 	Training Loss: 0.801799 	Validation Loss: 0.190896
Epoch: 477 	Training Loss: 0.798797 	Validation Loss: 0.187708
Validation loss decreased (0.189602 --&amp;gt; 0.187708).  Saving model ...
Epoch: 478 	Training Loss: 0.799128 	Validation Loss: 0.189194
Epoch: 479 	Training Loss: 0.799459 	Validation Loss: 0.194036
Epoch: 480 	Training Loss: 0.795995 	Validation Loss: 0.190724
Epoch: 481 	Training Loss: 0.798655 	Validation Loss: 0.190721
Epoch: 482 	Training Loss: 0.792206 	Validation Loss: 0.188309
Epoch: 483 	Training Loss: 0.799025 	Validation Loss: 0.187985
Epoch: 484 	Training Loss: 0.791694 	Validation Loss: 0.186556
Validation loss decreased (0.187708 --&amp;gt; 0.186556).  Saving model ...
Epoch: 485 	Training Loss: 0.784249 	Validation Loss: 0.184879
Validation loss decreased (0.186556 --&amp;gt; 0.184879).  Saving model ...
Epoch: 486 	Training Loss: 0.793165 	Validation Loss: 0.185806
Epoch: 487 	Training Loss: 0.791051 	Validation Loss: 0.189010
Epoch: 488 	Training Loss: 0.787608 	Validation Loss: 0.186931
Epoch: 489 	Training Loss: 0.789344 	Validation Loss: 0.195780
Epoch: 490 	Training Loss: 0.792061 	Validation Loss: 0.191099
Epoch: 491 	Training Loss: 0.786356 	Validation Loss: 0.189476
Epoch: 492 	Training Loss: 0.784223 	Validation Loss: 0.192026
Epoch: 493 	Training Loss: 0.785188 	Validation Loss: 0.189652
Epoch: 494 	Training Loss: 0.782519 	Validation Loss: 0.188833
Epoch: 495 	Training Loss: 0.786059 	Validation Loss: 0.192020
Epoch: 496 	Training Loss: 0.782317 	Validation Loss: 0.187162
Epoch: 497 	Training Loss: 0.785475 	Validation Loss: 0.191352
Epoch: 498 	Training Loss: 0.778186 	Validation Loss: 0.193208
Epoch: 499 	Training Loss: 0.780198 	Validation Loss: 0.190525
Epoch: 500 	Training Loss: 0.778074 	Validation Loss: 0.194126
Epoch: 501 	Training Loss: 0.778832 	Validation Loss: 0.186440
Epoch: 502 	Training Loss: 0.776556 	Validation Loss: 0.188577
Epoch: 503 	Training Loss: 0.774062 	Validation Loss: 0.190385
Epoch: 504 	Training Loss: 0.776408 	Validation Loss: 0.188763
Elapsed: 0:28:16.205032
Test Loss: 0.925722

Test Accuracy of airplane: 70% (703/1000)
Test Accuracy of automobile: 75% (753/1000)
Test Accuracy of  bird: 47% (470/1000)
Test Accuracy of   cat: 56% (562/1000)
Test Accuracy of  deer: 69% (697/1000)
Test Accuracy of   dog: 53% (536/1000)
Test Accuracy of  frog: 80% (803/1000)
Test Accuracy of horse: 67% (670/1000)
Test Accuracy of  ship: 82% (825/1000)
Test Accuracy of truck: 75% (756/1000)

Test Accuracy (Overall): 67% (6775/10000)
&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;test(model_3)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Test Loss: 0.954966

Test Accuracy of airplane: 62% (629/1000)
Test Accuracy of automobile: 76% (766/1000)
Test Accuracy of  bird: 50% (506/1000)
Test Accuracy of   cat: 44% (449/1000)
Test Accuracy of  deer: 66% (666/1000)
Test Accuracy of   dog: 52% (521/1000)
Test Accuracy of  frog: 82% (827/1000)
Test Accuracy of horse: 72% (721/1000)
Test Accuracy of  ship: 82% (829/1000)
Test Accuracy of truck: 67% (672/1000)

Test Accuracy (Overall): 65% (6586/10000)
&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;outcome = load_and_train(outcome)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Validation loss decreased (inf --&amp;gt; 0.396734).  Saving model ...
Validation loss decreased (0.396734 --&amp;gt; 0.353406).  Saving model ...
Validation loss decreased (0.353406 --&amp;gt; 0.312288).  Saving model ...
Validation loss decreased (0.312288 --&amp;gt; 0.292421).  Saving model ...
Validation loss decreased (0.292421 --&amp;gt; 0.281344).  Saving model ...
Validation loss decreased (0.281344 --&amp;gt; 0.267129).  Saving model ...
Validation loss decreased (0.267129 --&amp;gt; 0.259950).  Saving model ...
Validation loss decreased (0.259950 --&amp;gt; 0.255096).  Saving model ...
Validation loss decreased (0.255096 --&amp;gt; 0.249626).  Saving model ...
Epoch: 110 	Training Loss: 1.074378 	Validation Loss: 0.241995
Validation loss decreased (0.249626 --&amp;gt; 0.241995).  Saving model ...
Validation loss decreased (0.241995 --&amp;gt; 0.234253).  Saving model ...
Validation loss decreased (0.234253 --&amp;gt; 0.233744).  Saving model ...
Validation loss decreased (0.233744 --&amp;gt; 0.226195).  Saving model ...
Validation loss decreased (0.226195 --&amp;gt; 0.225804).  Saving model ...
Validation loss decreased (0.225804 --&amp;gt; 0.223489).  Saving model ...
Validation loss decreased (0.223489 --&amp;gt; 0.221263).  Saving model ...
Validation loss decreased (0.221263 --&amp;gt; 0.217546).  Saving model ...
Validation loss decreased (0.217546 --&amp;gt; 0.215720).  Saving model ...
Validation loss decreased (0.215720 --&amp;gt; 0.213332).  Saving model ...
Epoch: 120 	Training Loss: 0.952941 	Validation Loss: 0.209708
Validation loss decreased (0.213332 --&amp;gt; 0.209708).  Saving model ...
Validation loss decreased (0.209708 --&amp;gt; 0.207232).  Saving model ...
Validation loss decreased (0.207232 --&amp;gt; 0.205873).  Saving model ...
Validation loss decreased (0.205873 --&amp;gt; 0.199750).  Saving model ...
Epoch: 130 	Training Loss: 0.898597 	Validation Loss: 0.197858
Validation loss decreased (0.199750 --&amp;gt; 0.197858).  Saving model ...
Validation loss decreased (0.197858 --&amp;gt; 0.195818).  Saving model ...
Validation loss decreased (0.195818 --&amp;gt; 0.194920).  Saving model ...
Validation loss decreased (0.194920 --&amp;gt; 0.194267).  Saving model ...
Validation loss decreased (0.194267 --&amp;gt; 0.193904).  Saving model ...
Epoch: 140 	Training Loss: 0.856769 	Validation Loss: 0.203387
Validation loss decreased (0.193904 --&amp;gt; 0.187780).  Saving model ...
Epoch: 150 	Training Loss: 0.842055 	Validation Loss: 0.190620
Validation loss decreased (0.187780 --&amp;gt; 0.186874).  Saving model ...
Validation loss decreased (0.186874 --&amp;gt; 0.183554).  Saving model ...
Epoch: 160 	Training Loss: 0.821771 	Validation Loss: 0.186012
Validation loss decreased (0.183554 --&amp;gt; 0.183435).  Saving model ...
Validation loss decreased (0.183435 --&amp;gt; 0.183237).  Saving model ...
Epoch: 170 	Training Loss: 0.807321 	Validation Loss: 0.185445
Epoch: 180 	Training Loss: 0.796137 	Validation Loss: 0.182606
Validation loss decreased (0.183237 --&amp;gt; 0.182606).  Saving model ...
Validation loss decreased (0.182606 --&amp;gt; 0.180978).  Saving model ...
Validation loss decreased (0.180978 --&amp;gt; 0.179344).  Saving model ...
Epoch: 190 	Training Loss: 0.792454 	Validation Loss: 0.181462
Epoch: 200 	Training Loss: 0.777160 	Validation Loss: 0.187384
Ended: 2018-12-14 15:45:54.887063
Elapsed: 1:09:07.537337
Test Loss: 0.913029

Test Accuracy of airplane: 71% (715/1000)
Test Accuracy of automobile: 80% (803/1000)
Test Accuracy of  bird: 44% (445/1000)
Test Accuracy of   cat: 49% (496/1000)
Test Accuracy of  deer: 73% (733/1000)
Test Accuracy of   dog: 54% (540/1000)
Test Accuracy of  frog: 78% (788/1000)
Test Accuracy of horse: 74% (747/1000)
Test Accuracy of  ship: 84% (840/1000)
Test Accuracy of truck: 75% (750/1000)

Test Accuracy (Overall): 68% (6857/10000)
&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;outcome = load_and_train(outcome)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Validation loss decreased (inf --&amp;gt; 0.405255).  Saving model ...
Validation loss decreased (0.405255 --&amp;gt; 0.347472).  Saving model ...
Validation loss decreased (0.347472 --&amp;gt; 0.318586).  Saving model ...
Validation loss decreased (0.318586 --&amp;gt; 0.301050).  Saving model ...
Validation loss decreased (0.301050 --&amp;gt; 0.287208).  Saving model ...
Validation loss decreased (0.287208 --&amp;gt; 0.279541).  Saving model ...
Epoch: 410 	Training Loss: 1.188729 	Validation Loss: 0.269707
Validation loss decreased (0.279541 --&amp;gt; 0.269707).  Saving model ...
Validation loss decreased (0.269707 --&amp;gt; 0.262379).  Saving model ...
Validation loss decreased (0.262379 --&amp;gt; 0.254531).  Saving model ...
Validation loss decreased (0.254531 --&amp;gt; 0.252625).  Saving model ...
Validation loss decreased (0.252625 --&amp;gt; 0.240125).  Saving model ...
Validation loss decreased (0.240125 --&amp;gt; 0.235959).  Saving model ...
Validation loss decreased (0.235959 --&amp;gt; 0.234190).  Saving model ...
Validation loss decreased (0.234190 --&amp;gt; 0.231890).  Saving model ...
Validation loss decreased (0.231890 --&amp;gt; 0.226316).  Saving model ...
Epoch: 420 	Training Loss: 1.003592 	Validation Loss: 0.228944
Validation loss decreased (0.226316 --&amp;gt; 0.224643).  Saving model ...
Validation loss decreased (0.224643 --&amp;gt; 0.222303).  Saving model ...
Validation loss decreased (0.222303 --&amp;gt; 0.221804).  Saving model ...
Validation loss decreased (0.221804 --&amp;gt; 0.219019).  Saving model ...
Validation loss decreased (0.219019 --&amp;gt; 0.211782).  Saving model ...
Epoch: 430 	Training Loss: 0.933949 	Validation Loss: 0.211028
Validation loss decreased (0.211782 --&amp;gt; 0.211028).  Saving model ...
Validation loss decreased (0.211028 --&amp;gt; 0.210736).  Saving model ...
Validation loss decreased (0.210736 --&amp;gt; 0.207784).  Saving model ...
Validation loss decreased (0.207784 --&amp;gt; 0.204068).  Saving model ...
Validation loss decreased (0.204068 --&amp;gt; 0.202933).  Saving model ...
Validation loss decreased (0.202933 --&amp;gt; 0.201327).  Saving model ...
Epoch: 440 	Training Loss: 0.893833 	Validation Loss: 0.201305
Validation loss decreased (0.201327 --&amp;gt; 0.201305).  Saving model ...
Validation loss decreased (0.201305 --&amp;gt; 0.200246).  Saving model ...
Validation loss decreased (0.200246 --&amp;gt; 0.199212).  Saving model ...
Validation loss decreased (0.199212 --&amp;gt; 0.198127).  Saving model ...
Validation loss decreased (0.198127 --&amp;gt; 0.197780).  Saving model ...
Epoch: 450 	Training Loss: 0.869887 	Validation Loss: 0.193194
Validation loss decreased (0.197780 --&amp;gt; 0.193194).  Saving model ...
Validation loss decreased (0.193194 --&amp;gt; 0.192689).  Saving model ...
Validation loss decreased (0.192689 --&amp;gt; 0.191178).  Saving model ...
Epoch: 460 	Training Loss: 0.845976 	Validation Loss: 0.193641
Validation loss decreased (0.191178 --&amp;gt; 0.190434).  Saving model ...
Epoch: 470 	Training Loss: 0.831866 	Validation Loss: 0.190801
Validation loss decreased (0.190434 --&amp;gt; 0.189088).  Saving model ...
Epoch: 480 	Training Loss: 0.814776 	Validation Loss: 0.190064
Validation loss decreased (0.189088 --&amp;gt; 0.189077).  Saving model ...
Validation loss decreased (0.189077 --&amp;gt; 0.188256).  Saving model ...
Validation loss decreased (0.188256 --&amp;gt; 0.185333).  Saving model ...
Epoch: 490 	Training Loss: 0.804873 	Validation Loss: 0.190370
Epoch: 500 	Training Loss: 0.792694 	Validation Loss: 0.188568
Ended: 2018-12-14 22:04:39.786682
Elapsed: 0:28:03.912152
Test Loss: 0.933276

Test Accuracy of airplane: 75% (756/1000)
Test Accuracy of automobile: 74% (744/1000)
Test Accuracy of  bird: 48% (482/1000)
Test Accuracy of   cat: 44% (443/1000)
Test Accuracy of  deer: 68% (686/1000)
Test Accuracy of   dog: 50% (502/1000)
Test Accuracy of  frog: 80% (801/1000)
Test Accuracy of horse: 68% (681/1000)
Test Accuracy of  ship: 82% (823/1000)
Test Accuracy of truck: 77% (770/1000)

Test Accuracy (Overall): 66% (6688/10000)
&lt;/pre&gt;

&lt;p&gt;
The overall test-accuracy is going down - is it overfitting?
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;with open("model_3_outcomes.pkl", "rb") as reader:
    outcome = pickle.load(reader)

outcome = load_and_train(outcome)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Validation loss decreased (inf --&amp;gt; 0.400317).  Saving model ...
Validation loss decreased (0.400317 --&amp;gt; 0.339392).  Saving model ...
Epoch: 810 	Training Loss: 1.361320 	Validation Loss: 0.310385
Validation loss decreased (0.339392 --&amp;gt; 0.310385).  Saving model ...
Validation loss decreased (0.310385 --&amp;gt; 0.295311).  Saving model ...
Validation loss decreased (0.295311 --&amp;gt; 0.283410).  Saving model ...
Validation loss decreased (0.283410 --&amp;gt; 0.274456).  Saving model ...
Validation loss decreased (0.274456 --&amp;gt; 0.266069).  Saving model ...
Validation loss decreased (0.266069 --&amp;gt; 0.262745).  Saving model ...
Validation loss decreased (0.262745 --&amp;gt; 0.247262).  Saving model ...
Validation loss decreased (0.247262 --&amp;gt; 0.237769).  Saving model ...
Epoch: 820 	Training Loss: 1.028606 	Validation Loss: 0.236005
Validation loss decreased (0.237769 --&amp;gt; 0.236005).  Saving model ...
Validation loss decreased (0.236005 --&amp;gt; 0.230968).  Saving model ...
Validation loss decreased (0.230968 --&amp;gt; 0.228058).  Saving model ...
Validation loss decreased (0.228058 --&amp;gt; 0.224573).  Saving model ...
Validation loss decreased (0.224573 --&amp;gt; 0.223884).  Saving model ...
Validation loss decreased (0.223884 --&amp;gt; 0.219913).  Saving model ...
Validation loss decreased (0.219913 --&amp;gt; 0.217769).  Saving model ...
Epoch: 830 	Training Loss: 0.942998 	Validation Loss: 0.215061
Validation loss decreased (0.217769 --&amp;gt; 0.215061).  Saving model ...
Validation loss decreased (0.215061 --&amp;gt; 0.212656).  Saving model ...
Validation loss decreased (0.212656 --&amp;gt; 0.212616).  Saving model ...
Validation loss decreased (0.212616 --&amp;gt; 0.210596).  Saving model ...
Validation loss decreased (0.210596 --&amp;gt; 0.207554).  Saving model ...
Epoch: 840 	Training Loss: 0.900498 	Validation Loss: 0.208390
Validation loss decreased (0.207554 --&amp;gt; 0.206364).  Saving model ...
Validation loss decreased (0.206364 --&amp;gt; 0.205531).  Saving model ...
Validation loss decreased (0.205531 --&amp;gt; 0.203900).  Saving model ...
Epoch: 850 	Training Loss: 0.872049 	Validation Loss: 0.205466
Validation loss decreased (0.203900 --&amp;gt; 0.198664).  Saving model ...
Validation loss decreased (0.198664 --&amp;gt; 0.196482).  Saving model ...
Validation loss decreased (0.196482 --&amp;gt; 0.195664).  Saving model ...
Epoch: 860 	Training Loss: 0.845757 	Validation Loss: 0.198456
Validation loss decreased (0.195664 --&amp;gt; 0.193952).  Saving model ...
Epoch: 870 	Training Loss: 0.826413 	Validation Loss: 0.195060
Validation loss decreased (0.193952 --&amp;gt; 0.193670).  Saving model ...
Validation loss decreased (0.193670 --&amp;gt; 0.192782).  Saving model ...
Validation loss decreased (0.192782 --&amp;gt; 0.188631).  Saving model ...
Epoch: 880 	Training Loss: 0.818928 	Validation Loss: 0.199424
Epoch: 890 	Training Loss: 0.808009 	Validation Loss: 0.191352
Epoch: 900 	Training Loss: 0.801281 	Validation Loss: 0.196643
Ended: 2018-12-14 22:37:13.843477
Elapsed: 0:29:26.736300
Test Loss: 0.945705

Test Accuracy of airplane: 72% (725/1000)
Test Accuracy of automobile: 78% (782/1000)
Test Accuracy of  bird: 47% (473/1000)
Test Accuracy of   cat: 48% (488/1000)
Test Accuracy of  deer: 70% (705/1000)
Test Accuracy of   dog: 52% (527/1000)
Test Accuracy of  frog: 77% (776/1000)
Test Accuracy of horse: 69% (696/1000)
Test Accuracy of  ship: 84% (844/1000)
Test Accuracy of truck: 70% (703/1000)

Test Accuracy (Overall): 67% (6719/10000)
&lt;/pre&gt;

&lt;p&gt;
It looks like the overall accuracy dropped slightly beacause the best categories (truck, ship, frog) did worse but the worst categories did slightly better - although not bird for some reason.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3635ad8" class="outline-2"&gt;
&lt;h2 id="org3635ad8"&gt;Take two&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3635ad8"&gt;
&lt;p&gt;
It looks like I wasn't loading the model between each round of epochs…
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;outcome = load_and_train(model_number=4, epochs=200)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Epoch: 0 	Training Loss: 1.784692 	Validation Loss: 0.410727
Validation loss decreased (inf --&amp;gt; 0.410727).  Saving model ...
Validation loss decreased (0.410727 --&amp;gt; 0.360800).  Saving model ...
Validation loss decreased (0.360800 --&amp;gt; 0.314237).  Saving model ...
Validation loss decreased (0.314237 --&amp;gt; 0.293987).  Saving model ...
Validation loss decreased (0.293987 --&amp;gt; 0.283064).  Saving model ...
Validation loss decreased (0.283064 --&amp;gt; 0.275761).  Saving model ...
Validation loss decreased (0.275761 --&amp;gt; 0.270119).  Saving model ...
Validation loss decreased (0.270119 --&amp;gt; 0.261688).  Saving model ...
Validation loss decreased (0.261688 --&amp;gt; 0.254598).  Saving model ...
Epoch: 10 	Training Loss: 1.092668 	Validation Loss: 0.254406
Validation loss decreased (0.254598 --&amp;gt; 0.254406).  Saving model ...
Validation loss decreased (0.254406 --&amp;gt; 0.248653).  Saving model ...
Validation loss decreased (0.248653 --&amp;gt; 0.245797).  Saving model ...
Validation loss decreased (0.245797 --&amp;gt; 0.240849).  Saving model ...
Validation loss decreased (0.240849 --&amp;gt; 0.238558).  Saving model ...
Validation loss decreased (0.238558 --&amp;gt; 0.237812).  Saving model ...
Validation loss decreased (0.237812 --&amp;gt; 0.230956).  Saving model ...
Epoch: 20 	Training Loss: 0.991010 	Validation Loss: 0.225704
Validation loss decreased (0.230956 --&amp;gt; 0.225704).  Saving model ...
Validation loss decreased (0.225704 --&amp;gt; 0.221112).  Saving model ...
Validation loss decreased (0.221112 --&amp;gt; 0.218632).  Saving model ...
Epoch: 30 	Training Loss: 0.938513 	Validation Loss: 0.220019
Validation loss decreased (0.218632 --&amp;gt; 0.216886).  Saving model ...
Validation loss decreased (0.216886 --&amp;gt; 0.215869).  Saving model ...
Validation loss decreased (0.215869 --&amp;gt; 0.214766).  Saving model ...
Validation loss decreased (0.214766 --&amp;gt; 0.212452).  Saving model ...
Epoch: 40 	Training Loss: 0.896510 	Validation Loss: 0.212819
Validation loss decreased (0.212452 --&amp;gt; 0.209142).  Saving model ...
Validation loss decreased (0.209142 --&amp;gt; 0.208595).  Saving model ...
Validation loss decreased (0.208595 --&amp;gt; 0.205967).  Saving model ...
Validation loss decreased (0.205967 --&amp;gt; 0.205484).  Saving model ...
Epoch: 50 	Training Loss: 0.875811 	Validation Loss: 0.207912
Validation loss decreased (0.205484 --&amp;gt; 0.205164).  Saving model ...
Epoch: 60 	Training Loss: 0.856581 	Validation Loss: 0.208312
Validation loss decreased (0.205164 --&amp;gt; 0.204649).  Saving model ...
Validation loss decreased (0.204649 --&amp;gt; 0.203608).  Saving model ...
Epoch: 70 	Training Loss: 0.846062 	Validation Loss: 0.214614
Validation loss decreased (0.203608 --&amp;gt; 0.203064).  Saving model ...
Epoch: 80 	Training Loss: 0.826153 	Validation Loss: 0.212527
Validation loss decreased (0.203064 --&amp;gt; 0.201932).  Saving model ...
Validation loss decreased (0.201932 --&amp;gt; 0.200173).  Saving model ...
Epoch: 90 	Training Loss: 0.823697 	Validation Loss: 0.204494
Validation loss decreased (0.200173 --&amp;gt; 0.199886).  Saving model ...
Validation loss decreased (0.199886 --&amp;gt; 0.198804).  Saving model ...
Epoch: 100 	Training Loss: 0.808043 	Validation Loss: 0.205323
Epoch: 110 	Training Loss: 0.805417 	Validation Loss: 0.201136
Epoch: 120 	Training Loss: 0.805155 	Validation Loss: 0.204370
Epoch: 130 	Training Loss: 0.793174 	Validation Loss: 0.214048
Validation loss decreased (0.198804 --&amp;gt; 0.194650).  Saving model ...
Epoch: 140 	Training Loss: 0.783871 	Validation Loss: 0.200537
Epoch: 150 	Training Loss: 0.781592 	Validation Loss: 0.203295
Epoch: 160 	Training Loss: 0.774657 	Validation Loss: 0.199732
Epoch: 170 	Training Loss: 0.770487 	Validation Loss: 0.205331
Epoch: 180 	Training Loss: 0.767693 	Validation Loss: 0.202990
Epoch: 190 	Training Loss: 0.767225 	Validation Loss: 0.203797
Epoch: 200 	Training Loss: 0.769268 	Validation Loss: 0.196108
Test Loss: 0.974566

Test Accuracy of airplane: 70% (707/1000)
Test Accuracy of automobile: 73% (732/1000)
Test Accuracy of  bird: 45% (453/1000)
Test Accuracy of   cat: 53% (533/1000)
Test Accuracy of  deer: 71% (719/1000)
Test Accuracy of   dog: 42% (429/1000)
Test Accuracy of  frog: 81% (814/1000)
Test Accuracy of horse: 66% (666/1000)
Test Accuracy of  ship: 82% (823/1000)
Test Accuracy of truck: 72% (720/1000)

Test Accuracy (Overall): 65% (6596/10000)
Ended: 2018-12-15 08:33:22.925579
Elapsed: 0:55:24.733457
&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;outcome = load_and_train(model_number=4, epochs=200)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Validation loss decreased (inf --&amp;gt; 0.203577).  Saving model ...
Validation loss decreased (0.203577 --&amp;gt; 0.201161).  Saving model ...
Validation loss decreased (0.201161 --&amp;gt; 0.198027).  Saving model ...
Epoch: 210 	Training Loss: 0.785905 	Validation Loss: 0.199885
Epoch: 220 	Training Loss: 0.780148 	Validation Loss: 0.199842
Validation loss decreased (0.198027 --&amp;gt; 0.197471).  Saving model ...
Epoch: 230 	Training Loss: 0.773492 	Validation Loss: 0.206471
Validation loss decreased (0.197471 --&amp;gt; 0.195811).  Saving model ...
Epoch: 240 	Training Loss: 0.777896 	Validation Loss: 0.201046
Epoch: 250 	Training Loss: 0.767602 	Validation Loss: 0.203973
Epoch: 260 	Training Loss: 0.765374 	Validation Loss: 0.205219
Epoch: 270 	Training Loss: 0.764604 	Validation Loss: 0.202613
Epoch: 280 	Training Loss: 0.755534 	Validation Loss: 0.201307
Epoch: 290 	Training Loss: 0.754538 	Validation Loss: 0.199495
Epoch: 300 	Training Loss: 0.759395 	Validation Loss: 0.206451
Epoch: 310 	Training Loss: 0.750621 	Validation Loss: 0.203110
Epoch: 320 	Training Loss: 0.751456 	Validation Loss: 0.206920
Epoch: 330 	Training Loss: 0.747122 	Validation Loss: 0.199856
Epoch: 340 	Training Loss: 0.742640 	Validation Loss: 0.211159
Epoch: 350 	Training Loss: 0.743110 	Validation Loss: 0.214833
Epoch: 360 	Training Loss: 0.741861 	Validation Loss: 0.207520
Epoch: 370 	Training Loss: 0.740826 	Validation Loss: 0.210348
Epoch: 380 	Training Loss: 0.740333 	Validation Loss: 0.207724
Epoch: 390 	Training Loss: 0.739157 	Validation Loss: 0.204985
Epoch: 400 	Training Loss: 0.742582 	Validation Loss: 0.204150
Test Loss: 0.979350

Test Accuracy of airplane: 64% (648/1000)
Test Accuracy of automobile: 75% (751/1000)
Test Accuracy of  bird: 43% (430/1000)
Test Accuracy of   cat: 50% (507/1000)
Test Accuracy of  deer: 76% (766/1000)
Test Accuracy of   dog: 44% (443/1000)
Test Accuracy of  frog: 81% (818/1000)
Test Accuracy of horse: 63% (630/1000)
Test Accuracy of  ship: 86% (868/1000)
Test Accuracy of truck: 68% (680/1000)

Test Accuracy (Overall): 65% (6541/10000)
Ended: 2018-12-15 11:19:36.845565
Elapsed: 0:55:22.008796
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd200933" class="outline-2"&gt;
&lt;h2 id="orgd200933"&gt;Change the Training and Validation Sets&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd200933"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;INDICES = list(range(len(training_data)))
DataIterators = (torch.utils.data.dataloader.DataLoader,
		 torch.utils.data.dataloader.DataLoader)

def split_data() -&amp;gt; DataIterators:
    training_indices, validation_indices = train_test_split(
	INDICES,
	test_size=VALIDATION_FRACTION)
    train_sampler = SubsetRandomSampler(training_indices)
    valid_sampler = SubsetRandomSampler(validation_indices)
    train_loader = torch.utils.data.DataLoader(
	training_data, batch_size=BATCH_SIZE,
	sampler=train_sampler, num_workers=NUM_WORKERS)
    valid_loader = torch.utils.data.DataLoader(
	training_data, batch_size=BATCH_SIZE, 
	sampler=valid_sampler, num_workers=NUM_WORKERS)
    return train_loader, valid_loader
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;train_loader, valid_loader = split_data()
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for epoch in range(8):
    outcome = load_and_train(model_number=4, epochs=50)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Validation loss decreased (inf --&amp;gt; 0.178021).  Saving model ...
Validation loss decreased (0.178021 --&amp;gt; 0.164977).  Saving model ...
Epoch: 410 	Training Loss: 0.790843 	Validation Loss: 0.180614
Epoch: 420 	Training Loss: 0.779451 	Validation Loss: 0.184705
Epoch: 430 	Training Loss: 0.776067 	Validation Loss: 0.188225
Epoch: 440 	Training Loss: 0.767443 	Validation Loss: 0.189623
Epoch: 450 	Training Loss: 0.763348 	Validation Loss: 0.190223
Test Loss: 0.994385

Test Accuracy of airplane: 63% (632/1000)
Test Accuracy of automobile: 73% (738/1000)
Test Accuracy of  bird: 43% (432/1000)
Test Accuracy of   cat: 55% (551/1000)
Test Accuracy of  deer: 73% (731/1000)
Test Accuracy of   dog: 38% (384/1000)
Test Accuracy of  frog: 82% (828/1000)
Test Accuracy of horse: 63% (632/1000)
Test Accuracy of  ship: 88% (880/1000)
Test Accuracy of truck: 65% (658/1000)

Test Accuracy (Overall): 64% (6466/10000)
Ended: 2018-12-15 11:57:44.922535
Elapsed: 0:14:05.152783
Validation loss decreased (inf --&amp;gt; 0.170476).  Saving model ...
Epoch: 810 	Training Loss: 0.791785 	Validation Loss: 0.185611
Epoch: 820 	Training Loss: 0.775938 	Validation Loss: 0.185072
Epoch: 830 	Training Loss: 0.776210 	Validation Loss: 0.187146
Epoch: 840 	Training Loss: 0.768063 	Validation Loss: 0.182017
Epoch: 850 	Training Loss: 0.769061 	Validation Loss: 0.196850
Test Loss: 1.012101

Test Accuracy of airplane: 62% (624/1000)
Test Accuracy of automobile: 73% (738/1000)
Test Accuracy of  bird: 42% (429/1000)
Test Accuracy of   cat: 55% (551/1000)
Test Accuracy of  deer: 73% (730/1000)
Test Accuracy of   dog: 42% (420/1000)
Test Accuracy of  frog: 85% (854/1000)
Test Accuracy of horse: 60% (604/1000)
Test Accuracy of  ship: 84% (843/1000)
Test Accuracy of truck: 67% (679/1000)

Test Accuracy (Overall): 64% (6472/10000)
Ended: 2018-12-15 12:12:04.058599
Elapsed: 0:14:19.132241
Validation loss decreased (inf --&amp;gt; 0.174863).  Saving model ...
Epoch: 1610 	Training Loss: 0.797948 	Validation Loss: 0.176395
Validation loss decreased (0.174863 --&amp;gt; 0.172779).  Saving model ...
Validation loss decreased (0.172779 --&amp;gt; 0.170694).  Saving model ...
Epoch: 1620 	Training Loss: 0.789980 	Validation Loss: 0.178468
Epoch: 1630 	Training Loss: 0.772959 	Validation Loss: 0.183980
Epoch: 1640 	Training Loss: 0.776142 	Validation Loss: 0.198711
Epoch: 1650 	Training Loss: 0.767914 	Validation Loss: 0.208851
Test Loss: 0.987713

Test Accuracy of airplane: 62% (624/1000)
Test Accuracy of automobile: 74% (743/1000)
Test Accuracy of  bird: 43% (436/1000)
Test Accuracy of   cat: 52% (525/1000)
Test Accuracy of  deer: 73% (734/1000)
Test Accuracy of   dog: 47% (473/1000)
Test Accuracy of  frog: 83% (831/1000)
Test Accuracy of horse: 63% (631/1000)
Test Accuracy of  ship: 84% (845/1000)
Test Accuracy of truck: 68% (682/1000)

Test Accuracy (Overall): 65% (6524/10000)
Ended: 2018-12-15 12:26:50.701191
Elapsed: 0:14:46.638712
Validation loss decreased (inf --&amp;gt; 0.181906).  Saving model ...
Validation loss decreased (0.181906 --&amp;gt; 0.175381).  Saving model ...
Validation loss decreased (0.175381 --&amp;gt; 0.169833).  Saving model ...
Epoch: 3220 	Training Loss: 0.776567 	Validation Loss: 0.178259
Epoch: 3230 	Training Loss: 0.777072 	Validation Loss: 0.180300
Epoch: 3240 	Training Loss: 0.770289 	Validation Loss: 0.192919
Epoch: 3250 	Training Loss: 0.762633 	Validation Loss: 0.192530
Epoch: 3260 	Training Loss: 0.760599 	Validation Loss: 0.195964
Test Loss: 0.982302

Test Accuracy of airplane: 66% (665/1000)
Test Accuracy of automobile: 75% (756/1000)
Test Accuracy of  bird: 44% (444/1000)
Test Accuracy of   cat: 56% (565/1000)
Test Accuracy of  deer: 68% (686/1000)
Test Accuracy of   dog: 40% (407/1000)
Test Accuracy of  frog: 85% (855/1000)
Test Accuracy of horse: 63% (639/1000)
Test Accuracy of  ship: 84% (844/1000)
Test Accuracy of truck: 68% (683/1000)

Test Accuracy (Overall): 65% (6544/10000)
Ended: 2018-12-15 12:41:47.333383
Elapsed: 0:14:56.629183
Validation loss decreased (inf --&amp;gt; 0.187802).  Saving model ...
Validation loss decreased (0.187802 --&amp;gt; 0.184430).  Saving model ...
Validation loss decreased (0.184430 --&amp;gt; 0.183925).  Saving model ...
Validation loss decreased (0.183925 --&amp;gt; 0.180367).  Saving model ...
Validation loss decreased (0.180367 --&amp;gt; 0.173719).  Saving model ...
Epoch: 6440 	Training Loss: 0.778801 	Validation Loss: 0.190905
Epoch: 6450 	Training Loss: 0.771958 	Validation Loss: 0.182070
Epoch: 6460 	Training Loss: 0.764318 	Validation Loss: 0.190349
Epoch: 6470 	Training Loss: 0.766295 	Validation Loss: 0.192508
Epoch: 6480 	Training Loss: 0.761968 	Validation Loss: 0.189583
Test Loss: 0.987995

Test Accuracy of airplane: 66% (661/1000)
Test Accuracy of automobile: 76% (763/1000)
Test Accuracy of  bird: 44% (443/1000)
Test Accuracy of   cat: 55% (557/1000)
Test Accuracy of  deer: 72% (728/1000)
Test Accuracy of   dog: 41% (415/1000)
Test Accuracy of  frog: 85% (853/1000)
Test Accuracy of horse: 60% (600/1000)
Test Accuracy of  ship: 84% (849/1000)
Test Accuracy of truck: 66% (669/1000)

Test Accuracy (Overall): 65% (6538/10000)
Ended: 2018-12-15 12:56:04.438153
Elapsed: 0:14:17.094202
Validation loss decreased (inf --&amp;gt; 0.191682).  Saving model ...
Validation loss decreased (0.191682 --&amp;gt; 0.182732).  Saving model ...
Validation loss decreased (0.182732 --&amp;gt; 0.181846).  Saving model ...
Epoch: 12870 	Training Loss: 0.770414 	Validation Loss: 0.185177
Validation loss decreased (0.181846 --&amp;gt; 0.179913).  Saving model ...
Epoch: 12880 	Training Loss: 0.772306 	Validation Loss: 0.191702
Epoch: 12890 	Training Loss: 0.768497 	Validation Loss: 0.181795
Epoch: 12900 	Training Loss: 0.760247 	Validation Loss: 0.183884
Epoch: 12910 	Training Loss: 0.757400 	Validation Loss: 0.197759
Test Loss: 0.995634

Test Accuracy of airplane: 64% (648/1000)
Test Accuracy of automobile: 75% (755/1000)
Test Accuracy of  bird: 37% (377/1000)
Test Accuracy of   cat: 55% (557/1000)
Test Accuracy of  deer: 72% (726/1000)
Test Accuracy of   dog: 45% (459/1000)
Test Accuracy of  frog: 85% (857/1000)
Test Accuracy of horse: 59% (590/1000)
Test Accuracy of  ship: 84% (842/1000)
Test Accuracy of truck: 69% (696/1000)

Test Accuracy (Overall): 65% (6507/10000)
Ended: 2018-12-15 13:10:05.720077
Elapsed: 0:14:01.278026
Validation loss decreased (inf --&amp;gt; 0.190403).  Saving model ...
Validation loss decreased (0.190403 --&amp;gt; 0.187068).  Saving model ...
Epoch: 25730 	Training Loss: 0.768132 	Validation Loss: 0.185507
Validation loss decreased (0.187068 --&amp;gt; 0.185507).  Saving model ...
Validation loss decreased (0.185507 --&amp;gt; 0.177258).  Saving model ...
Epoch: 25740 	Training Loss: 0.772002 	Validation Loss: 0.190112
Epoch: 25750 	Training Loss: 0.760312 	Validation Loss: 0.195855
Epoch: 25760 	Training Loss: 0.759808 	Validation Loss: 0.204542
Epoch: 25770 	Training Loss: 0.756103 	Validation Loss: 0.193606
Test Loss: 0.979529

Test Accuracy of airplane: 66% (663/1000)
Test Accuracy of automobile: 76% (769/1000)
Test Accuracy of  bird: 39% (396/1000)
Test Accuracy of   cat: 57% (578/1000)
Test Accuracy of  deer: 74% (749/1000)
Test Accuracy of   dog: 41% (414/1000)
Test Accuracy of  frog: 83% (833/1000)
Test Accuracy of horse: 61% (618/1000)
Test Accuracy of  ship: 84% (844/1000)
Test Accuracy of truck: 68% (687/1000)

Test Accuracy (Overall): 65% (6551/10000)
Ended: 2018-12-15 13:24:12.319440
Elapsed: 0:14:06.595121
Validation loss decreased (inf --&amp;gt; 0.186117).  Saving model ...
Validation loss decreased (0.186117 --&amp;gt; 0.182822).  Saving model ...
Epoch: 51460 	Training Loss: 0.767829 	Validation Loss: 0.189161
Epoch: 51470 	Training Loss: 0.763347 	Validation Loss: 0.194681
Validation loss decreased (0.182822 --&amp;gt; 0.179458).  Saving model ...
Epoch: 51480 	Training Loss: 0.756280 	Validation Loss: 0.187176
Epoch: 51490 	Training Loss: 0.757250 	Validation Loss: 0.198088
Epoch: 51500 	Training Loss: 0.754145 	Validation Loss: 0.204468
Test Loss: 0.973007

Test Accuracy of airplane: 67% (676/1000)
Test Accuracy of automobile: 74% (749/1000)
Test Accuracy of  bird: 41% (415/1000)
Test Accuracy of   cat: 57% (579/1000)
Test Accuracy of  deer: 75% (752/1000)
Test Accuracy of   dog: 41% (412/1000)
Test Accuracy of  frog: 81% (815/1000)
Test Accuracy of horse: 65% (653/1000)
Test Accuracy of  ship: 85% (850/1000)
Test Accuracy of truck: 69% (696/1000)

Test Accuracy (Overall): 65% (6597/10000)
Ended: 2018-12-15 13:38:06.475872
Elapsed: 0:13:54.151685
&lt;/pre&gt;

&lt;p&gt;
So, this model seems pretty much stuck. I cheated and peaked at the lecturer's solution, but this post is getting too long so I'll save that for another one.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;figure, axe = pyplot.subplots()
figure.suptitle("Loss")
x = list(range(len(outcome["training_loss"])))
training = numpy.array(outcome["training_loss"])
limit = 500
axe.plot(x[:limit], training[:limit], ".", label="Training")
axe.plot(x[:limit], outcome["validation_loss"][:limit], ".", label="Validation")
legend = axe.legend()
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/final_model.png" alt="final_model.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
So it looks like there's something wrong with my code. I'll have to figure this out (or just stick with straight epochs).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cnn</category><category>exercise</category><guid>https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/cifar-10/</guid><pubDate>Tue, 04 Dec 2018 23:26:15 GMT</pubDate></item><item><title>Visualizing Max Pooling</title><link>https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-max-pooling/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-max-pooling/#org3557c3d"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-max-pooling/#org055949d"&gt;Set Up&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-max-pooling/#orgf5c563b"&gt;Define and visualize the filters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-max-pooling/#org7098889"&gt;Define convolutional and pooling layers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-max-pooling/#orgbcbe9c5"&gt;Visualize the output of each filter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-max-pooling/#org5094c97"&gt;ReLu activation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-max-pooling/#org315c4a6"&gt;Visualize the output of the pooling layer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3557c3d" class="outline-2"&gt;
&lt;h2 id="org3557c3d"&gt;Introduction&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3557c3d"&gt;
&lt;p&gt;
This is from &lt;a href="https://github.com/udacity/deep-learning-v2-pytorch.git"&gt;Udacity's Deep Learning Repository&lt;/a&gt; which supports their Deep Learning Nanodegree.
&lt;/p&gt;

&lt;p&gt;
In this notebook, we will visualize the output of a maxpooling layer in a CNN. 
&lt;/p&gt;

&lt;p&gt;
A convolutional layer + activation function, followed by a pooling layer, and a linear layer (to create a desired output size) make up the basic layers of a CNN.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org055949d" class="outline-2"&gt;
&lt;h2 id="org055949d"&gt;Set Up&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org055949d"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc6c4398" class="outline-3"&gt;
&lt;h3 id="orgc6c4398"&gt;Imports&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgc6c4398"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org836d887" class="outline-4"&gt;
&lt;h4 id="org836d887"&gt;PyPi&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org836d887"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from dotenv import load_dotenv
import cv2
import matplotlib.pyplot as pyplot
import numpy
import seaborn
import torch
import torch.nn as nn
import torch.nn.functional as F
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org562f8fa" class="outline-4"&gt;
&lt;h4 id="org562f8fa"&gt;This Project&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org562f8fa"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from neurotic.tangles.data_paths import DataPathTwo
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org50d05b0" class="outline-3"&gt;
&lt;h3 id="org50d05b0"&gt;Plotting&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org50d05b0"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;get_ipython().run_line_magic('matplotlib', 'inline')
seaborn.set(style="whitegrid",
	    rc={"axes.grid": False,
		"font.family": ["sans-serif"],
		"font.sans-serif": ["Latin Modern Sans", "Lato"],
		"figure.figsize": (14, 12)},
	    font_scale=3)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org90cd7b9" class="outline-3"&gt;
&lt;h3 id="org90cd7b9"&gt;Load the Data&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org90cd7b9"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;load_dotenv()
path = DataPathTwo("rodin.jpg", "CNN")
print(path.from_folder)
assert path.from_folder.is_file()
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
/home/brunhilde/datasets/cnn/rodin.jpg

&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bgr_img = cv2.imread(str(path.from_folder))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6966c24" class="outline-4"&gt;
&lt;h4 id="org6966c24"&gt;Convert To Grayscale&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org6966c24"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gray_img = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2GRAY)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org2e4ea85" class="outline-4"&gt;
&lt;h4 id="org2e4ea85"&gt;Normalize: Rescale Entries To Lie In [0,1]&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org2e4ea85"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gray_img = gray_img.astype("float32")/255
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;image = pyplot.imshow(gray_img, cmap='gray')
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-max-pooling/gray_image.png" alt="gray_image.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf5c563b" class="outline-2"&gt;
&lt;h2 id="orgf5c563b"&gt;Define and visualize the filters&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgf5c563b"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;filter_vals = numpy.array([[-1, -1, -1],
			   [-1, 8, -1],
			   [-1, -1, -1]])
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print('Filter shape: ', filter_vals.shape)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Filter shape:  (3, 3)

&lt;/pre&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3ea0242" class="outline-3"&gt;
&lt;h3 id="org3ea0242"&gt;Defining four different filters,&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org3ea0242"&gt;
&lt;p&gt;
All of these are linear combinations of the &lt;code&gt;filter_vals&lt;/code&gt; defined above
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;filter_1 = filter_vals
filter_2 = -filter_1
filter_3 = filter_1.T
filter_4 = -filter_3
filters = numpy.array([filter_1, filter_2, filter_3, filter_4])
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print('Filter 1: \n', filter_4)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Filter 1: 
 [[ 1  1  1]
 [ 1 -8  1]
 [ 1  1  1]]

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7098889" class="outline-2"&gt;
&lt;h2 id="org7098889"&gt;Define convolutional and pooling layers&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org7098889"&gt;
&lt;p&gt;
You've seen how to define a convolutional layer, next is a &lt;b&gt;Pooling Layer&lt;/b&gt;.
&lt;/p&gt;

&lt;p&gt;
In the next cell, we initialize a convolutional layer so that it contains all the created filters. Then add a maxpooling layer, &lt;a href="http://pytorch.org/docs/stable/_modules/torch/nn/modules/pooling.html"&gt;documented here&lt;/a&gt;, with a kernel size of (2x2) so you can see that the image resolution has been reduced after this step.
&lt;/p&gt;

&lt;p&gt;
A maxpooling layer reduces the x-y size of an input and only keeps the most &lt;b&gt;active&lt;/b&gt; pixel values. Below is an example of a 2x2 pooling kernel, with a stride of 2, appied to a small patch of grayscale pixel values; reducing the x-y size of the patch by a factor of 2. Only the maximum pixel values in 2x2 remain in the new, pooled output.
&lt;/p&gt;


&lt;p&gt;
Define a neural network with a convolutional layer with four filters &lt;i&gt;and&lt;/i&gt; a pooling layer of size (2, 2).
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1de93e4" class="outline-3"&gt;
&lt;h3 id="org1de93e4"&gt;The Model&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1de93e4"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;class Net(nn.Module):
    """A convolutional neural network to process 4 filters

    Args:
     weight: matrix of filters
    """
    def __init__(self, weight: numpy.ndarray) -&amp;gt; None:
	super(Net, self).__init__()
	# initializes the weights of the convolutional layer to be the weights of the 4 defined filters
	k_height, k_width = weight.shape[2:]
	# assumes there are 4 grayscale filters
	self.conv = nn.Conv2d(1, 4, kernel_size=(k_height, k_width), bias=False)
	self.conv.weight = torch.nn.Parameter(weight)
	# define a pooling layer
	self.pool = nn.MaxPool2d(2, 2)
	return

    def forward(self, x: torch.Tensor):
	"""calculates the output of a convolutional layer

	Args:
	 x: image to process

	Returns:
	 layers: convolutional, activated, and pooled layers
	"""
	conv_x = self.conv(x)
	activated_x = F.relu(conv_x)

	# applies pooling layer
	pooled_x = self.pool(activated_x)

	# returns all layers
	return conv_x, activated_x, pooled_x
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdc95b9c" class="outline-3"&gt;
&lt;h3 id="orgdc95b9c"&gt;instantiate the model and set the weights&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgdc95b9c"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;weight = torch.from_numpy(filters).unsqueeze(1).type(torch.FloatTensor)
model = Net(weight)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(model)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Net(
  (conv): Conv2d(1, 4, kernel_size=(3, 3), stride=(1, 1), bias=False)
  (pool): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
)

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbcbe9c5" class="outline-2"&gt;
&lt;h2 id="orgbcbe9c5"&gt;Visualize the output of each filter&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgbcbe9c5"&gt;
&lt;p&gt;
First, we'll define a helper function, &lt;code&gt;viz_layer&lt;/code&gt; that takes in a specific layer and number of filters (optional argument), and displays the output of that layer once an image has been passed through.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def viz_layer(layer, n_filters= 4):
    fig = pyplot.figure(figsize=(20, 20))

    for i in range(n_filters):
	ax = fig.add_subplot(1, n_filters, i+1)
	# grab layer outputs
	ax.imshow(numpy.squeeze(layer[0,i].data.numpy()), cmap='gray')
	ax.set_title('Output %s' % str(i+1))
    return
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
Let's look at the output of a convolutional layer after a ReLu activation function is applied.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5094c97" class="outline-2"&gt;
&lt;h2 id="org5094c97"&gt;ReLu activation&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org5094c97"&gt;
&lt;p&gt;
A ReLu function turns all negative pixel values in 0's (black). See the equation pictured below for input pixel values, &lt;code&gt;x&lt;/code&gt;. 
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-max-pooling/gray_image.png" alt="gray_image.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8249b00" class="outline-3"&gt;
&lt;h3 id="org8249b00"&gt;Visualize All the Filters&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org8249b00"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fig = pyplot.figure(figsize=(12, 6))
fig.subplots_adjust(left=0, right=1.5, bottom=0.8, top=1, hspace=0.05, wspace=0.05)
for i in range(4):
    ax = fig.add_subplot(1, 4, i+1, xticks=[], yticks=[])
    ax.imshow(filters[i], cmap='gray')
    ax.set_title('Filter %s' % str(i+1))
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-max-pooling/filters.png" alt="filters.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga4c7a67" class="outline-4"&gt;
&lt;h4 id="orga4c7a67"&gt;convert the image into an input Tensor&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orga4c7a67"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gray_img_tensor = torch.from_numpy(gray_img).unsqueeze(0).unsqueeze(1)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orga7ef240" class="outline-4"&gt;
&lt;h4 id="orga7ef240"&gt;get all the layers&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orga7ef240"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;conv_layer, activated_layer, pooled_layer = model(gray_img_tensor)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
visualize the output of the activated conv layer
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;viz_layer(activated_layer)
&lt;/pre&gt;&lt;/div&gt;



&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-max-pooling/activated_layer.png" alt="activated_layer.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org315c4a6" class="outline-2"&gt;
&lt;h2 id="org315c4a6"&gt;Visualize the output of the pooling layer&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org315c4a6"&gt;
&lt;p&gt;
Then, take a look at the output of a pooling layer. The pooling layer takes as input the feature maps pictured above and reduces the dimensionality of those maps, by some pooling factor, by constructing a new, smaller image of only the maximum (brightest) values in a given kernel area.
&lt;/p&gt;

&lt;p&gt;
Take a look at the values on the x, y axes to see how the image has changed size.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;viz_layer(pooled_layer)
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-max-pooling/pooled_layer.png" alt="pooled_layer.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cnn</category><category>max pooling</category><category>visualization</category><guid>https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-max-pooling/</guid><pubDate>Mon, 03 Dec 2018 15:25:07 GMT</pubDate></item><item><title>Visualizing Convolving</title><link>https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-convolving/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-convolving/#org25af0fb"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-convolving/#org7eba73a"&gt;Imports&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-convolving/#org722e254"&gt;The Image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-convolving/#orge1eab2c"&gt;Plot the Image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-convolving/#org4635826"&gt;Define and Visualize the Filters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-convolving/#org8add5d8"&gt;Defining four different filters,&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-convolving/#org53ac575"&gt;Define a convolutional layer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-convolving/#orgfe59f85"&gt;ReLu activation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org25af0fb" class="outline-2"&gt;
&lt;h2 id="org25af0fb"&gt;Introduction&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org25af0fb"&gt;
&lt;p&gt;
This is from &lt;a href="https://github.com/udacity/deep-learning-v2-pytorch.git"&gt;Udacity's Deep Learning Repository&lt;/a&gt; which supports their Deep Learning Nanodegree.
&lt;/p&gt;

&lt;p&gt;
In this notebook, we visualize four filtered outputs (a.k.a. activation maps) of a convolutional layer. 
&lt;/p&gt;

&lt;p&gt;
In this example, &lt;b&gt;we&lt;/b&gt; are defining four filters that are applied to an input image by initializing the &lt;b&gt;&lt;b&gt;weights&lt;/b&gt;&lt;/b&gt; of a convolutional layer, but a trained CNN will learn the values of these weights.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org7eba73a" class="outline-2"&gt;
&lt;h2 id="org7eba73a"&gt;Imports&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org7eba73a"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0c8fd08" class="outline-3"&gt;
&lt;h3 id="org0c8fd08"&gt;PyPi&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0c8fd08"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from dotenv import load_dotenv
import cv2
import matplotlib.pyplot as pyplot
import numpy
import seaborn
import torch
import torch.nn as nn
import torch.nn.functional as F
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orged65d43" class="outline-3"&gt;
&lt;h3 id="orged65d43"&gt;This Project&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orged65d43"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from neurotic.tangles.data_paths import DataPathTwo
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org632bda4" class="outline-3"&gt;
&lt;h3 id="org632bda4"&gt;Set Up Plotting&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org632bda4"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;get_ipython().run_line_magic('matplotlib', 'inline')
seaborn.set(style="whitegrid",
	    rc={"axes.grid": False,
		"font.family": ["sans-serif"],
		"font.sans-serif": ["Latin Modern Sans", "Lato"],
		"figure.figsize": (14, 12)},
	    font_scale=3)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org722e254" class="outline-2"&gt;
&lt;h2 id="org722e254"&gt;The Image&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org722e254"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;load_dotenv()
path = DataPathTwo("udacity_sdc.png", folder_key="CNN")
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2f078e0" class="outline-3"&gt;
&lt;h3 id="org2f078e0"&gt;Load the Image&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2f078e0"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bgr_img = cv2.imread(str(path.from_folder))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org74f7fce" class="outline-3"&gt;
&lt;h3 id="org74f7fce"&gt;Convert It To Grayscale&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org74f7fce"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gray_img = cv2.cvtColor(bgr_img, cv2.COLOR_BGR2GRAY)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org234b637" class="outline-3"&gt;
&lt;h3 id="org234b637"&gt;Normalize By Rescaling the Entries To Lie In [0,1]&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org234b637"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gray_img = gray_img.astype("float32")/255
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge1eab2c" class="outline-2"&gt;
&lt;h2 id="orge1eab2c"&gt;Plot the Image&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge1eab2c"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;image = pyplot.imshow(gray_img, cmap='gray')
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-convolving/grayscale.png" alt="grayscale.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4635826" class="outline-2"&gt;
&lt;h2 id="org4635826"&gt;Define and Visualize the Filters&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org4635826"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;filter_vals = numpy.array([[-1, -1, 1, 1], [-1, -1, 1, 1], [-1, -1, 1, 1], [-1, -1, 1, 1]])

print('Filter shape: ', filter_vals.shape)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Filter shape:  (4, 4)

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8add5d8" class="outline-2"&gt;
&lt;h2 id="org8add5d8"&gt;Defining four different filters,&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8add5d8"&gt;
&lt;p&gt;
All of these are linear combinations of the &lt;code&gt;filter_vals&lt;/code&gt; defined above.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;filter_1 = filter_vals
filter_2 = -filter_1
filter_3 = filter_1.T
filter_4 = -filter_3
filters = numpy.array([filter_1, filter_2, filter_3, filter_4])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Here's what &lt;code&gt;filter_1&lt;/code&gt; has.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print('Filter 1: \n', filter_1)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Filter 1: 
 [[-1 -1  1  1]
 [-1 -1  1  1]
 [-1 -1  1  1]
 [-1 -1  1  1]]

&lt;/pre&gt;
&lt;/div&gt;


&lt;div id="outline-container-orge79d663" class="outline-3"&gt;
&lt;h3 id="orge79d663"&gt;Visualize All Four Filters&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge79d663"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fig = pyplot.figure(figsize=(10, 5))
for i in range(4):
    ax = fig.add_subplot(1, 4, i+1, xticks=[], yticks=[])
    ax.imshow(filters[i], cmap='gray')
    ax.set_title('Filter %s' % str(i+1))
    width, height = filters[i].shape
    for x in range(width):
	for y in range(height):
	    ax.annotate(str(filters[i][x][y]), xy=(y,x),
			horizontalalignment='center',
			verticalalignment='center',
			color='white' if filters[i][x][y]&amp;lt;0 else 'black')
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-convolving/four_filters.png" alt="four_filters.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org53ac575" class="outline-2"&gt;
&lt;h2 id="org53ac575"&gt;Define a convolutional layer&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org53ac575"&gt;
&lt;p&gt;
The various layers that make up any neural network are documented, &lt;a href="http://pytorch.org/docs/stable/nn.html"&gt;here&lt;/a&gt;. For a convolutional neural network, we'll start by defining a:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Convolutional Layer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Initialize a single convolutional layer so that it contains all your created filters. Note that you are not training this network; you are initializing the weights in a convolutional layer so that you can visualize what happens after a forward pass through this network!
&lt;/p&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgdfc3910" class="outline-3"&gt;
&lt;h3 id="orgdfc3910"&gt;&lt;code&gt;__init__&lt;/code&gt; and &lt;code&gt;forward&lt;/code&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgdfc3910"&gt;
&lt;p&gt;
To define a neural network in PyTorch, you define the layers of a model in the &lt;code&gt;__init__&lt;/code&gt; method and define the forward behavior of a network that applyies those initialized layers to an input (&lt;code&gt;x&lt;/code&gt;) in the  &lt;code&gt;forward&lt;/code&gt; method. In PyTorch we convert all inputs into the Tensor datatype, which is similar to a list data type in Python. 
&lt;/p&gt;

&lt;p&gt;
Below is a class called &lt;code&gt;Net&lt;/code&gt; that has a convolutional layer that can contain four 3x3 grayscale filters.
&lt;/p&gt;


&lt;p&gt;
This will be a neural network with a single convolutional layer with four filters.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;class Net(nn.Module):
    """CNN To apply 4 filters

    initializes the weights of the convolutional layer to be the 
    weights of the 4 defined filters

    Args:
     weights: array with the four filters
    """
    def __init__(self, weight):
	super(Net, self).__init__()
	k_height, k_width = weight.shape[2:]
	# assumes there are 4 grayscale filters
	self.conv = nn.Conv2d(1, 4, kernel_size=(k_height, k_width), bias=False)
	self.conv.weight = torch.nn.Parameter(weight)
	return

    def forward(self, x):
	"""calculates the output of a convolutional layer
	pre- and post-activation

	Args:
	 x: the image to apply the convolution to

	Returns:
	 tuple: convolution output, relu output
	"""
	conv_x = self.conv(x)
	activated_x = F.relu(conv_x)

	# returns both layers
	return conv_x, activated_x
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgbba3a0d" class="outline-3"&gt;
&lt;h3 id="orgbba3a0d"&gt;Instantiate the Model and Set the Weights&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgbba3a0d"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;weight = torch.from_numpy(filters).unsqueeze(1).type(torch.FloatTensor)
model = Net(weight)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(model)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Net(
  (conv): Conv2d(1, 4, kernel_size=(4, 4), stride=(1, 1), bias=False)
)

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org94bf668" class="outline-3"&gt;
&lt;h3 id="org94bf668"&gt;Visualize the output of each filter&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org94bf668"&gt;
&lt;p&gt;
First, we'll define a helper function, &lt;code&gt;viz_layer&lt;/code&gt; that takes in a specific layer and number of filters (optional argument), and displays the output of that layer once an image has been passed through.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def viz_layer(layer, n_filters= 4):
    fig = pyplot.figure(figsize=(20, 20))

    for i in range(n_filters):
	ax = fig.add_subplot(1, n_filters, i+1, xticks=[], yticks=[])
	# grab layer outputs
	ax.imshow(numpy.squeeze(layer[0,i].data.numpy()), cmap='gray')
	ax.set_title('Output %s' % str(i+1))
    return
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
Let's look at the output of a convolutional layer, before and after a ReLu activation function is applied. First, here's our original image again.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;image = pyplot.imshow(gray_img, cmap='gray')
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-convolving/gray_2.png" alt="gray_2.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga0c62e5" class="outline-3"&gt;
&lt;h3 id="orga0c62e5"&gt;visualize all filters&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga0c62e5"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fig = pyplot.figure(figsize=(12, 6))
fig.subplots_adjust(left=0, right=1.5, bottom=0.8, top=1, hspace=0.05, wspace=0.05)
for i in range(4):
    ax = fig.add_subplot(1, 4, i+1, xticks=[], yticks=[])
    ax.imshow(filters[i], cmap='gray')
    ax.set_title('Filter %s' % str(i+1))
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-convolving/filtered.png" alt="filtered.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgcb49d55" class="outline-3"&gt;
&lt;h3 id="orgcb49d55"&gt;Convert The Image Into An Input Tensor&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgcb49d55"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gray_img_tensor = torch.from_numpy(gray_img).unsqueeze(0).unsqueeze(1)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3d5d4c2" class="outline-3"&gt;
&lt;h3 id="org3d5d4c2"&gt;Get The Convolutional Layer (Pre and Post Activation)&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org3d5d4c2"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;conv_layer, activated_layer = model(gray_img_tensor)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdb5eea8" class="outline-3"&gt;
&lt;h3 id="orgdb5eea8"&gt;Visualize the Output of a Convolutional Layer&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgdb5eea8"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;viz_layer(conv_layer)
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-convolving/layer_1.png" alt="layer_1.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Sort of gives it a bas-relief look.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfe59f85" class="outline-2"&gt;
&lt;h2 id="orgfe59f85"&gt;ReLu activation&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgfe59f85"&gt;
&lt;p&gt;
In this model, we've used an activation function that scales the output of the convolutional layer. We've chose a ReLu function to do this, and this function simply turns all negative pixel values to 0's (black). See the equation pictured below for input pixel values, &lt;code&gt;x&lt;/code&gt;. 
&lt;/p&gt;

&lt;p&gt;
Visualize the output of an activated conv layer after a ReLu is applied.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;viz_layer(activated_layer)
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-convolving/activated_layer.png" alt="activated_layer.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cnn</category><guid>https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/visualizing-convolving/</guid><pubDate>Mon, 03 Dec 2018 03:23:25 GMT</pubDate></item></channel></rss>