<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>In Too Deep (Posts about nlp)</title><link>https://necromuralist.github.io/In-Too-Deep/</link><description></description><atom:link href="https://necromuralist.github.io/In-Too-Deep/categories/nlp.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2019 &lt;a href="mailto:necromuralist@protonmail.com"&gt;Cloistered Monkey&lt;/a&gt; </copyright><lastBuildDate>Tue, 10 Sep 2019 00:03:33 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>IMDB Reviews Tensorflow Dataset</title><link>https://necromuralist.github.io/In-Too-Deep/posts/keras/imdb-reviews-tensorflow-dataset/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/imdb-reviews-tensorflow-dataset/#org9e58ef8"&gt;Beginning&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/imdb-reviews-tensorflow-dataset/#org0760cc7"&gt;Imports&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/imdb-reviews-tensorflow-dataset/#org9cc75e4"&gt;PyPi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/imdb-reviews-tensorflow-dataset/#org4f54300"&gt;Middle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/imdb-reviews-tensorflow-dataset/#org8e22346"&gt;End&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/imdb-reviews-tensorflow-dataset/#orgcd17ba0"&gt;Raw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9e58ef8" class="outline-2"&gt;
&lt;h2 id="org9e58ef8"&gt;Beginning&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9e58ef8"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org0760cc7" class="outline-3"&gt;
&lt;h3 id="org0760cc7"&gt;Imports&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0760cc7"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9cc75e4" class="outline-4"&gt;
&lt;h4 id="org9cc75e4"&gt;PyPi&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org9cc75e4"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org4f54300" class="outline-2"&gt;
&lt;h2 id="org4f54300"&gt;Middle&lt;/h2&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8e22346" class="outline-2"&gt;
&lt;h2 id="org8e22346"&gt;End&lt;/h2&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgcd17ba0" class="outline-2"&gt;
&lt;h2 id="orgcd17ba0"&gt;Raw&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgcd17ba0"&gt;
&lt;div class="org-center"&gt;
&lt;p&gt;
#!/usr/bin/env python
&lt;/p&gt;


&lt;p&gt;
from &lt;span class="underline"&gt;&lt;span class="underline"&gt;future&lt;/span&gt;&lt;/span&gt; import absolute_import, division, print_function, unicode_literals
&lt;/p&gt;


&lt;p&gt;
import tensorflow_datasets as tfds
import tensorflow as tf
print(tf.__version__)
&lt;/p&gt;


&lt;p&gt;
#!pip install tensorflow==2.0.0-beta0
&lt;/p&gt;


&lt;p&gt;
import tensorflow_datasets as tfds
import tensorflow as tf
print(tf.__version__)
&lt;/p&gt;


&lt;p&gt;
dataset, info = tfds.load('imdb_reviews/subwords8k', with_info=True, as_supervised=True)
train_dataset, test_dataset = dataset['train'], dataset['test']
&lt;/p&gt;


&lt;p&gt;
tokenizer = info.features['text'].encoder
&lt;/p&gt;


&lt;p&gt;
BUFFER_SIZE = 10000
BATCH_SIZE = 64
&lt;/p&gt;

&lt;p&gt;
train_dataset = train_dataset.shuffle(BUFFER_SIZE)
train_dataset = train_dataset.padded_batch(BATCH_SIZE, train_dataset.output_shapes)
test_dataset = test_dataset.padded_batch(BATCH_SIZE, test_dataset.output_shapes)
&lt;/p&gt;


&lt;p&gt;
model = tf.keras.Sequential([
    tf.keras.layers.Embedding(tokenizer.vocab_size, 64),
    tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(64)),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(1, activation='sigmoid')
])
&lt;/p&gt;


&lt;p&gt;
model.summary()
&lt;/p&gt;


&lt;p&gt;
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])
&lt;/p&gt;


&lt;p&gt;
NUM_EPOCHS = 10
history = model.fit(train_dataset, epochs=NUM_EPOCHS, validation_data=test_dataset)
&lt;/p&gt;


&lt;p&gt;
import matplotlib.pyplot as plt
&lt;/p&gt;


&lt;p&gt;
def plot_graphs(history, string):
  plt.plot(history.history[string])
  plt.plot(history.history['val_'+string])
  plt.xlabel("Epochs")
  plt.ylabel(string)
  plt.legend([string, 'val_'+string])
  plt.show()
&lt;/p&gt;


&lt;p&gt;
plot_graphs(history, 'accuracy')
&lt;/p&gt;


&lt;p&gt;
plot_graphs(history, 'loss')
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>nlp</category><category>sentiment</category><category>tensorflow</category><guid>https://necromuralist.github.io/In-Too-Deep/posts/keras/imdb-reviews-tensorflow-dataset/</guid><pubDate>Mon, 09 Sep 2019 23:24:46 GMT</pubDate></item><item><title>BBC News Classification</title><link>https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/#org38ee150"&gt;Beginning&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/#orgcee04a6"&gt;Imports&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/#orge627f09"&gt;Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/#org0f97fe9"&gt;PyPi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/#org8d1eee4"&gt;Graeae&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/#orge25b1e8"&gt;Setup&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/#org18971fd"&gt;The Timer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/#org6bdab2d"&gt;The Environment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/#org857db46"&gt;Spacy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/#org6c8b6e8"&gt;Plotting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/#org9d3fb8d"&gt;Middle&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/#org2de0b99"&gt;Load the Datasets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/#org1abc976"&gt;The Tokenizers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/#orgf89f739"&gt;Making the Sequences&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/#orgbc6c887"&gt;Make training and testing sets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/#orgcd744cd"&gt;The Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/#orgde3f2a1"&gt;Plotting the Performance&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/#org8386b26"&gt;End&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org38ee150" class="outline-2"&gt;
&lt;h2 id="org38ee150"&gt;Beginning&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org38ee150"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgcee04a6" class="outline-3"&gt;
&lt;h3 id="orgcee04a6"&gt;Imports&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgcee04a6"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge627f09" class="outline-4"&gt;
&lt;h4 id="orge627f09"&gt;Python&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orge627f09"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from functools import partial
from pathlib import Path
import csv
import random
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0f97fe9" class="outline-4"&gt;
&lt;h4 id="org0f97fe9"&gt;PyPi&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org0f97fe9"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from sklearn.model_selection import train_test_split
from tensorflow.keras import layers
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
import hvplot.pandas
import numpy
import pandas
import spacy
import tensorflow
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8d1eee4" class="outline-4"&gt;
&lt;h4 id="org8d1eee4"&gt;Graeae&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org8d1eee4"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from graeae import EmbedHoloviews, SubPathLoader, Timer
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge25b1e8" class="outline-3"&gt;
&lt;h3 id="orge25b1e8"&gt;Setup&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orge25b1e8"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org18971fd" class="outline-4"&gt;
&lt;h4 id="org18971fd"&gt;The Timer&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org18971fd"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;TIMER = Timer()
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org6bdab2d" class="outline-4"&gt;
&lt;h4 id="org6bdab2d"&gt;The Environment&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org6bdab2d"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ENVIRONMENT = SubPathLoader('DATASETS')
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org857db46" class="outline-4"&gt;
&lt;h4 id="org857db46"&gt;Spacy&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org857db46"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;spacy.prefer_gpu()
nlp = spacy.load("en_core_web_lg")
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org6c8b6e8" class="outline-4"&gt;
&lt;h4 id="org6c8b6e8"&gt;Plotting&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org6c8b6e8"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;SLUG = "bbc-news-classification"
Embed = partial(EmbedHoloviews, folder_path=f"../../files/posts/keras/{SLUG}")
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9d3fb8d" class="outline-2"&gt;
&lt;h2 id="org9d3fb8d"&gt;Middle&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9d3fb8d"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2de0b99" class="outline-3"&gt;
&lt;h3 id="org2de0b99"&gt;Load the Datasets&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2de0b99"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;path = Path(ENVIRONMENT["BBC_NEWS"]).expanduser()

texts = []
labels = []
with TIMER:
    with path.open() as csvfile:
	lines = csv.DictReader(csvfile)
	for line in lines:
	    labels.append(line["category"])
	    texts.append(nlp(line["text"]))
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
WARNING: Logging before flag parsing goes to stderr.
I0908 13:32:14.804769 139839933974336 environment.py:35] Environment Path: /home/athena/.env
I0908 13:32:14.806000 139839933974336 environment.py:90] Environment Path: /home/athena/.config/datasets/env
2019-09-08 13:32:14,806 graeae.timers.timer start: Started: 2019-09-08 13:32:14.806861
I0908 13:32:14.806965 139839933974336 timer.py:70] Started: 2019-09-08 13:32:14.806861
2019-09-08 13:33:37,430 graeae.timers.timer end: Ended: 2019-09-08 13:33:37.430228
I0908 13:33:37.430259 139839933974336 timer.py:77] Ended: 2019-09-08 13:33:37.430228
2019-09-08 13:33:37,431 graeae.timers.timer end: Elapsed: 0:01:22.623367
I0908 13:33:37.431128 139839933974336 timer.py:78] Elapsed: 0:01:22.623367

&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(texts[random.randrange(len(texts))])
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
candidate resigns over bnp link a prospective candidate for the uk independence party (ukip) has resigned after admitting a  brief attachment  to the british national party(bnp).  nicholas betts-green  who had been selected to fight the suffolk coastal seat  quit after reports in a newspaper that he attended a bnp meeting. the former teacher confirmed he had attended the meeting but said that was the only contact he had with the group. mr betts-green resigned after being questioned by the party s leadership. a ukip spokesman said mr betts-green s resignation followed disclosures in the east anglian daily times last month about his attendance at a bnp meeting.  he did once attend a bnp meeting. he did not like what he saw and heard and will take no further part of it   the spokesman added. a meeting of suffolk coastal ukip members is due to be held next week to discuss a replacement. mr betts-green  of woodbridge  suffolk  has also resigned as ukip s branch chairman.

&lt;/pre&gt;

&lt;p&gt;
So, it looks like the text has been lower-cased but there's still punctuation and extra white-space.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(f"Rows: {len(labels):,}")
print(f"Unique Labels: {len(set(labels)):,}")
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Rows: 2,225
Unique Labels: 5

&lt;/pre&gt;

&lt;p&gt;
Since there's only five maybe we should plot it.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;labels_frame = pandas.DataFrame({"label": labels})
counts = labels_frame.label.value_counts().reset_index().rename(
    columns={"index": "Category", "label": "Articles"})
plot = counts.hvplot.bar("Category", "Articles").opts(
    title="Count of BBC News Articles by Category",
    height=800, width=1000)
Embed(plot=plot, file_name="bbc_category_counts")()
&lt;/pre&gt;&lt;/div&gt;

&lt;object type="text/html" data="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/bbc_category_counts.html" style="width:100%" height="800"&gt;
  &lt;p&gt;Figure Missing&lt;/p&gt;
&lt;/object&gt;

&lt;p&gt;
It looks like the categories are somewhat unevenly distributed. Now to normalize the tokens.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;with TIMER:
    cleaned = [[token.lemma_ for token in text if not any((token.is_stop, token.is_space, token.is_punct))]
	       for text in texts]
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
2019-09-08 13:33:40,257 graeae.timers.timer start: Started: 2019-09-08 13:33:40.257908
I0908 13:33:40.257930 139839933974336 timer.py:70] Started: 2019-09-08 13:33:40.257908
2019-09-08 13:33:40,810 graeae.timers.timer end: Ended: 2019-09-08 13:33:40.810135
I0908 13:33:40.810176 139839933974336 timer.py:77] Ended: 2019-09-08 13:33:40.810135
2019-09-08 13:33:40,811 graeae.timers.timer end: Elapsed: 0:00:00.552227
I0908 13:33:40.811067 139839933974336 timer.py:78] Elapsed: 0:00:00.552227

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1abc976" class="outline-3"&gt;
&lt;h3 id="org1abc976"&gt;The Tokenizers&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1abc976"&gt;
&lt;p&gt;
Even though I've already tokenized the texts, we need to eventually one-hot-encode them so I'll use the &lt;a href="https://www.tensorflow.org/api_docs/python/tf/keras/preprocessing/text/Tokenizer"&gt;tensorflow keras Tokenizer&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;Note:&lt;/b&gt; The labels tokenizer doesn't get the out-of-vocabulary token, only the text-tokenizer does.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tokenizer = Tokenizer(num_words=1000, oov_token="&amp;lt;OOV&amp;gt;")
labels_tokenizer = Tokenizer()
labels_tokenizer.fit_on_texts(labels)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
The &lt;code&gt;num_words&lt;/code&gt; is the total amount of words that will be kept in the word index - I don't know why a thousand, I just found that in the "answer" notebook. The &lt;code&gt;oov_token&lt;/code&gt; is what's used when a word is encountered outside of the words we're building into our word-index (&lt;i&gt;Out Of Vocabulary&lt;/i&gt;). The next step is to create the word-index by fitting the tokenizer to the text.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;with TIMER:
    tokenizer.fit_on_texts(cleaned)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
2019-09-08 14:59:30,671 graeae.timers.timer start: Started: 2019-09-08 14:59:30.671536
I0908 14:59:30.671563 139839933974336 timer.py:70] Started: 2019-09-08 14:59:30.671536
2019-09-08 14:59:30,862 graeae.timers.timer end: Ended: 2019-09-08 14:59:30.862483
I0908 14:59:30.862523 139839933974336 timer.py:77] Ended: 2019-09-08 14:59:30.862483
2019-09-08 14:59:30,863 graeae.timers.timer end: Elapsed: 0:00:00.190947
I0908 14:59:30.863504 139839933974336 timer.py:78] Elapsed: 0:00:00.190947

&lt;/pre&gt;

&lt;p&gt;
The tokenizer now has a dictionary named &lt;code&gt;word_index&lt;/code&gt; that holds the words:index pairs for all the tokens found (it only uses the &lt;code&gt;num_words&lt;/code&gt; when you call tokenizer's methods according to &lt;a href="https://stackoverflow.com/questions/46202519/keras-tokenizer-num-words-doesnt-seem-to-work"&gt;Stack Overflow&lt;/a&gt;).
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(f"{len(tokenizer.word_index):,}")
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
24,339

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf89f739" class="outline-3"&gt;
&lt;h3 id="orgf89f739"&gt;Making the Sequences&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf89f739"&gt;
&lt;p&gt;
I've trained the Tokenizer so that it has a word-index, but now we have to one hot encode our texts and pad them so they're all the same length.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MAX_LENGTH = 120
sequences = tokenizer.texts_to_sequences(cleaned)
padded = pad_sequences(sequences, padding="post", maxlen=MAX_LENGTH)
labels_sequenced = labels_tokenizer.texts_to_sequences(labels)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbc6c887" class="outline-3"&gt;
&lt;h3 id="orgbc6c887"&gt;Make training and testing sets&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgbc6c887"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;TESTING = 0.2
x_train, x_test, y_train, y_test = train_test_split(
    padded, labels_sequenced,
    test_size=TESTING)
x_train, x_validation, y_train, y_validation = train_test_split(
    x_train, y_train, test_size=TESTING)

y_train = numpy.array(y_train)
y_test = numpy.array(y_test)
y_validation = numpy.array(y_validation)

print(f"Training: {x_train.shape}")
print(f"Validation: {x_validation.shape}")
print(f"Testing: {x_test.shape}")
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Training: (1424, 120)
Validation: (356, 120)
Testing: (445, 120)

&lt;/pre&gt;

&lt;p&gt;
&lt;b&gt;Note:&lt;/b&gt; I originally forgot to pass the &lt;code&gt;TESTING&lt;/code&gt; variable with the keyword &lt;code&gt;test_size&lt;/code&gt; and got an error that I couldn't use a Singleton array - don't forget the keywords when you pass in anything other than the data to &lt;code&gt;train_test_split&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgcd744cd" class="outline-3"&gt;
&lt;h3 id="orgcd744cd"&gt;The Model&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgcd744cd"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vocabulary_size = 1000
embedding_dimension = 16
max_length=120

model = tensorflow.keras.Sequential([
    layers.Embedding(vocabulary_size, embedding_dimension,
		     input_length=max_length),
    layers.GlobalAveragePooling1D(),
    layers.Dense(24, activation="relu"),
    layers.Dense(6, activation="softmax"),
])
model.compile(loss='sparse_categorical_crossentropy',optimizer='adam',metrics=['accuracy'])
print(model.summary())
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Model: "sequential_1"
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
embedding_1 (Embedding)      (None, 120, 16)           16000     
_________________________________________________________________
global_average_pooling1d_1 ( (None, 16)                0         
_________________________________________________________________
dense_2 (Dense)              (None, 24)                408       
_________________________________________________________________
dense_3 (Dense)              (None, 6)                 150       
=================================================================
Total params: 16,558
Trainable params: 16,558
Non-trainable params: 0
_________________________________________________________________
None
&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model.fit(x_train, y_train, epochs=30,
	  validation_data=(x_validation, y_validation), verbose=2)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Train on 1424 samples, validate on 356 samples
Epoch 1/30
1424/1424 - 0s - loss: 1.7623 - accuracy: 0.2879 - val_loss: 1.7257 - val_accuracy: 0.5000
Epoch 2/30
1424/1424 - 0s - loss: 1.6871 - accuracy: 0.5190 - val_loss: 1.6332 - val_accuracy: 0.5281
Epoch 3/30
1424/1424 - 0s - loss: 1.5814 - accuracy: 0.4782 - val_loss: 1.5118 - val_accuracy: 0.4944
Epoch 4/30
1424/1424 - 0s - loss: 1.4417 - accuracy: 0.4677 - val_loss: 1.3543 - val_accuracy: 0.5365
Epoch 5/30
1424/1424 - 0s - loss: 1.2706 - accuracy: 0.5934 - val_loss: 1.1850 - val_accuracy: 0.7022
Epoch 6/30
1424/1424 - 0s - loss: 1.1075 - accuracy: 0.6749 - val_loss: 1.0387 - val_accuracy: 0.8006
Epoch 7/30
1424/1424 - 0s - loss: 0.9606 - accuracy: 0.8483 - val_loss: 0.9081 - val_accuracy: 0.8567
Epoch 8/30
1424/1424 - 0s - loss: 0.8244 - accuracy: 0.8869 - val_loss: 0.7893 - val_accuracy: 0.8848
Epoch 9/30
1424/1424 - 0s - loss: 0.6963 - accuracy: 0.9164 - val_loss: 0.6747 - val_accuracy: 0.8961
Epoch 10/30
1424/1424 - 0s - loss: 0.5815 - accuracy: 0.9228 - val_loss: 0.5767 - val_accuracy: 0.9185
Epoch 11/30
1424/1424 - 0s - loss: 0.4831 - accuracy: 0.9375 - val_loss: 0.4890 - val_accuracy: 0.9270
Epoch 12/30
1424/1424 - 0s - loss: 0.3991 - accuracy: 0.9473 - val_loss: 0.4195 - val_accuracy: 0.9326
Epoch 13/30
1424/1424 - 0s - loss: 0.3321 - accuracy: 0.9508 - val_loss: 0.3669 - val_accuracy: 0.9438
Epoch 14/30
1424/1424 - 0s - loss: 0.2800 - accuracy: 0.9572 - val_loss: 0.3268 - val_accuracy: 0.9494
Epoch 15/30
1424/1424 - 0s - loss: 0.2385 - accuracy: 0.9656 - val_loss: 0.2936 - val_accuracy: 0.9438
Epoch 16/30
1424/1424 - 0s - loss: 0.2053 - accuracy: 0.9740 - val_loss: 0.2693 - val_accuracy: 0.9466
Epoch 17/30
1424/1424 - 0s - loss: 0.1775 - accuracy: 0.9761 - val_loss: 0.2501 - val_accuracy: 0.9466
Epoch 18/30
1424/1424 - 0s - loss: 0.1557 - accuracy: 0.9789 - val_loss: 0.2332 - val_accuracy: 0.9494
Epoch 19/30
1424/1424 - 0s - loss: 0.1362 - accuracy: 0.9831 - val_loss: 0.2189 - val_accuracy: 0.9522
Epoch 20/30
1424/1424 - 0s - loss: 0.1209 - accuracy: 0.9853 - val_loss: 0.2082 - val_accuracy: 0.9551
Epoch 21/30
1424/1424 - 0s - loss: 0.1070 - accuracy: 0.9860 - val_loss: 0.1979 - val_accuracy: 0.9579
Epoch 22/30
1424/1424 - 0s - loss: 0.0952 - accuracy: 0.9888 - val_loss: 0.1897 - val_accuracy: 0.9551
Epoch 23/30
1424/1424 - 0s - loss: 0.0854 - accuracy: 0.9902 - val_loss: 0.1815 - val_accuracy: 0.9579
Epoch 24/30
1424/1424 - 0s - loss: 0.0765 - accuracy: 0.9916 - val_loss: 0.1761 - val_accuracy: 0.9522
Epoch 25/30
1424/1424 - 0s - loss: 0.0689 - accuracy: 0.9930 - val_loss: 0.1729 - val_accuracy: 0.9579
Epoch 26/30
1424/1424 - 0s - loss: 0.0618 - accuracy: 0.9951 - val_loss: 0.1680 - val_accuracy: 0.9551
Epoch 27/30
1424/1424 - 0s - loss: 0.0559 - accuracy: 0.9958 - val_loss: 0.1633 - val_accuracy: 0.9551
Epoch 28/30
1424/1424 - 0s - loss: 0.0505 - accuracy: 0.9958 - val_loss: 0.1594 - val_accuracy: 0.9579
Epoch 29/30
1424/1424 - 0s - loss: 0.0457 - accuracy: 0.9965 - val_loss: 0.1559 - val_accuracy: 0.9522
Epoch 30/30
1424/1424 - 0s - loss: 0.0416 - accuracy: 0.9972 - val_loss: 0.1544 - val_accuracy: 0.9551
&lt;/pre&gt;

&lt;p&gt;
It seems to get good suprisingly fast - it might be overfitting toward the end.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;loss, accuracy =model.evaluate(x_test, y_test, verbose=0)
print(f"Loss: {loss: .2f} Accuracy: {accuracy:.2f}")
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Loss:  0.16 Accuracy: 0.95

&lt;/pre&gt;

&lt;p&gt;
It does pretty well, even on the test set.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgde3f2a1" class="outline-3"&gt;
&lt;h3 id="orgde3f2a1"&gt;Plotting the Performance&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgde3f2a1"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;data = pandas.DataFrame(model.history.history)
plot = data.hvplot().opts(title="Training Performance", width=1000, height=800)
Embed(plot=plot, file_name="model_performance")()
&lt;/pre&gt;&lt;/div&gt;

&lt;object type="text/html" data="https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/model_performance.html" style="width:100%" height="800"&gt;
  &lt;p&gt;Figure Missing&lt;/p&gt;
&lt;/object&gt;

&lt;p&gt;
Unlike with the image classifications, the validation performance never quite matches the training performance (although it's quite good), probably because we aren't doing any kind of augmentation the way you tend to do with images.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org8386b26" class="outline-2"&gt;
&lt;h2 id="org8386b26"&gt;End&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8386b26"&gt;
&lt;p&gt;
Okay, so we seem to have a decent model, but is that really the end-game? No, we want to be able to predict what classification a new input should get.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;index_to_label = {value:key for (key, value) in labels_tokenizer.word_index.items()}

def category(text: str) -&amp;gt; None:
    """Categorizes the text

    Args:
     text: text to categorize
    """
    text = tokenizer.texts_to_sequences([text])
    predictions = model.predict(pad_sequences(text, maxlen=MAX_LENGTH))
    print(f"Predicted Category: {index_to_label[predictions.argmax()]}")
    return
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;text = "crickets are nutritious and delicious but make for such a silly game"
category(text)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Predicted Category: sport

&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;text = "i like butts that are big and round, something something like a xxx throw down, and so does the house of parliament"
category(text)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Predicted Category: sport

&lt;/pre&gt;

&lt;p&gt;
It kind of looks like it's biased toward sports.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;text = "tv future hand viewer home theatre"
category(text)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Predicted Category: sport

&lt;/pre&gt;

&lt;p&gt;
Something isn't right here.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>nlp</category><guid>https://necromuralist.github.io/In-Too-Deep/posts/keras/bbc-news-classification/</guid><pubDate>Mon, 26 Aug 2019 22:28:56 GMT</pubDate></item><item><title>Cleaning the BBC News Archive</title><link>https://necromuralist.github.io/In-Too-Deep/posts/keras/cleaning-the-bbc-news-archive/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/cleaning-the-bbc-news-archive/#orgdbc39c1"&gt;Beginning&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/cleaning-the-bbc-news-archive/#org5778562"&gt;Imports&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/cleaning-the-bbc-news-archive/#orgdfcdab3"&gt;Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/cleaning-the-bbc-news-archive/#org3771026"&gt;PyPi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/cleaning-the-bbc-news-archive/#org12f289a"&gt;Graeae&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/cleaning-the-bbc-news-archive/#org73135c4"&gt;Set Up&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/cleaning-the-bbc-news-archive/#orgc4ce931"&gt;The Environment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/cleaning-the-bbc-news-archive/#org045df1b"&gt;The Timer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/cleaning-the-bbc-news-archive/#orga1c4c4e"&gt;Middle&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/cleaning-the-bbc-news-archive/#org2095082"&gt;The DataSet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/cleaning-the-bbc-news-archive/#orgc26494e"&gt;The Tokenizer&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/cleaning-the-bbc-news-archive/#org720e402"&gt;Convert the Texts To Sequences&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/cleaning-the-bbc-news-archive/#org3c41d73"&gt;End&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/cleaning-the-bbc-news-archive/#orgaede1f2"&gt;Sources&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/keras/cleaning-the-bbc-news-archive/#orgd6a2143"&gt;The Original Dataset&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgdbc39c1" class="outline-2"&gt;
&lt;h2 id="orgdbc39c1"&gt;Beginning&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdbc39c1"&gt;
&lt;p&gt;
This is an initial look at cleaning up &lt;a href="http://mlg.ucd.ie/datasets/bbc.html"&gt;a text dataset&lt;/a&gt; from the BBC News archives. Although the exercise sites this as the source the dataset provided doesn't look like the actual raw dataset which is broken up into folders that classify the contents and each news item is in a separate file. Instead we're starting with a &lt;a href="https://storage.googleapis.com/laurencemoroney-blog.appspot.com/bbc-text.csv"&gt;partially pre-processed&lt;/a&gt; CSV that has been lower-cased and the classification is given as the first column in the dataset.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5778562" class="outline-3"&gt;
&lt;h3 id="org5778562"&gt;Imports&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5778562"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgdfcdab3" class="outline-4"&gt;
&lt;h4 id="orgdfcdab3"&gt;Python&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgdfcdab3"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from pathlib import Path
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3771026" class="outline-4"&gt;
&lt;h4 id="org3771026"&gt;PyPi&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org3771026"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from nltk.corpus import stopwords
from sklearn.feature_extraction.text import CountVectorizer
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
import pandas
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org12f289a" class="outline-4"&gt;
&lt;h4 id="org12f289a"&gt;Graeae&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org12f289a"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from graeae import SubPathLoader, Timer
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org73135c4" class="outline-3"&gt;
&lt;h3 id="org73135c4"&gt;Set Up&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org73135c4"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc4ce931" class="outline-4"&gt;
&lt;h4 id="orgc4ce931"&gt;The Environment&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgc4ce931"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ENVIRONMENT = SubPathLoader("DATASETS")
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org045df1b" class="outline-4"&gt;
&lt;h4 id="org045df1b"&gt;The Timer&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org045df1b"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;TIMER = Timer()
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga1c4c4e" class="outline-2"&gt;
&lt;h2 id="orga1c4c4e"&gt;Middle&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orga1c4c4e"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org2095082" class="outline-3"&gt;
&lt;h3 id="org2095082"&gt;The DataSet&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org2095082"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bbc_path = Path(ENVIRONMENT["BBC_NEWS"]).expanduser()
with TIMER:
    data = pandas.read_csv(bbc_path/"bbc-text.csv")
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
2019-08-25 18:51:38,411 graeae.timers.timer start: Started: 2019-08-25 18:51:38.411196
2019-08-25 18:51:38,658 graeae.timers.timer end: Ended: 2019-08-25 18:51:38.658181
2019-08-25 18:51:38,658 graeae.timers.timer end: Elapsed: 0:00:00.246985

&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(data.shape)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
(2225, 2)

&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(data.sample().iloc[0])
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
category                                                sport
text        bell set for england debut bath prop duncan be...
Name: 2134, dtype: object

&lt;/pre&gt;

&lt;p&gt;
So we have two columns - &lt;code&gt;category&lt;/code&gt; and &lt;code&gt;text&lt;/code&gt;, text being the one we have to clean up.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(data.text.dtype)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
object

&lt;/pre&gt;

&lt;p&gt;
That's not such an informative answer, but I checked and each row of text is a single string.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc26494e" class="outline-3"&gt;
&lt;h3 id="orgc26494e"&gt;The Tokenizer&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgc26494e"&gt;
&lt;p&gt;
The &lt;a href="https://www.tensorflow.org/api_docs/python/tf/keras/preprocessing/text/Tokenizer"&gt;Keras Tokenizer&lt;/a&gt; tokenizes the text for us as well as removing the punctuation, lower-casing the text, and some other things. We're also going to use a Out-of-Vocabulary token of "&amp;lt;OOV&amp;gt;" to identify words that are outside of the vocabulary when converting new texts to sequences.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tokenizer = Tokenizer(oov_token="&amp;lt;OOV&amp;gt;", num_words=100)
tokenizer.fit_on_texts(data.text)
word_index = tokenizer.word_index
print(len(word_index))
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
29727

&lt;/pre&gt;

&lt;p&gt;
The word-index is a dict that maps words found in the documents to counts.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org720e402" class="outline-4"&gt;
&lt;h4 id="org720e402"&gt;Convert the Texts To Sequences&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org720e402"&gt;
&lt;p&gt;
We're going to convert each of our texts to a sequence of numbers representing the words in them (one-hot-encoding). The &lt;code&gt;pad_sequences&lt;/code&gt; function adds zeros to the end of sequences that are shorter than the longest one so that they are all the same size.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sequences = tokenizer.texts_to_sequences(data.text)
padded = pad_sequences(sequences, padding="post")
print(padded[0])
print(padded.shape)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
[1 1 7 ... 0 0 0]
(2225, 4491)

&lt;/pre&gt;

&lt;p&gt;
Strangely there doesn't appear to be a good way to use stopwords. Maybe sklearn is more appropriate here.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vectorizer = CountVectorizer(stop_words=stopwords.words("english"),
			     lowercase=True, min_df=3,
			     max_df=0.9, max_features=5000)
vectors = vectorizer.fit_transform(data.text)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3c41d73" class="outline-2"&gt;
&lt;h2 id="org3c41d73"&gt;End&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3c41d73"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgaede1f2" class="outline-3"&gt;
&lt;h3 id="orgaede1f2"&gt;Sources&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgaede1f2"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd6a2143" class="outline-4"&gt;
&lt;h4 id="orgd6a2143"&gt;The Original Dataset&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgd6a2143"&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;D. Greene and P. Cunningham. "Practical Solutions to the Problem of Diagonal Dominance in Kernel Document Clustering", Proc. ICML 2006. [PDF] [BibTeX].&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cleaning</category><category>nlp</category><guid>https://necromuralist.github.io/In-Too-Deep/posts/keras/cleaning-the-bbc-news-archive/</guid><pubDate>Mon, 26 Aug 2019 00:14:54 GMT</pubDate></item></channel></rss>