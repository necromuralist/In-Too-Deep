<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Neurotic Networking (Posts about Style Transfer)</title><link>https://necromuralist.github.io/Neurotic-Networking/</link><description></description><atom:link href="https://necromuralist.github.io/Neurotic-Networking/categories/cat_style-transfer.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2020 &lt;a href="mailto:necromuralist@protonmail.com"&gt;Cloistered Monkey&lt;/a&gt; </copyright><lastBuildDate>Tue, 18 Aug 2020 13:39:45 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Style Transfer</title><link>https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/#org3d34310"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/#orge412597"&gt;Set Up&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/#org1d9aff3"&gt;The VGG 19 Network&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/#org7a3495e"&gt;Load in Content and Style Images&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/#org710a5b8"&gt;VGG19 Layers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/#org8bed676"&gt;Content and Style Features&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/#org0e02167"&gt;Gram Matrix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/#org550a59e"&gt;Putting it all Together&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/#org4b0b344"&gt;Loss and Weights&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/#org1768a49"&gt;Updating the Target &amp;amp; Calculating Losses&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/#orgeffab7c"&gt;Content Loss&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/#org51396cc"&gt;Style Loss&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/#orgbb22213"&gt;Total Loss&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/#orgcfdb9af"&gt;Display the Target Image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/#org1075fcf"&gt;A Holhwein Transfer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3d34310" class="outline-2"&gt;
&lt;h2 id="org3d34310"&gt;Introduction&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3d34310"&gt;
&lt;p&gt;
In this notebook, we’ll &lt;b&gt;recreate&lt;/b&gt; a style transfer method that is outlined in the paper, &lt;a href="https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Gatys_Image_Style_Transfer_CVPR_2016_paper.pdf"&gt;Image Style Transfer Using Convolutional Neural Networks, by Gatys&lt;/a&gt; in PyTorch.
&lt;/p&gt;

&lt;p&gt;
In this paper, style transfer uses the features found in the 19-layer VGG Network, which is comprised of a series of convolutional and pooling layers, and a few fully-connected layers. In the image below, the convolutional layers are named by stack and their order in the stack. Conv_1_1 is the first convolutional layer that an image is passed through, in the first stack. Conv_2_1 is the first convolutional layer in the &lt;b&gt;second&lt;/b&gt; stack. The deepest convolutional layer in the network is conv_5_4.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org26c19ac" class="outline-3"&gt;
&lt;h3 id="org26c19ac"&gt;Separating Style and Content&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org26c19ac"&gt;
&lt;p&gt;
Style transfer relies on separating the content and style of an image. Given one content image and one style image, we aim to create a new, &lt;i&gt;target&lt;/i&gt; image which should contain our desired content and style components:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;objects and their arrangement are similar to that of the &lt;b&gt;&lt;b&gt;content image&lt;/b&gt;&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;style, colors, and textures are similar to that of the &lt;b&gt;&lt;b&gt;style image&lt;/b&gt;&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
In this notebook, we'll use a pre-trained VGG19 Net to extract content or style features from a passed in image. We'll then formalize the idea of content and style &lt;i&gt;losses&lt;/i&gt; and use those to iteratively update our target image until we get a result that we want. You are encouraged to use a style and content image of your own and share your work on Twitter with @udacity; we'd love to see what you come up with!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orge412597" class="outline-2"&gt;
&lt;h2 id="orge412597"&gt;Set Up&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge412597"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org6e20408" class="outline-3"&gt;
&lt;h3 id="org6e20408"&gt;Imports&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org6e20408"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org66aa75c" class="outline-4"&gt;
&lt;h4 id="org66aa75c"&gt;Python Standard Library&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org66aa75c"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from datetime import datetime
import pathlib
from typing import Union
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc367e8e" class="outline-4"&gt;
&lt;h4 id="orgc367e8e"&gt;From PyPi&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgc367e8e"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;start = datetime.now()
from dotenv import load_dotenv
from PIL import Image
import matplotlib.pyplot as pyplot
import numpy
import seaborn
import torch
import torch.optim as optim
import torch.nn.functional as F
from torchvision import transforms, models
print("Elapsed: {}".format(datetime.now() - start))
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Elapsed: 0:00:03.711236

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4f48515" class="outline-4"&gt;
&lt;h4 id="org4f48515"&gt;This Project&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org4f48515"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from neurotic.tangles.data_paths import DataPathTwo
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgf8992b9" class="outline-3"&gt;
&lt;h3 id="orgf8992b9"&gt;Plotting&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf8992b9"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;get_ipython().run_line_magic('matplotlib', 'inline')
get_ipython().run_line_magic('config', "InlineBackend.figure_format = 'retina'")
seaborn.set(style="whitegrid",
	    rc={"axes.grid": False,
		"font.family": ["sans-serif"],
		"font.sans-serif": ["Open Sans", "Latin Modern Sans", "Lato"],
		"font.size": 12,
		"xtick.labelsize": 10,
		"ytick.labelsize": 10,
		"axes.titlesize": 12,
		"figure.figsize": (8, 6),
	    },
	    font_scale=3)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc57950b" class="outline-3"&gt;
&lt;h3 id="orgc57950b"&gt;Typing&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgc57950b"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;PathType = Union[pathlib.Path, str]
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1d9aff3" class="outline-2"&gt;
&lt;h2 id="org1d9aff3"&gt;The VGG 19 Network&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1d9aff3"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org5ce8f54" class="outline-3"&gt;
&lt;h3 id="org5ce8f54"&gt;Load in VGG19 (features)&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5ce8f54"&gt;
&lt;p&gt;
VGG19 is split into two portions:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;&lt;code&gt;vgg19.features&lt;/code&gt;, which are all the convolutional and pooling layers&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vgg19.classifier&lt;/code&gt;, which are the three linear, classifier layers at the end&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
We only need the &lt;code&gt;features&lt;/code&gt; portion, which we're going to load in and "freeze" the weights of, below.
&lt;/p&gt;

&lt;p&gt;
Get the "features" portion of VGG19 (we will not need the "classifier" portion).
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;start = datetime.now()
vgg = models.vgg19(pretrained=True).features
print("Elapsed: {}".format(datetime.now() - start))
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Elapsed: 0:00:03.197737

&lt;/pre&gt;

&lt;p&gt;
Freeze all VGG parameters since we're only optimizing the target image.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for param in vgg.parameters():
    param.requires_grad_(False)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
move the model to GPU, if available
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;start = datetime.now()
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
vgg.to(device)
print("Using: {}".format(device))
print("Elapsed: {}".format(datetime.now() - start))
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Using: cuda
Elapsed: 0:00:04.951571

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org7a3495e" class="outline-2"&gt;
&lt;h2 id="org7a3495e"&gt;Load in Content and Style Images&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org7a3495e"&gt;
&lt;p&gt;
You can load in any images you want! Below, we've provided a helper function for loading in any type and size of image. The &lt;code&gt;load_image&lt;/code&gt; function also converts images to normalized Tensors.
&lt;/p&gt;

&lt;p&gt;
Additionally, it will be easier to have smaller images and to squish the content and style images so that they are of the same size.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def load_image(img_path: PathType, max_size: int=400, shape=None):
    ''' Load in and transform an image, making sure the image
       is &amp;lt;= max_size pixels in the x-y dims.'''

    image = Image.open(img_path).convert('RGB')

    # large images will slow down processing
    if max(image.size) &amp;gt; max_size:
	size = max_size
    else:
	size = max(image.size)

    if shape is not None:
	size = shape

    in_transform = transforms.Compose([
			transforms.Resize(size),
			transforms.ToTensor(),
			transforms.Normalize((0.485, 0.456, 0.406), 
					     (0.229, 0.224, 0.225))])

    # discard the transparent, alpha channel (that's the :3) and add the batch dimension
    image = in_transform(image)[:3,:,:].unsqueeze(0)

    return image
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Next, I'm loading in images by file name and forcing the style image to be the same size as the content image.
&lt;/p&gt;

&lt;p&gt;
Load in content and style image.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;load_dotenv()
max_size = 400 if torch.cuda.is_available() else 128
path = DataPathTwo(folder_key="IMAGES", filename_key="RAVEN")
content = load_image(path.from_folder, max_size=max_size).to(device)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Resize style to match content, makes code easier
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;style_path = DataPathTwo(filename_key="VERMEER", folder_key="IMAGES")
style = load_image(style_path.from_folder, shape=content.shape[-2:]).to(device)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
A helper function for un-normalizing an image and converting it from a Tensor image to a NumPy image for display.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def im_convert(tensor: torch.Tensor) -&amp;gt; numpy.ndarray:
    """ Display a tensor as an image.

    Args:
     tensor: tensor with image

    Returns:
     numpy image from tensor
    """

    image = tensor.to("cpu").clone().detach()
    image = image.numpy().squeeze()
    image = image.transpose(1,2,0)
    image = image * numpy.array((0.229, 0.224, 0.225)) + numpy.array((0.485, 0.456, 0.406))
    image = image.clip(0, 1)
    return image
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Display the images.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;figure, (ax1, ax2) = pyplot.subplots(1, 2)
figure.suptitle("Content and Style Images Side-By-Side", weight="bold", y=0.75)
ax1.set_title("Raven (content)")
ax2.set_title("Girl With a Pearl Earring (style)")
ax1.imshow(im_convert(content))
image = ax2.imshow(im_convert(style))
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/images.png" alt="images.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org710a5b8" class="outline-2"&gt;
&lt;h2 id="org710a5b8"&gt;VGG19 Layers&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org710a5b8"&gt;
&lt;p&gt;
To get the content and style representations of an image, we have to pass an image forward through the VGG19 network until we get to the desired layer(s) and then get the output from that layer.
&lt;/p&gt;

&lt;p&gt;
Print out VGG19 structure so you can see the names of various layers.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(vgg)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (1): ReLU(inplace)
  (2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (3): ReLU(inplace)
  (4): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  (5): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (6): ReLU(inplace)
  (7): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (8): ReLU(inplace)
  (9): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  (10): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (11): ReLU(inplace)
  (12): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (13): ReLU(inplace)
  (14): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (15): ReLU(inplace)
  (16): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (17): ReLU(inplace)
  (18): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  (19): Conv2d(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (20): ReLU(inplace)
  (21): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (22): ReLU(inplace)
  (23): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (24): ReLU(inplace)
  (25): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (26): ReLU(inplace)
  (27): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  (28): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (29): ReLU(inplace)
  (30): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (31): ReLU(inplace)
  (32): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (33): ReLU(inplace)
  (34): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (35): ReLU(inplace)
  (36): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8bed676" class="outline-2"&gt;
&lt;h2 id="org8bed676"&gt;Content and Style Features&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org8bed676"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def get_features(image, model, layers=None):
    """ Run an image forward through a model and get the features for 
	a set of layers. Default layers are for VGGNet matching Gatys et al (2016)
    """
    if layers is None:
	layers = {'0': 'conv1_1',
		  '5': 'conv2_1',
		  '10': 'conv3_1', 
		  '19': 'conv4_1',
		  '21': 'conv4_2',  ## content representation
		  '28': 'conv5_1'}


    ## -- do not need to change the code below this line -- ##
    features = {}
    x = image
    # model._modules is a dictionary holding each module in the model
    for name, layer in model._modules.items():
	x = layer(x)
	if name in layers:
	    features[layers[name]] = x            
    return features
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0e02167" class="outline-2"&gt;
&lt;h2 id="org0e02167"&gt;Gram Matrix&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org0e02167"&gt;
&lt;p&gt;
The output of every convolutional layer is a Tensor with dimensions associated with the &lt;code&gt;batch_size&lt;/code&gt;, a depth, &lt;code&gt;d&lt;/code&gt; and some height and width (&lt;code&gt;h&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;). The Gram matrix of a convolutional layer can be calculated as follows:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Get the depth, height, and width of a tensor using &lt;code&gt;batch_size, d, h, w = tensor.size&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Reshape that tensor so that the spatial dimensions are flattened&lt;/li&gt;
&lt;li&gt;Calculate the gram matrix by multiplying the reshaped tensor by it's transpose&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
&lt;b&gt;Note: You can multiply two matrices using &lt;code&gt;torch.mm(matrix1, matrix2)&lt;/code&gt;.&lt;/b&gt;
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def gram_matrix(tensor: torch.Tensor) -&amp;gt; torch.Tensor:
    """ Calculate the Gram Matrix of a given tensor 
	Gram Matrix: https://en.wikipedia.org/wiki/Gramian_matrix
    """
    batch_size, depth, height, width = tensor.size()
    tensor = tensor.view(batch_size * depth, height * width)
    gram = torch.mm(tensor, tensor.t())
    return gram 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org550a59e" class="outline-2"&gt;
&lt;h2 id="org550a59e"&gt;Putting it all Together&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org550a59e"&gt;
&lt;p&gt;
Now that we've written functions for extracting features and computing the gram matrix of a given convolutional layer; let's put all these pieces together! We'll extract our features from our images and calculate the gram matrices for each layer in our style representation.
&lt;/p&gt;

&lt;p&gt;
Get content and style features only once before forming the target image.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;content_features = get_features(content, vgg)
style_features = get_features(style, vgg)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
calculate the gram matrices for each layer of our style representation
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;style_grams = {layer: gram_matrix(style_features[layer]) for layer in style_features}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Create a third "target" image and prep it for change. It is a good idea to start off with the target as a copy of our &lt;b&gt;content&lt;/b&gt; image then iteratively change its style.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;target = content.clone().requires_grad_(True).to(device)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4b0b344" class="outline-2"&gt;
&lt;h2 id="org4b0b344"&gt;Loss and Weights&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org4b0b344"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgaf56554" class="outline-3"&gt;
&lt;h3 id="orgaf56554"&gt;Individual Layer Style Weights&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgaf56554"&gt;
&lt;p&gt;
Below, you are given the option to weight the style representation at each relevant layer. It's suggested that you use a range between 0-1 to weight these layers. By weighting earlier layers (&lt;code&gt;conv1_1&lt;/code&gt; and &lt;code&gt;conv2_1&lt;/code&gt;) more, you can expect to get &lt;i&gt;larger&lt;/i&gt; style artifacts in your resulting, target image. Should you choose to weight later layers, you'll get more emphasis on smaller features. This is because each layer is a different size and together they create a multi-scale style representation!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org670a62b" class="outline-3"&gt;
&lt;h3 id="org670a62b"&gt;Content and Style Weight&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org670a62b"&gt;
&lt;p&gt;
Just like in the paper, we define an alpha (&lt;code&gt;content_weight&lt;/code&gt;) and a beta (&lt;code&gt;style_weight&lt;/code&gt;). This ratio will affect how &lt;i&gt;stylized&lt;/i&gt; your final image is. It's recommended that you leave the content_weight = 1 and set the style_weight to achieve the ratio you want.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org5aa7ff3" class="outline-3"&gt;
&lt;h3 id="org5aa7ff3"&gt;Weights For Each Style Layer&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5aa7ff3"&gt;
&lt;p&gt;
Weighting earlier layers more will result in &lt;b&gt;larger&lt;/b&gt; style artifacts. Notice we are excluding &lt;code&gt;conv4_2&lt;/code&gt; our content representation.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;style_weights = {'conv1_1': 1.,
		 'conv2_1': 0.8,
		 'conv3_1': 0.6,
		 'conv4_1': 0.4,
		 'conv5_1': 0.2}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;content_weight = 1  # alpha
style_weight = 1e6  # beta
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1768a49" class="outline-2"&gt;
&lt;h2 id="org1768a49"&gt;Updating the Target &amp;amp; Calculating Losses&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1768a49"&gt;
&lt;p&gt;
You'll decide on a number of steps for which to update your image, this is similar to the training loop that you've seen before, only we are changing our &lt;span class="underline"&gt;target&lt;/span&gt; image and nothing else about VGG19 or any other image. Therefore, the number of steps is really up to you to set! &lt;b&gt;&lt;b&gt;I recommend using at least 2000 steps for good results.&lt;/b&gt;&lt;/b&gt; But, you may want to start out with fewer steps if you are just testing out different weight values or experimenting with different images.
&lt;/p&gt;

&lt;p&gt;
Inside the iteration loop, you'll calculate the content and style losses and update your target image, accordingly.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgeffab7c" class="outline-2"&gt;
&lt;h2 id="orgeffab7c"&gt;Content Loss&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgeffab7c"&gt;
&lt;p&gt;
The content loss will be the mean squared difference between the target and content features at layer &lt;code&gt;conv4_2&lt;/code&gt;. This can be calculated as follows: 
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;content_loss&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;torch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mean&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;target_features&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'conv4_2'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;content_features&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'conv4_2'&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org51396cc" class="outline-2"&gt;
&lt;h2 id="org51396cc"&gt;Style Loss&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org51396cc"&gt;
&lt;p&gt;
The style loss is calculated in a similar way, only you have to iterate through a number of layers, specified by name in our dictionary &lt;code&gt;style_weights&lt;/code&gt;. 
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;You'll calculate the gram matrix for the target image, &lt;code&gt;target_gram&lt;/code&gt; and style image &lt;code&gt;style_gram&lt;/code&gt; at each of these layers and compare those gram matrices, calculating the &lt;code&gt;layer_style_loss&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Later, you'll see that this value is normalized by the size of the layer.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbb22213" class="outline-2"&gt;
&lt;h2 id="orgbb22213"&gt;Total Loss&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgbb22213"&gt;
&lt;p&gt;
Finally, you'll create the total loss by adding up the style and content losses and weighting them with your specified alpha and beta!
&lt;/p&gt;

&lt;p&gt;
Intermittently, we'll print out this loss; don't be alarmed if the loss is very large. It takes some time for an image's style to change and you should focus on the appearance of your target image rather than any loss value. Still, you should see that this loss decreases over some number of iterations.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;show_every = 400

# iteration hyperparameters
optimizer = optim.Adam([target], lr=0.003)
steps = 2000  # decide how many iterations to update your image (5000)
CONTENT_LAYER = "conv4_2"
start = datetime.now()
for repetition in range(1, steps+1):
    target_features = get_features(target, vgg)
    content_loss = F.mse_loss(target_features[CONTENT_LAYER],
			      content_features[CONTENT_LAYER])

    # the style loss
    # initialize the style loss to 0
    style_loss = 0
    # iterate through each style layer and add to the style loss
    for layer in style_weights:
	# get the "target" style representation for the layer
	target_feature = target_features[layer]
	_, d, h, w = target_feature.shape

	target_gram = gram_matrix(target_feature)

	style_gram = style_grams[layer]

	layer_style_loss = style_weights[layer] * F.mse_loss(target_gram,
							     style_gram)
	# add to the style loss
	style_loss += layer_style_loss / (d * h * w)

    total_loss = content_weight * content_loss + style_weight * style_loss

    ## -- do not need to change code, below -- ##
    # update your target image
    optimizer.zero_grad()
    total_loss.backward()
    optimizer.step()

    # display intermediate images and print the loss
    if  repetition % show_every == 0:
	print('({}) Total loss: {}'.format(repetition, total_loss.item()))
	#plt.imshow(im_convert(target))
	#plt.show()
print("Elapsed: {}".format(datetime.now() - start))
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
(400) Total loss: 26489776.0
(800) Total loss: 12765434.0
(1200) Total loss: 8439541.0
(1600) Total loss: 6268045.0
(2000) Total loss: 4820489.5
Elapsed: 0:08:03.885520

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgcfdb9af" class="outline-2"&gt;
&lt;h2 id="orgcfdb9af"&gt;Display the Target Image&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgcfdb9af"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;figure, (ax1, ax2) = pyplot.subplots(1, 2)
figure.suptitle("Vermeer Raven", weight="bold", y=0.75)
ax1.imshow(im_convert(content))
image = ax2.imshow(im_convert(target))
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/raven_vermeer.png" alt="raven_vermeer.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1075fcf" class="outline-2"&gt;
&lt;h2 id="org1075fcf"&gt;A Holhwein Transfer&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1075fcf"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;max_size = 400 if torch.cuda.is_available() else 128
path = DataPathTwo(folder_key="IMAGES", filename_key="RAVEN")
content = load_image(path.from_folder, max_size=max_size).to(device)

style_path = DataPathTwo(filename_key="HOHLWEIN", folder_key="IMAGES")
style = load_image(style_path.from_folder, shape=content.shape[-2:]).to(device)

content_features = get_features(content, vgg)
target = content.clone().requires_grad_(True).to(device)
content_loss = torch.mean((target_features['conv4_2'] - content_features['conv4_2'])**2)
style_features = get_features(style, vgg)
style_grams = {layer: gram_matrix(style_features[layer]) for layer in style_features}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;show_every = 400
vgg = models.vgg19(pretrained=True).features
for param in vgg.parameters():
    param.requires_grad_(False)
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
vgg.to(device)
# iteration hyperparameters
optimizer = optim.Adam([target], lr=0.003)
steps = 2000  # decide how many iterations to update your image (5000)
CONTENT_LAYER = "conv4_2"
start = datetime.now()
for repetition in range(1, steps+1):
    target_features = get_features(target, vgg)
    content_loss = F.mse_loss(target_features[CONTENT_LAYER],
			      content_features[CONTENT_LAYER])

    # the style loss
    # initialize the style loss to 0
    style_loss = 0
    # iterate through each style layer and add to the style loss
    for layer in style_weights:
	# get the "target" style representation for the layer
	target_feature = target_features[layer]
	_, d, h, w = target_feature.shape

	target_gram = gram_matrix(target_feature)

	style_gram = style_grams[layer]

	layer_style_loss = style_weights[layer] * F.mse_loss(target_gram,
							     style_gram)
	# add to the style loss
	style_loss += layer_style_loss / (d * h * w)

    total_loss = content_weight * content_loss + style_weight * style_loss

    ## -- do not need to change code, below -- ##
    # update your target image
    optimizer.zero_grad()
    total_loss.backward()
    optimizer.step()

    # display intermediate images and print the loss
    if  repetition % show_every == 0:
	print('({}) Total loss: {}'.format(repetition, total_loss.item()))
print("Elapsed: {}".format(datetime.now() - start))
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
(400) Total loss: 38191616.0
(800) Total loss: 19276114.0
(1200) Total loss: 12646590.0
(1600) Total loss: 9095670.0
(2000) Total loss: 6934397.0
Elapsed: 0:08:09.517655

&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;figure, (ax1, ax2) = pyplot.subplots(1, 2)
figure.suptitle("Hohlwein Raven", weight="bold", y=.8)
ax1.imshow(im_convert(content))
image = ax2.imshow(im_convert(target))
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/hohlwein_raven.png" alt="hohlwein_raven.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cnn</category><category>exercise</category><category>style transfer</category><guid>https://necromuralist.github.io/Neurotic-Networking/posts/nano/style-transfer/style-transfer/</guid><pubDate>Sat, 22 Dec 2018 22:44:24 GMT</pubDate></item></channel></rss>