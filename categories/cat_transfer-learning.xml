<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>In Too Deep (Posts about Transfer Learning)</title><link>https://necromuralist.github.io/In-Too-Deep/</link><description></description><atom:link href="https://necromuralist.github.io/In-Too-Deep/categories/cat_transfer-learning.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2019 &lt;a href="mailto:necromuralist@protonmail.com"&gt;Cloistered Monkey&lt;/a&gt; </copyright><lastBuildDate>Sat, 23 Feb 2019 22:45:17 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Transfer Learning Exercise</title><link>https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/transfer-learning-exercise/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/transfer-learning-exercise/#orgd3c18a5"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/transfer-learning-exercise/#org1f515ec"&gt;Imports&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/transfer-learning-exercise/#orgdc15eeb"&gt;Flower power&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/transfer-learning-exercise/#org11d6bc3"&gt;Download the Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/transfer-learning-exercise/#orge27c381"&gt;Transforming the Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/transfer-learning-exercise/#org6bf7c51"&gt;DataLoaders and Data Visualization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/transfer-learning-exercise/#org789a811"&gt;Visualize some sample data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/transfer-learning-exercise/#orgfa9057d"&gt;Plot The Images In The Batch, Along With The Corresponding Labels&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/transfer-learning-exercise/#org067106c"&gt;Define the Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/transfer-learning-exercise/#org4b1b679"&gt;Final Classifier Layer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/transfer-learning-exercise/#org9741c0a"&gt;Specify Loss Function and Optimizer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/transfer-learning-exercise/#orgeb0fa3e"&gt;Training&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgd3c18a5" class="outline-2"&gt;
&lt;h2 id="orgd3c18a5"&gt;Introduction&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgd3c18a5"&gt;
&lt;p&gt;
Most of the time you won't want to train a whole convolutional network yourself. Modern ConvNets training on huge datasets like ImageNet take weeks on multiple GPUs. Instead, most people use a pretrained network either as a fixed feature extractor, or as an initial network to fine tune.
&lt;/p&gt;

&lt;p&gt;
In this notebook, you'll be using &lt;a href="https://arxiv.org/pdf/1409.1556.pdf"&gt;VGGNet&lt;/a&gt; trained on the &lt;a href="http://www.image-net.org/"&gt;ImageNet dataset&lt;/a&gt; as a feature extractor. 
&lt;/p&gt;

&lt;p&gt;
VGGNet is great because it's simple and has great performance, coming in second in the ImageNet competition. The idea here is that we keep all the convolutional layers, but &lt;b&gt;&lt;b&gt;replace the final fully-connected layer&lt;/b&gt;&lt;/b&gt; with our own classifier. This way we can use VGGNet as a &lt;b&gt;fixed feature extractor&lt;/b&gt; for our images then easily train a simple classifier on top of that. 
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Use all but the last fully-connected layer as a fixed feature extractor.&lt;/li&gt;
&lt;li&gt;Define a new, final classification layer and apply it to a task of our choice!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
You can read more about transfer learning from &lt;a href="http://cs231n.github.io/transfer-learning/"&gt;the CS231n Stanford course notes&lt;/a&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1f515ec" class="outline-2"&gt;
&lt;h2 id="org1f515ec"&gt;Imports&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org1f515ec"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# python
from collections import OrderedDict
from datetime import datetime
import os

# pypi
from dotenv import load_dotenv
from torch import nn
from sklearn.model_selection import train_test_split
from torch.utils.data.sampler import SubsetRandomSampler

import matplotlib
import numpy
import seaborn
import torch
import torch.optim as optimize
import torchvision
from torchvision import datasets, models, transforms
import matplotlib.pyplot as pyplot

# this project
from neurotic.tangles.data_paths import DataPathTwo
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org260a82f" class="outline-3"&gt;
&lt;h3 id="org260a82f"&gt;Plotting&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org260a82f"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;get_ipython().run_line_magic('matplotlib', 'inline')
get_ipython().run_line_magic('config', "InlineBackend.figure_format = 'retina'")
seaborn.set(style="whitegrid",
	    rc={"axes.grid": False,
		"font.size": 8,
		"font.family": ["sans-serif"],
		"font.sans-serif": ["Latin Modern Sans", "Lato"],
		"figure.figsize": (8, 6)},
	    font_scale=3)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgdc15eeb" class="outline-2"&gt;
&lt;h2 id="orgdc15eeb"&gt;Flower power&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdc15eeb"&gt;
&lt;p&gt;
Here we'll be using VGGNet to classify images of flowers. We'll start, as usual, by importing our usual resources. And checking if we can train our model on the GPU.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org11d6bc3" class="outline-2"&gt;
&lt;h2 id="org11d6bc3"&gt;Download the Data&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org11d6bc3"&gt;
&lt;p&gt;
Download the flower data from &lt;a href="https://s3.amazonaws.com/video.udacity-data.com/topher/2018/September/5baa60a0_flower-photos/flower-photos.zip"&gt;this link&lt;/a&gt;, save it in the home directory of this notebook and extract the zip file to get the directory &lt;code&gt;flower_photos/&lt;/code&gt;. &lt;b&gt;&lt;b&gt;Make sure the directory has this exact name for accessing data: flower_photos&lt;/b&gt;&lt;/b&gt;.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;load_dotenv()
path = DataPathTwo(folder_key="FLOWERS")
print(path.folder)
for target in path.folder.iterdir():
    print(target)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
/home/hades/datasets/flower_photos
/home/hades/datasets/flower_photos/.DS_Store
/home/hades/datasets/flower_photos/train
/home/hades/datasets/flower_photos/test
/home/hades/datasets/flower_photos/LICENSE.txt

&lt;/pre&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd58ad4b" class="outline-3"&gt;
&lt;h3 id="orgd58ad4b"&gt;Check If CUDA Is Available&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgd58ad4b"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;device = "cuda:0" if torch.cuda.is_available() else "cpu"
print(device)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
cuda:0

&lt;/pre&gt;

&lt;p&gt;
CUDA is running out of memory and crashing so don't use CUDA.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;device = "cpu"
print(device)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
cpu

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org87bc198" class="outline-3"&gt;
&lt;h3 id="org87bc198"&gt;Load and Transform our Data&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org87bc198"&gt;
&lt;p&gt;
We'll be using PyTorch's &lt;a href="https://pytorch.org/docs/stable/torchvision/datasets.html#imagefolder"&gt;ImageFolder&lt;/a&gt; class which makes is very easy to load data from a directory. For example, the training images are all stored in a directory path that looks like this:
&lt;/p&gt;

&lt;pre class="example"&gt;
root/class_1/xxx.png
root/class_1/xxy.png
root/class_1/xxz.png

root/class_2/123.png
root/class_2/nsdf3.png
root/class_2/asd932_.png
&lt;/pre&gt;

&lt;p&gt;
Where, in this case, the root folder for training is &lt;code&gt;flower_photos/train/&lt;/code&gt; and the classes are the names of flower types.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb73001d" class="outline-3"&gt;
&lt;h3 id="orgb73001d"&gt;Define Training and Test Data Directories&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb73001d"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;train_dir = path.folder.joinpath('train/')
test_dir = path.folder.joinpath('test/')
print(train_dir)
print(test_dir)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
/home/hades/datasets/flower_photos/train
/home/hades/datasets/flower_photos/test

&lt;/pre&gt;

&lt;p&gt;
&lt;i&gt;Classes&lt;/i&gt; are folders in each directory with these names:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;classes = ['daisy', 'dandelion', 'roses', 'sunflowers', 'tulips']
CLASS_COUNT = len(classes)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge27c381" class="outline-2"&gt;
&lt;h2 id="orge27c381"&gt;Transforming the Data&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orge27c381"&gt;
&lt;p&gt;
When we perform transfer learning, we have to shape our input data into the shape that the pre-trained model expects. VGG16 expects `224`-dim square images as input and so, we resize each flower image to fit this mold.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb0d2f20" class="outline-3"&gt;
&lt;h3 id="orgb0d2f20"&gt;Load And Transform Data Using ImageFolder&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb0d2f20"&gt;
&lt;p&gt;
VGG-16 Takes 224x224 images as input, so we resize all of them.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;data_transform = transforms.Compose([transforms.RandomResizedCrop(224), 
				      transforms.ToTensor()])

train_data = datasets.ImageFolder(train_dir, transform=data_transform)
test_data = datasets.ImageFolder(test_dir, transform=data_transform)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org201cab8" class="outline-3"&gt;
&lt;h3 id="org201cab8"&gt;Print Out Some Data Stats&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org201cab8"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print('Num training images: ', len(train_data))
print('Num test images: ', len(test_data))
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Num training images:  3130
Num test images:  540

&lt;/pre&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;VALIDATION_FRACTION = 0.2
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;indices = list(range(len(train_data)))
training_indices, validation_indices = train_test_split(
    indices,
    test_size=VALIDATION_FRACTION)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6bf7c51" class="outline-2"&gt;
&lt;h2 id="org6bf7c51"&gt;DataLoaders and Data Visualization&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org6bf7c51"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org09ce245" class="outline-3"&gt;
&lt;h3 id="org09ce245"&gt;Define Dataloader Parameters&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org09ce245"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;BATCH_SIZE = 20
NUM_WORKERS=4
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;train_sampler = SubsetRandomSampler(training_indices)
valid_sampler = SubsetRandomSampler(validation_indices)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4c1efde" class="outline-3"&gt;
&lt;h3 id="org4c1efde"&gt;Prepare Data Loaders&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org4c1efde"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;train_loader = torch.utils.data.DataLoader(train_data, batch_size=BATCH_SIZE, 
					   sampler=train_sampler,
					   num_workers=NUM_WORKERS)
valid_loader = torch.utils.data.DataLoader(train_data, batch_size=BATCH_SIZE, 
					   sampler=valid_sampler, num_workers=NUM_WORKERS)
test_loader = torch.utils.data.DataLoader(test_data, batch_size=batch_size, 
					  num_workers=num_workers, shuffle=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org789a811" class="outline-2"&gt;
&lt;h2 id="org789a811"&gt;Visualize some sample data&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org789a811"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org88c08e9" class="outline-3"&gt;
&lt;h3 id="org88c08e9"&gt;obtain one batch of training images&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org88c08e9"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dataiter = iter(train_loader)
images, labels = dataiter.next()
images = images.numpy() # convert images to numpy for display
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfa9057d" class="outline-2"&gt;
&lt;h2 id="orgfa9057d"&gt;Plot The Images In The Batch, Along With The Corresponding Labels&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgfa9057d"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fig = pyplot.figure(figsize=(12, 10))
pyplot.rc("axes", titlesize=10)
for idx in numpy.arange(20):
    ax = fig.add_subplot(2, 20/2, idx+1, xticks=[], yticks=[])
    pyplot.imshow(numpy.transpose(images[idx], (1, 2, 0)))
    ax.set_title(classes[labels[idx]])
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/transfer-learning-exercise/sample_batches.png" alt="sample_batches.png"&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org067106c" class="outline-2"&gt;
&lt;h2 id="org067106c"&gt;Define the Model&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org067106c"&gt;
&lt;p&gt;
To define a model for training we'll follow these steps:
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;Load in a pre-trained VGG16 model&lt;/li&gt;
&lt;li&gt;"Freeze" all the parameters, so the net acts as a fixed feature extractor&lt;/li&gt;
&lt;li&gt;Remove the last layer&lt;/li&gt;
&lt;li&gt;Replace the last layer with a linear classifier of our own&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
/Freezing simply means that the parameters in the pre-trained model will &lt;b&gt;not&lt;/b&gt; change during training.**
&lt;/p&gt;

&lt;p&gt;
Load the pretrained model from pytorch
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vgg16 = models.vgg16(pretrained=True)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Print Out The Model Structure
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(vgg16)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
VGG(
  (features): Sequential(
    (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (1): ReLU(inplace)
    (2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (3): ReLU(inplace)
    (4): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (5): Conv2d(64, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (6): ReLU(inplace)
    (7): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (8): ReLU(inplace)
    (9): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (10): Conv2d(128, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (11): ReLU(inplace)
    (12): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (13): ReLU(inplace)
    (14): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (15): ReLU(inplace)
    (16): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (17): Conv2d(256, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (18): ReLU(inplace)
    (19): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (20): ReLU(inplace)
    (21): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (22): ReLU(inplace)
    (23): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
    (24): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (25): ReLU(inplace)
    (26): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (27): ReLU(inplace)
    (28): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
    (29): ReLU(inplace)
    (30): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  )
  (classifier): Sequential(
    (0): Linear(in_features=25088, out_features=4096, bias=True)
    (1): ReLU(inplace)
    (2): Dropout(p=0.5)
    (3): Linear(in_features=4096, out_features=4096, bias=True)
    (4): ReLU(inplace)
    (5): Dropout(p=0.5)
    (6): Linear(in_features=4096, out_features=1000, bias=True)
  )
)
&lt;/pre&gt;

&lt;p&gt;
Since we're only going to change the last (classification) layer, it might be helpful to see how many inputs and outpts it has.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(vgg16.classifier[6].in_features) 
print(vgg16.classifier[6].out_features) 
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
4096
1000

&lt;/pre&gt;

&lt;p&gt;
So, the original model output 1,000 classes - we're going to need to change that to our five classes (eventually).
&lt;/p&gt;

&lt;p&gt;
Freeze training for all "features" layers
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for param in vgg16.features.parameters():
    param.requires_grad = False
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4b1b679" class="outline-2"&gt;
&lt;h2 id="org4b1b679"&gt;Final Classifier Layer&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org4b1b679"&gt;
&lt;p&gt;
Once you have the pre-trained feature extractor, you just need to modify and/or add to the final, fully-connected classifier layers. In this case, we suggest that you replace the last layer in the vgg classifier group of layers. 
&lt;/p&gt;

&lt;p&gt;
This layer should see as input the number of features produced by the portion of the network that you are not changing, and produce an appropriate number of outputs for the flower classification task.
&lt;/p&gt;

&lt;p&gt;
You can access any layer in a pretrained network by name and (sometimes) number, i.e. &lt;code&gt;vgg16.classifier[6]&lt;/code&gt; is the sixth layer in a group of layers named "classifier".
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;classifier = nn.Sequential(OrderedDict([
    ("Fullly Connected Classifier", nn.Linear(in_features=4096, out_features=CLASS_COUNT, bias=True)),
]))
vgg16.classifier[6] = classifier
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
after completing your model, if GPU is available, move the model to GPU
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vgg16.to(device)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9741c0a" class="outline-2"&gt;
&lt;h2 id="org9741c0a"&gt;Specify &lt;a href="http://pytorch.org/docs/stable/nn.html#loss-functions"&gt;Loss Function&lt;/a&gt; and &lt;a href="http://pytorch.org/docs/stable/optim.html"&gt;Optimizer&lt;/a&gt;&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org9741c0a"&gt;
&lt;p&gt;
Below we'll use cross-entropy loss and stochastic gradient descent with a small learning rate. Note that the optimizer accepts as input &lt;i&gt;only&lt;/i&gt; the trainable parameters &lt;code&gt;vgg.classifier.parameters()&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb113faa" class="outline-3"&gt;
&lt;h3 id="orgb113faa"&gt;Specify Loss Function (Categorical Cross-Entropy)&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb113faa"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;criterion = nn.CrossEntropyLoss()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
specify optimizer (stochastic gradient descent) and learning rate = 0.001
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;optimizer = optimize.SGD(vgg16.classifier.parameters(), lr=0.001)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgeb0fa3e" class="outline-2"&gt;
&lt;h2 id="orgeb0fa3e"&gt;Training&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgeb0fa3e"&gt;
&lt;p&gt;
Here, we'll train the network.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;&lt;b&gt;Exercise:&lt;/b&gt;&lt;/b&gt; So far we've been providing the training code for you. Here, I'm going to give you a bit more of a challenge and have you write the code to train the network. Of course, you'll be able to see my solution if you need help.
&lt;/p&gt;

&lt;p&gt;
number of epochs to train the model
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;n_epochs = EPOCHS = 2
def train(model: nn.Module, epochs: int=EPOCHS, model_number: int=0,
	  epoch_offset: int=1, print_every: int=10) -&amp;gt; tuple:
    """Train, validate, and save the model
    This trains the model and validates it, saving the best 
    (based on validation loss) as =model_&amp;lt;number&amp;gt;_cifar.pth=

    Args:
     model: the network to train
     epochs: number of times to repeat training
     model_number: an identifier for the saved hyperparameters file
     epoch_offset: amount of epochs that have occurred previously
     print_every: how often to print output
    Returns:
     filename, training-loss, validation-loss, improvements: the outcomes for the training
    """
    optimizer = optimize.SGD(model.parameters(), lr=0.001)
    criterion = nn.CrossEntropyLoss()
    output_file = "model_{}_vgg.pth".format(model_number)
    training_losses = []
    validation_losses = []
    improvements = []
    valid_loss_min = numpy.Inf # track change in validation loss
    epoch_start = epoch_offset
    last_epoch = epoch_start + epochs + 1
    for epoch in range(epoch_start, last_epoch):

	# keep track of training and validation loss
	train_loss = 0.0
	valid_loss = 0.0

	model.train()
	for data, target in train_loader:
	    # move tensors to GPU if CUDA is available            
	    data, target = data.to(device), target.to(device)
	    # clear the gradients of all optimized variables
	    optimizer.zero_grad()
	    # forward pass: compute predicted outputs by passing inputs to the model
	    output = model(data)
	    # calculate the batch loss
	    loss = criterion(output, target)
	    # backward pass: compute gradient of the loss with respect to model parameters
	    loss.backward()
	    # perform a single optimization step (parameter update)
	    optimizer.step()
	    # update training loss
	    train_loss += loss.item() * data.size(0)

	model.eval()
	for data, target in valid_loader:
	    # move tensors to GPU if CUDA is available
	    data, target = data.to(device), target.to(device)
	    # forward pass: compute predicted outputs by passing inputs to the model
	    output = model(data)
	    # calculate the batch loss
	    loss = criterion(output, target)
	    # update total validation loss 
	    valid_loss += loss.item() * data.size(0)

	# calculate average losses
	train_loss = train_loss/len(train_loader.dataset)
	valid_loss = valid_loss/len(valid_loader.dataset)

	# print training/validation statistics 
	if not (epoch % print_every):
	    print('Epoch: {} \tTraining Loss: {:.6f} \tValidation Loss: {:.6f}'.format(
		epoch, train_loss, valid_loss))
	training_losses.append(train_loss)
	validation_losses.append(valid_loss)
	# save model if validation loss has decreased
	if valid_loss &amp;lt;= valid_loss_min:
	    print('Validation loss decreased ({:.6f} --&amp;gt; {:.6f}).  Saving model ...'.format(
	    valid_loss_min,
	    valid_loss))
	    torch.save(model.state_dict(), output_file)
	    valid_loss_min = valid_loss
	    improvements.append(epoch - 1)
    return output_file, training_losses, validation_losses, improvements
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def test(best_model):
    criterion = nn.CrossEntropyLoss()
    # track test loss
    test_loss = 0.0
    class_correct = list(0. for i in range(10))
    class_total = list(0. for i in range(10))

    best_model.to(device)
    best_model.eval()
    # iterate over test data
    for data, target in test_loader:
	# move tensors to GPU if CUDA is available
	data, target = data.to(device), target.to(device)
	# forward pass: compute predicted outputs by passing inputs to the model
	output = best_model(data)
	# calculate the batch loss
	loss = criterion(output, target)
	# update test loss 
	test_loss += loss.item() * data.size(0)
	# convert output probabilities to predicted class
	_, pred = torch.max(output, 1)    
	# compare predictions to true label
	correct_tensor = pred.eq(target.data.view_as(pred))
	correct = (
	    numpy.squeeze(correct_tensor.numpy())
	    if not train_on_gpu
	    else numpy.squeeze(correct_tensor.cpu().numpy()))
	# calculate test accuracy for each object class
	for i in range(BATCH_SIZE):
	    label = target.data[i]
	    class_correct[label] += correct[i].item()
	    class_total[label] += 1

    # average test loss
    test_loss = test_loss/len(test_loader.dataset)
    print('Test Loss: {:.6f}\n'.format(test_loss))

    for i in range(10):
	if class_total[i] &amp;gt; 0:
	    print('Test Accuracy of %5s: %2d%% (%2d/%2d)' % (
		classes[i], 100 * class_correct[i] / class_total[i],
		numpy.sum(class_correct[i]), numpy.sum(class_total[i])))
	else:
	    print('Test Accuracy of %5s: N/A (no training examples)' % (classes[i]))

    print('\nTest Accuracy (Overall): %2d%% (%2d/%2d)' % (
	100. * numpy.sum(class_correct) / numpy.sum(class_total),
	numpy.sum(class_correct), numpy.sum(class_total)))
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;output_file, training_losses, validation_losses, improvements = train(vgg16, print_every=1)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;training_losses = []
validation_losses = []
improvements = []
valid_loss_min = numpy.Inf # track change in validation loss
for epoch in range(1, 3):

    # keep track of training and validation loss
    train_loss = 0.0
    valid_loss = 0.0

    vgg16.train()
    for data, target in train_loader:
	# move tensors to GPU if CUDA is available            
	data, target = data.to(device), target.to(device)
	# clear the gradients of all optimized variables
	optimizer.zero_grad()
	# forward pass: compute predicted outputs by passing inputs to the model
	output = vgg16(data)
	# calculate the batch loss
	loss = criterion(output, target)
	# backward pass: compute gradient of the loss with respect to model parameters
	loss.backward()
	# perform a single optimization step (parameter update)
	optimizer.step()
	# update training loss
	train_loss += loss.item() * data.size(0)

    vgg16.eval()
    for data, target in valid_loader:
	# move tensors to GPU if CUDA is available
	data, target = data.to(device), target.to(device)
	# forward pass: compute predicted outputs by passing inputs to the model
	output = vgg16(data)
	# calculate the batch loss
	loss = criterion(output, target)
	# update total validation loss 
	valid_loss += loss.item() * data.size(0)

    # calculate average losses
    train_loss = train_loss/len(train_loader.dataset)
    valid_loss = valid_loss/len(valid_loader.dataset)

    # print training/validation statistics 
    print('Epoch: {} \tTraining Loss: {:.6f} \tValidation Loss: {:.6f}'.format(
	epoch, train_loss, valid_loss))
    training_losses.append(train_loss)
    validation_losses.append(valid_loss)
    # save model if validation loss has decreased
    if valid_loss &amp;lt;= valid_loss_min:
	print('Validation loss decreased ({:.6f} --&amp;gt; {:.6f}).  Saving model ...'.format(
	valid_loss_min,
	valid_loss))
	torch.save(vgg16.state_dict(), output_file)
	valid_loss_min = valid_loss
	improvements.append(epoch - 1)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
test_loss = 0.0
class_correct = list(0. for i in range(5))
class_total = list(0. for i in range(5))
&lt;/p&gt;

&lt;p&gt;
vgg16.eval() # eval mode
&lt;/p&gt;

&lt;p&gt;
for data, target in test_loader:
&lt;/p&gt;

&lt;p&gt;
if train_on_gpu:
    data, target = data.cuda(), target.cuda()
&lt;/p&gt;

&lt;p&gt;
output = vgg16(data)
&lt;/p&gt;

&lt;p&gt;
loss = criterion(output, target)
&lt;/p&gt;

&lt;p&gt;
test_loss += loss.item()*data.size(0)
&lt;/p&gt;

&lt;p&gt;
_, pred = torch.max(output, 1)    
&lt;/p&gt;

&lt;p&gt;
correct_tensor = pred.eq(target.data.view_as(pred))
correct = np.squeeze(correct_tensor.numpy()) if not train_on_gpu else np.squeeze(correct_tensor.cpu().numpy())
&lt;/p&gt;

&lt;p&gt;
for i in range(batch_size):
    label = target.data[i]
    class_correct[label] += correct[i].item()
    class_total[label] += 1
&lt;/p&gt;

&lt;p&gt;
test_loss = test_loss/len(test_loader.dataset)
print('Test Loss: {:.6f}\n'.format(test_loss))
&lt;/p&gt;

&lt;p&gt;
for i in range(5):
    if class_total[i] &amp;gt; 0:
        print('Test Accuracy of %5s: %2d%% (%2d/%2d)' % (
            classes[i], 100 * class_correct[i] / class_total[i],
            np.sum(class_correct[i]), np.sum(class_total[i])))
    else:
        print('Test Accuracy of %5s: N/A (no training examples)' % (classes[i]))
&lt;/p&gt;

&lt;p&gt;
print('\nTest Accuracy (Overall): %2d%% (%2d/%2d)' % (
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;* np.sum(class_correct) / np.sum(class_total),&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
np.sum(class_correct), np.sum(class_total)))
&lt;/p&gt;


&lt;p&gt;
dataiter = iter(test_loader)
images, labels = dataiter.next()
images.numpy()
&lt;/p&gt;

&lt;p&gt;
if train_on_gpu:
    images = images.cuda()
&lt;/p&gt;

&lt;p&gt;
output = vgg16(images)
&lt;/p&gt;

&lt;p&gt;
_, preds_tensor = torch.max(output, 1)
preds = np.squeeze(preds_tensor.numpy()) if not train_on_gpu else np.squeeze(preds_tensor.cpu().numpy())
&lt;/p&gt;

&lt;p&gt;
fig = plt.figure(figsize=(25, 4))
for idx in np.arange(20):
    ax = fig.add_subplot(2, 20/2, idx+1, xticks=[], yticks=[])
    plt.imshow(np.transpose(images[idx], (1, 2, 0)))
    ax.set_title("{} ({})".format(classes[preds[idx]], classes[labels[idx]]),
                 color=("green" if preds[idx]==labels[idx].item() else "red"))
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>cnn</category><category>exercise</category><category>transfer learning</category><guid>https://necromuralist.github.io/In-Too-Deep/posts/nano/cnn/transfer-learning-exercise/</guid><pubDate>Sat, 15 Dec 2018 22:50:47 GMT</pubDate></item></channel></rss>