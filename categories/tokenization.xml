<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Neurotic Networking (Posts about tokenization)</title><link>https://necromuralist.github.io/Neurotic-Networking/</link><description></description><atom:link href="https://necromuralist.github.io/Neurotic-Networking/categories/tokenization.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2020 &lt;a href="mailto:necromuralist@protonmail.com"&gt;Cloistered Monkey&lt;/a&gt; &lt;a rel="license" href="http://creativecommons.org/licenses/by/4.0/"&gt;&lt;img id="license-image" alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png" /&gt;&lt;/a&gt;This work is licensed under a &lt;a rel="license" href="http://creativecommons.org/licenses/by/4.0/"&gt;Creative Commons Attribution 4.0 International License&lt;/a&gt;.</copyright><lastBuildDate>Fri, 23 Oct 2020 01:36:49 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>IMDB GRU With Tokenization</title><link>https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#org00220f3"&gt;Beginning&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#org336a4cb"&gt;Imports&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#org7fa45f2"&gt;Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#orgc6aff24"&gt;PyPi&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#org32a82e7"&gt;Other&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#orgb011395"&gt;Set Up&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#orgfc9ef8b"&gt;The Timer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#org3912ea2"&gt;Plotting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#orged6378f"&gt;Middle&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#org7b84880"&gt;Set Up the Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#orgeae0db2"&gt;Building Up the Tokenizer&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#org33c8f9d"&gt;Split Up the Sentences and Their Labels&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#org695df13"&gt;Some Constants&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#orga066bfb"&gt;Build the Tokenizer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#orga0a237f"&gt;Decoder Ring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#org0d0dd1d"&gt;Build the Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#orgedd637a"&gt;Train it&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#org1d1575f"&gt;Plot It&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/#org53150d6"&gt;Raw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org00220f3" class="outline-2"&gt;
&lt;h2 id="org00220f3"&gt;Beginning&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org00220f3"&gt;
&lt;p&gt;
This is another version of the RNN model to classify the IMDB reviews, but this time we're going to tokenize it ourselves and use a GRU, instead of using the tensorflow-datasets version.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org336a4cb" class="outline-3"&gt;
&lt;h3 id="org336a4cb"&gt;Imports&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org336a4cb"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org7fa45f2" class="outline-4"&gt;
&lt;h4 id="org7fa45f2"&gt;Python&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org7fa45f2"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from argparse import Namespace
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgc6aff24" class="outline-4"&gt;
&lt;h4 id="orgc6aff24"&gt;PyPi&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgc6aff24"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences

import hvplot.pandas
import numpy
import pandas
import tensorflow
import tensorflow_datasets
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org32a82e7" class="outline-4"&gt;
&lt;h4 id="org32a82e7"&gt;Other&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org32a82e7"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;from graeae import Timer, EmbedHoloviews
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb011395" class="outline-3"&gt;
&lt;h3 id="orgb011395"&gt;Set Up&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgb011395"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgfc9ef8b" class="outline-4"&gt;
&lt;h4 id="orgfc9ef8b"&gt;The Timer&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-orgfc9ef8b"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;TIMER = Timer()
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3912ea2" class="outline-4"&gt;
&lt;h4 id="org3912ea2"&gt;Plotting&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orged6378f" class="outline-2"&gt;
&lt;h2 id="orged6378f"&gt;Middle&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orged6378f"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org7b84880" class="outline-3"&gt;
&lt;h3 id="org7b84880"&gt;Set Up the Data&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org7b84880"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;imdb, info = tensorflow_datasets.load("imdb_reviews",
				      with_info=True,
				      as_supervised=True)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
WARNING: Logging before flag parsing goes to stderr.
W0924 21:52:10.158111 139862640383808 dataset_builder.py:439] Warning: Setting shuffle_files=True because split=TRAIN and shuffle_files=None. This behavior will be deprecated on 2019-08-06, at which point shuffle_files=False will be the default for all splits.
&lt;/pre&gt;



&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;training, testing = imdb["train"], imdb["test"]
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgeae0db2" class="outline-3"&gt;
&lt;h3 id="orgeae0db2"&gt;Building Up the Tokenizer&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgeae0db2"&gt;
&lt;p&gt;
Since we didn't pass in a specifier for the configuration we wanted (e.g. &lt;code&gt;imdb/subwords8k&lt;/code&gt;) it defaulted to giving us the plain text reviews (and their labels) so we have to build the tokenizer ourselves.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org33c8f9d" class="outline-4"&gt;
&lt;h4 id="org33c8f9d"&gt;Split Up the Sentences and Their Labels&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org33c8f9d"&gt;
&lt;p&gt;
As you might recall, the data set consists of 50,000 IMDB movie reviews categorized as positive or negative. To build the tokenize we first have to split the sentences from their labels
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;training_sentences = []
training_labels = []
testing_sentences = []
testing_labels = []
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;with TIMER:
    for sentence, label in training:
	training_sentences.append(str(sentence.numpy()))
	training_labels.append(str(label.numpy()))


    for sentence, label in testing:
	testing_sentences.append(str(sentence.numpy))
	testing_labels.append(str(label.numpy()))
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
2019-09-24 21:52:11,396 graeae.timers.timer start: Started: 2019-09-24 21:52:11.395126
I0924 21:52:11.396310 139862640383808 timer.py:70] Started: 2019-09-24 21:52:11.395126
2019-09-24 21:52:18,667 graeae.timers.timer end: Ended: 2019-09-24 21:52:18.667789
I0924 21:52:18.667830 139862640383808 timer.py:77] Ended: 2019-09-24 21:52:18.667789
2019-09-24 21:52:18,670 graeae.timers.timer end: Elapsed: 0:00:07.272663
I0924 21:52:18.670069 139862640383808 timer.py:78] Elapsed: 0:00:07.272663
&lt;/pre&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;training_labels_final = numpy.array(training_labels)
testing_labels_final = numpy.array(testing_labels)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org695df13" class="outline-4"&gt;
&lt;h4 id="org695df13"&gt;Some Constants&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org695df13"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Text = Namespace(
    vocab_size = 10000,
    embedding_dim = 16,
    max_length = 120,
    trunc_type='post',
    oov_token = "&amp;lt;OOV&amp;gt;",
)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orga066bfb" class="outline-3"&gt;
&lt;h3 id="orga066bfb"&gt;Build the Tokenizer&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga066bfb"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tokenizer = Tokenizer(num_words=Text.vocab_size, oov_token=Text.oov_token)
with TIMER:
    tokenizer.fit_on_texts(training_sentences)

    word_index = tokenizer.word_index
    sequences = tokenizer.texts_to_sequences(training_sentences)
    padded = pad_sequences(sequences, maxlen=Text.max_length, truncating=Text.trunc_type)

    testing_sequences = tokenizer.texts_to_sequences(testing_sentences)
    testing_padded = pad_sequences(testing_sequences, maxlen=Text.max_length)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
2019-09-24 21:52:21,705 graeae.timers.timer start: Started: 2019-09-24 21:52:21.705287
I0924 21:52:21.705317 139862640383808 timer.py:70] Started: 2019-09-24 21:52:21.705287
2019-09-24 21:52:32,152 graeae.timers.timer end: Ended: 2019-09-24 21:52:32.152267
I0924 21:52:32.152314 139862640383808 timer.py:77] Ended: 2019-09-24 21:52:32.152267
2019-09-24 21:52:32,154 graeae.timers.timer end: Elapsed: 0:00:10.446980
I0924 21:52:32.154620 139862640383808 timer.py:78] Elapsed: 0:00:10.446980
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga0a237f" class="outline-3"&gt;
&lt;h3 id="orga0a237f"&gt;Decoder Ring&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orga0a237f"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;index_to_word = {value: key for key, value in word_index.items()}

def decode_review(text: numpy.array) -&amp;gt; str:
    return " ".join([index_to_word.get(item, "&amp;lt;?&amp;gt;") for item in text])
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0d0dd1d" class="outline-3"&gt;
&lt;h3 id="org0d0dd1d"&gt;Build the Model&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org0d0dd1d"&gt;
&lt;p&gt;
This time we're going to build a four-layer model with one Bidirectional layer that uses a &lt;a href="https://www.tensorflow.org/versions/r2.0/api_docs/python/tf/keras/layers/GRU"&gt;GRU&lt;/a&gt; (&lt;a href="https://www.wikiwand.com/en/Gated_recurrent_unit"&gt;Gated Recurrent Unit&lt;/a&gt;) instead of a LSTM.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;model = tensorflow.keras.Sequential([
    tensorflow.keras.layers.Embedding(Text.vocab_size, Text.embedding_dim, input_length=Text.max_length),
    tensorflow.keras.layers.Bidirectional(tensorflow.compat.v2.keras.layers.GRU(32)),
    tensorflow.keras.layers.Dense(6, activation='relu'),
    tensorflow.keras.layers.Dense(1, activation='sigmoid')
])
model.compile(loss="binary_crossentropy", optimizer="adam", metrics=["accuracy"])
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print(model.summary())
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
Model: "sequential"
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
embedding (Embedding)        (None, 120, 16)           160000    
_________________________________________________________________
bidirectional (Bidirectional (None, 64)                9600      
_________________________________________________________________
dense (Dense)                (None, 6)                 390       
_________________________________________________________________
dense_1 (Dense)              (None, 1)                 7         
=================================================================
Total params: 169,997
Trainable params: 169,997
Non-trainable params: 0
_________________________________________________________________
None
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgedd637a" class="outline-3"&gt;
&lt;h3 id="orgedd637a"&gt;Train it&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgedd637a"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;EPOCHS = 50
ONCE_PER_EPOCH = 2
batch_size = 8
history = model.fit(padded, training_labels_final,
		    epochs=EPOCHS,
		    batch_size=batch_size,
		    validation_data=(testing_padded, testing_labels_final),
		    verbose=ONCE_PER_EPOCH)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1d1575f" class="outline-3"&gt;
&lt;h3 id="org1d1575f"&gt;Plot It&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1d1575f"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;data = pandas.DataFrame(history.history)
plot = data.hvplot().opts(title="GRU Training Performance", width=1000, height=800)
Embed(plot=plot, file_name="gru_training")()
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org53150d6" class="outline-2"&gt;
&lt;h2 id="org53150d6"&gt;Raw&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org53150d6"&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>gru</category><category>nlp</category><category>tokenization</category><guid>https://necromuralist.github.io/Neurotic-Networking/posts/keras/imdb-lstm-with-tokenization/</guid><pubDate>Mon, 23 Sep 2019 21:14:04 GMT</pubDate></item></channel></rss>