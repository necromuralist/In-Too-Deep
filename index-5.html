<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#">
<head>
<meta charset="utf-8">
<meta content="Studies in Deep Learning." name="description">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>Neurotic Networking (old posts, page 5) | Neurotic Networking</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta content="#5670d4" name="theme-color">
<meta content="Nikola (getnikola.com)" name="generator">
<link href="rss.xml" hreflang="en" rel="alternate" title="RSS" type="application/rss+xml">
<link href="https://necromuralist.github.io/Neurotic-Networking/index-5.html" rel="canonical">
<link href="index-6.html" rel="prev" type="text/html">
<link href="index-4.html" rel="next" type="text/html"><!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
<link href="apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180">
<link href="favicon-32x32.png" rel="icon" sizes="32x32" type="image/png">
<link href="favicon-16x16.png" rel="icon" sizes="16x16" type="image/png">
<link href="site.webmanifest" rel="manifest">
</head>
<body>
<a class="sr-only sr-only-focusable" href="#content">Skip to main content</a> <!-- Menubar -->
<nav class="navbar navbar-expand-md static-top mb-4 navbar-light bg-light">
<div class="container"><!-- This keeps the margins nice -->
 <a class="navbar-brand" href="."><span id="blog-title">Neurotic Networking</span></a> <button aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler" data-target="#bs-navbar" data-toggle="collapse" type="button"><span class="navbar-toggler-icon"></span></button>
<div class="collapse navbar-collapse" id="bs-navbar">
<ul class="navbar-nav mr-auto">
<li class="nav-item"><a class="nav-link" href="archive.html">Archive</a></li>
<li class="nav-item"><a class="nav-link" href="categories/">Tags</a></li>
<li class="nav-item"><a class="nav-link" href="rss.xml">RSS feed</a></li>
<li class="nav-item"><a class="nav-link" href="https://necromuralist.github.io/">Cloistered Monkey</a></li>
</ul>
<!-- Google custom search -->
<form action="https://www.google.com/search" class="navbar-form navbar-right" method="get" role="search">
<div class="form-group"><input class="form-control" name="q" placeholder="Search" type="text"></div>
<!-- 
<button type="submit" class="btn btn-primary">
        <span class="glyphicon glyphicon-search"></span>
</button>
-->
<input name="sitesearch" type="hidden" value="https://necromuralist.github.io/Neurotic-Networking/"></form>
<!-- End of custom search -->
<ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse --></div>
<!-- /.container --></nav>
<!-- End of Menubar -->
<div class="container" id="content" role="main">
<div class="body-content"><!--Body content-->
<div class="postindex">
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/nano/dog-breed-classifier/dog-breed-classification/">Dog Breed Classification</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/nano/dog-breed-classifier/dog-breed-classification/" rel="bookmark"><time class="published dt-published" datetime="2018-11-26T13:11:29-08:00" itemprop="datePublished" title="2018-11-26 13:11">2018-11-26 13:11</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/nano/dog-breed-classifier/dog-breed-classification/#orgcb9499d">Introduction</a></li>
<li><a href="posts/nano/dog-breed-classifier/dog-breed-classification/#org1023961">Set Up</a></li>
<li><a href="posts/nano/dog-breed-classifier/dog-breed-classification/#orgb019b7d">A Human Face Detector</a></li>
<li><a href="posts/nano/dog-breed-classifier/dog-breed-classification/#orga7f4688">A Dog Detector</a></li>
<li><a href="posts/nano/dog-breed-classifier/dog-breed-classification/#orgfcf95c1">Combine The Detectors</a></li>
<li><a href="posts/nano/dog-breed-classifier/dog-breed-classification/#orgc171a62">A Dog Breed Classifier</a></li>
<li><a href="posts/nano/dog-breed-classifier/dog-breed-classification/#org7448652">The Dog Breed Classifier</a></li>
<li><a href="posts/nano/dog-breed-classifier/dog-breed-classification/#orgcdf230c">Some Sample applications</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-orgcb9499d">
<h2 id="orgcb9499d">Introduction</h2>
<div class="outline-text-2" id="text-orgcb9499d">
<p>This application is a dog-breed classifier. It takes as input an image and detects if it's an image of either a human or a dog and if it's either one of those then it finds the dog-breed classification that the subject of the image most resembles. If it's neither a human or a dog then it emits an error message. To do this I'm going to try two libraries for each of the human face-detectors and dog detectors and I'm also going to try three Neural Networks to try and classify the dog breeds.</p>
</div>
</div>
<div class="outline-2" id="outline-container-org1023961">
<h2 id="org1023961">Set Up</h2>
<div class="outline-text-2" id="text-org1023961">
<p>This section does some preliminary set-up for the code that comes later.</p>
</div>
<div class="outline-3" id="outline-container-org10b230b">
<h3 id="org10b230b">Imports</h3>
<div class="outline-text-3" id="text-org10b230b"></div>
<div class="outline-4" id="outline-container-org6f1cd74">
<h4 id="org6f1cd74">Python</h4>
<div class="outline-text-4" id="text-org6f1cd74">
<div class="highlight">
<pre><span></span>from functools import partial
from pathlib import Path
import os
import warnings
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orge238024">
<h4 id="orge238024">From Pypi</h4>
<div class="outline-text-4" id="text-orge238024">
<div class="highlight">
<pre><span></span>from dotenv import load_dotenv
from PIL import Image, ImageFile
from torchvision import datasets
import cv2
import face_recognition
import matplotlib.cbook
warnings.filterwarnings("ignore", category=matplotlib.cbook.mplDeprecation)
import matplotlib.pyplot as pyplot
import matplotlib.image as mpimage
import matplotlib.patches as patches
import numpy
try:
    import pyttsx3
    SPEAKABLE = True
except ImportError:
    print("pyttsx3 not available")
    SPEAKABLE = False
import seaborn
import torch
import torchvision.models as models
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optimizer
import torchvision.transforms as transforms
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org83b4e58">
<h4 id="org83b4e58">This Project</h4>
<div class="outline-text-4" id="text-org83b4e58">
<p>This is code that I wrote to maybe make it easier to work with.</p>
<div class="highlight">
<pre><span></span>from neurotic.tangles.data_paths import DataPathTwo
from neurotic.tangles.timer import Timer
from neurotic.constants.imagenet_map import imagenet
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org0e4e9c3">
<h3 id="org0e4e9c3">Plotting</h3>
<div class="outline-text-3" id="text-org0e4e9c3">
<div class="highlight">
<pre><span></span>get_ipython().run_line_magic('matplotlib', 'inline')
get_ipython().run_line_magic('config', "InlineBackend.figure_format = 'retina'")
seaborn.set(style="whitegrid",
            rc={"axes.grid": False,
                "font.family": ["sans-serif"],
                "font.sans-serif": ["Open Sans", "Latin Modern Sans", "Lato"],
                "figure.figsize": (8, 6)},
            font_scale=1)
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org6dbd320">
<h3 id="org6dbd320">Set the Random Seed</h3>
<div class="outline-text-3" id="text-org6dbd320">
<div class="highlight">
<pre><span></span>numpy.random.seed(seed=2019)
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgb847448">
<h3 id="orgb847448">Check If CUDA Is Available</h3>
<div class="outline-text-3" id="text-orgb847448">
<div class="highlight">
<pre><span></span>device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(device)
</pre></div>
<pre class="example">
cuda
</pre></div>
</div>
<div class="outline-3" id="outline-container-org2432297">
<h3 id="org2432297">Handle Truncated Images</h3>
<div class="outline-text-3" id="text-org2432297">
<p>There seems to be at least one image that is truncated which will cause an exception when it's loaded so this next setting lets us ignore the error and keep working.</p>
<div class="highlight">
<pre><span></span>ImageFile.LOAD_TRUNCATED_IMAGES = True
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgf19947f">
<h3 id="orgf19947f">Build the Timer</h3>
<div class="outline-text-3" id="text-orgf19947f">
<p>The timer times how long a code-block takes to run so that if I run it more than once I'll know if it will take a while.</p>
<div class="highlight">
<pre><span></span>timer = Timer(beep=SPEAKABLE)
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org439fc85">
<h3 id="org439fc85">The Data Paths</h3>
<div class="outline-text-3" id="text-org439fc85">
<p>The data-sets are hosted online and need to be downloaded.</p>
<ul class="org-ul">
<li>This is a download link for the <a href="https://s3-us-west-1.amazonaws.com/udacity-aind/dog-project/dogImages.zip">dog dataset</a>.</li>
<li>This is a download link for the the <a href="https://s3-us-west-1.amazonaws.com/udacity-aind/dog-project/lfw.zip">human dataset</a>.</li>
</ul>
<p>I've already downloaded them and put the path to the folders in a <code>.env</code> file so this next block gets the paths so we can load the data later.</p>
</div>
<div class="outline-4" id="outline-container-org1a1818c">
<h4 id="org1a1818c">The Model Path</h4>
<div class="outline-text-4" id="text-org1a1818c">
<p>The models turn out to take up a lot of space so I'm saving them outside of the repository.</p>
<div class="highlight">
<pre><span></span>MODEL_PATH = DataPathTwo(folder_key="MODELS")
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgd50d016">
<h4 id="orgd50d016">Dog Paths</h4>
<div class="outline-text-4" id="text-orgd50d016">
<p>This is a class to hold the paths for the dog Images</p>
<div class="highlight">
<pre><span></span>class DogPaths:
    """holds the paths to the dog images"""
    def __init__(self) -&gt; None:
        self._main = None
        self._training = None
        self._testing = None
        self._validation = None
        self._breed_count = None
        load_dotenv()
        return

    @property
    def main(self) -&gt; DataPathTwo:
        """The path to the main folder"""
        if self._main is None:
            self._main = DataPathTwo(folder_key="DOG_PATH")
        return self._main

    @property
    def training(self) -&gt; DataPathTwo:
        """Path to the training images"""
        if self._training is None:
            self._training = DataPathTwo(folder_key="DOG_TRAIN")
        return self._training

    @property
    def validation(self) -&gt; DataPathTwo:
        """Path to the validation images"""
        if self._validation is None:
            self._validation = DataPathTwo(folder_key="DOG_VALIDATE")
        return self._validation

    @property
    def testing(self) -&gt; DataPathTwo:
        """Path to the testing images"""
        if self._testing is None:
            self._testing = DataPathTwo(folder_key="DOG_TEST")
        return self._testing

    @property
    def breed_count(self) -&gt; int:
        """Counts the number of dog breeds

        This assumes that the training folder has all the breeds
        """
        if self._breed_count is None:
            self._breed_count = len(set(self.training.folder.iterdir()))
        return self._breed_count

    def check(self) -&gt; None:
        """Checks that the folders are valid

        Raises: 
         AssertionError: folder doesn't exist
        """
        self.main.check_folder()
        self.training.check_folder()
        self.validation.check_folder()
        self.testing.check_folder()
        return
</pre></div>
<p>Now I'll build the dog-paths.</p>
<div class="highlight">
<pre><span></span>dog_paths = DogPaths()
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgc40abc3">
<h4 id="orgc40abc3">Human Path</h4>
<div class="outline-text-4" id="text-orgc40abc3">
<p>This is the path to the downloaded <a href="http://vis-www.cs.umass.edu/lfw/">Labeled Faces in the Wild</a> data set.</p>
<div class="highlight">
<pre><span></span>human_path = DataPathTwo(folder_key="HUMAN_PATH")
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org923e0d3">
<h4 id="org923e0d3">Check the Paths</h4>
<div class="outline-text-4" id="text-org923e0d3">
<p>This makes sure that the folders exist and shows where they are.</p>
<div class="highlight">
<pre><span></span>print(dog_paths.main.folder)
print(dog_paths.training.folder)
print(dog_paths.testing.folder)
print(dog_paths.validation.folder)
dog_paths.check()
print(human_path.folder)
human_path.check_folder()
</pre></div>
<pre class="example">
/home/hades/data/datasets/dog-breed-classification/dogImages
/home/hades/data/datasets/dog-breed-classification/dogImages/train
/home/hades/data/datasets/dog-breed-classification/dogImages/test
/home/hades/data/datasets/dog-breed-classification/dogImages/valid
/home/hades/data/datasets/dog-breed-classification/lfw
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org773d6f4">
<h3 id="org773d6f4">Count The Breeds</h3>
<div class="outline-text-3" id="text-org773d6f4">
<p>To build the neural network I'll need to know how many dog breeds there are. I made it an attribute of the <code>DogPath</code> class and I'll just inspect it here.</p>
<div class="highlight">
<pre><span></span>print("Number of Dog Breeds: {}".format(dog_paths.breed_count))
</pre></div>
<pre class="example">
Number of Dog Breeds: 133
</pre></div>
</div>
<div class="outline-3" id="outline-container-org5f9a632">
<h3 id="org5f9a632">Load the Files</h3>
<div class="outline-text-3" id="text-org5f9a632">
<p>For this first part we're going to load in all the files and ignore the train-validation-test split for the dog-images.</p>
<div class="highlight">
<pre><span></span>timer.start()
human_files = numpy.array(list(human_path.folder.glob("*/*")))
dog_files = numpy.array(list(dog_paths.main.folder.glob("*/*/*")))
timer.end()
</pre></div>
<pre class="example">
Started: 2019-01-13 14:05:09.566221
Ended: 2019-01-13 14:05:42.932863
Elapsed: 0:00:33.366642
</pre>
<div class="highlight">
<pre><span></span>print('There are {:,} total human images.'.format(len(human_files)))
print('There are {:,} total dog images.'.format(len(dog_files)))
</pre></div>
<pre class="example">
There are 13,233 total human images.
There are 8,351 total dog images.
</pre>
<p>So we have a bit more human images than dog images.</p>
</div>
</div>
<div class="outline-3" id="outline-container-orge3b4a6b">
<h3 id="orge3b4a6b">Some Helper Code</h3>
<div class="outline-text-3" id="text-orge3b4a6b">
<p>This is code meant to help with the other code.</p>
</div>
<div class="outline-4" id="outline-container-orgbb381e2">
<h4 id="orgbb381e2">Tee</h4>
<div class="outline-text-4" id="text-orgbb381e2">
<p>I wrote this for the jupyter notebook because it loses the output if the server disconnects. I think it will also make it easier to use multiproccessing so I can train things in parallel. But I don't think I'm using it right now.</p>
<div class="highlight">
<pre><span></span>class Tee:
    """Save the input to a file and print it

    Args:
     log_name: name to give the log    
     directory_path: path to the directory for the file
    """
    def __init__(self, log_name: str, 
                 directory_name: str="../../../logs/dog-breed-classifier") -&gt; None:
        self.directory_name = directory_name
        self.log_name = log_name
        self._path = None
        self._log = None
        return

    @property
    def path(self) -&gt; Path:
        """path to the log-file"""
        if self._path is None:
            self._path = Path(self.directory_name).expanduser()
            assert self._path.is_dir()
            self._path = self._path.joinpath(self.log_name)
        return self._path

    @property
    def log(self):
        """File object to write log to"""
        if self._log is None:
            self._log = self.path.open("w", buffering=1)
        return self._log

    def __call__(self, line: str) -&gt; None:
        """Writes to the file and stdout

        Args:
         line: text to emit
        """
        self.log.write("{}\n".format(line))
        print(line)
        return
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org1992b5b">
<h4 id="org1992b5b">F1 Scorer</h4>
<div class="outline-text-4" id="text-org1992b5b">
<p>I'm going to be comparing two models for both the humans and dogs, this scorer will focus on the F1 score, but will emit some other information as well.</p>
<div class="highlight">
<pre><span></span> class F1Scorer:
     """Calculates the F1 and other scores

     Args:
      predictor: callable that gets passed and image and outputs boolean
      true_images: images that should be predicted as True
      false_images: images that shouldn't be matched by the predictor
      done_message: what to announce when done
     """
     def __init__(self, predictor: callable, true_images:list,
                  false_images: list,
                  done_message: str="Scoring Done") -&gt; None:
         self.predictor = predictor
         self.true_images = true_images
         self.false_images = false_images
         self.done_message = done_message
         self._timer = None
         self._false_image_predictions = None
         self._true_image_predictions = None
         self._false_positives = None
         self._false_negatives = None
         self._true_positives = None
         self._true_negatives = None
         self._false_positive_rate = None
         self._precision = None
         self._recall = None
         self._f1 = None
         self._accuracy = None
         self._specificity = None
         return

     @property
     def timer(self) -&gt; Timer:
         if self._timer is None:
             self._timer = Timer(message=self.done_message, emit=False)
         return self._timer

     @property
     def false_image_predictions(self) -&gt; list:
         """Predictions made on the false-images"""
         if self._false_image_predictions is None:
             self._false_image_predictions = [self.predictor(str(image))
                                              for image in self.false_images]
         return self._false_image_predictions

     @property
     def true_image_predictions(self) -&gt; list:
         """Predictions on the true-images"""
         if self._true_image_predictions is None:
             self._true_image_predictions = [self.predictor(str(image))
                                             for image in self.true_images]
         return self._true_image_predictions

     @property
     def true_positives(self) -&gt; int:
         """count of correct positive predictions"""
         if self._true_positives is None:
             self._true_positives = sum(self.true_image_predictions)
         return self._true_positives

     @property
     def false_positives(self) -&gt; int:
         """Count of incorrect positive predictions"""
         if self._false_positives is None:
             self._false_positives = sum(self.false_image_predictions)
         return self._false_positives

     @property
     def false_negatives(self) -&gt; int:
         """Count of images that were incorrectly classified as negative"""
         if self._false_negatives is None:
             self._false_negatives = len(self.true_images) - self.true_positives
         return self._false_negatives

     @property
     def true_negatives(self) -&gt; int:
         """Count of images that were correctly ignored"""
         if self._true_negatives is None:
             self._true_negatives = len(self.false_images) - self.false_positives
         return self._true_negatives

     @property
     def accuracy(self) -&gt; float:
         """fraction of correct predictions"""
         if self._accuracy is None:
             self._accuracy = (
                 (self.true_positives + self.true_negatives)
                 /(len(self.true_images) + len(self.false_images)))
         return self._accuracy

     @property
     def precision(self) -&gt; float:
         """True-Positive with penalty for false positives"""
         if self._precision is None:
             self._precision = self.true_positives/(
                 self.true_positives + self.false_positives)
         return self._precision

     @property
     def recall(self) -&gt; float:
         """fraction of correct images correctly predicted"""
         if self._recall is None:
             self._recall = (
                 self.true_positives/len(self.true_images))
         return self._recall

     @property
     def false_positive_rate(self) -&gt; float:
         """fraction of incorrect images predicted as positive"""
         if self._false_positive_rate is None:
             self._false_positive_rate = (
                 self.false_positives/len(self.false_images))
         return self._false_positive_rate

     @property
     def specificity(self) -&gt; float:
         """metric for how much to believe a negative prediction

         Specificity is 1 - false positive rate so you only need one or the other
         """
         if self._specificity is None:
             self._specificity = self.true_negatives/(self.true_negatives
                                                      + self.false_positives)
         return self._specificity

     @property
     def f1(self) -&gt; float:
         """Harmonic Mean of the precision and recall"""
         if self._f1 is None:
             TP = 2 * self.true_positives
             self._f1 = (TP)/(TP + self.false_negatives + self.false_positives)
         return self._f1

     def __call__(self) -&gt; None:
         """Emits the F1 and other scores as an org-table
         """
         self.timer.start()
         print("|Metric|Value|")
         print("|-+-|")
         print("|Accuracy|{:.2f}|".format(self.accuracy))
         print("|Precision|{:.2f}|".format(self.precision))
         print("|Recall|{:.2f}|".format(self.recall))
         print("|Specificity|{:.2f}".format(self.specificity))
         # print("|False Positive Rate|{:.2f}|".format(self.false_positive_rate))
         print("|F1|{:.2f}|".format(self.f1))
         self.timer.end()
         print("|Elapsed|{}|".format(self.timer.ended - self.timer.started))
         return
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org06506b5">
<h4 id="org06506b5">Get Human</h4>
<div class="outline-text-4" id="text-org06506b5">
<p>This will grab the name of the person in an image file (based on the file name).</p>
<div class="highlight">
<pre><span></span>def get_name(path: Path) -&gt; str:
    """Extracts the name of the person from the file name

    Args:
     path: path to the file

    Returns:
     the name extracted from the file name
    """
    return " ".join(path.name.split("_")[:-1]).title()
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org2145aa4">
<h4 id="org2145aa4">Display Image</h4>
<div class="outline-text-4" id="text-org2145aa4">
<p>A little matplotlib helper.</p>
<div class="highlight">
<pre><span></span>def display_image(image: Path, title: str, is_file: bool=True) -&gt; tuple:
    """Plot the image

    Args:
     image: path to the image file or image
     title: title for the image
     is_file: first argument is a file name, not an array

    Returns:
     figure, axe
    """
    figure, axe = pyplot.subplots()
    figure.suptitle(title, weight="bold")
    axe.tick_params(dict(axis="both",
                         which="both",
                         bottom=False,
                         top=False))
    axe.get_xaxis().set_ticks([])
    axe.get_yaxis().set_ticks([])
    if is_file:
        image = Image.open(image)
    image = axe.imshow(image)
    return figure, axe
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org99d6ca5">
<h4 id="org99d6ca5">First Prediction</h4>
<div class="outline-text-4" id="text-org99d6ca5">
<p>This function is used to grab images that register as false-positives.</p>
<div class="highlight">
<pre><span></span>def first_prediction(source: list, start:int=0) -&gt; int:
    """Gets the index of the first True prediction

    Args:
     source: list of True/False predictions
     start: index to start the search from

    Returns:
     index of first True prediction found
    """
    for index, prediction in enumerate(source[start:]):
        if prediction:
            print("{}: {}".format(start + index, prediction))
            break
    return start + index
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org8f499c5">
<h3 id="org8f499c5">Some Constants</h3>
<div class="outline-text-3" id="text-org8f499c5">
<p>The pre-trained models need to be normalized using the following means and standard deviations.</p>
<div class="highlight">
<pre><span></span>MEANS = [0.485, 0.456, 0.406]
DEVIATIONS = [0.229, 0.224, 0.225]
</pre></div>
<p>I'm going to offload the models that I move to the GPU while exploring before doing the final implementation so this list is to keep track of all of them.</p>
<div class="highlight">
<pre><span></span>MODELS = []
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgb019b7d">
<h2 id="orgb019b7d">A Human Face Detector</h2>
<div class="outline-text-2" id="text-orgb019b7d">
<p>I'm going to need a way to tell if an image has a human in it (or not), so I'll build two versions of a detector, one using <a href="https://opencv.org/">OpenCV</a>, and one using <a href="http://dlib.net/">dlib</a>.</p>
<p>For each detector I'm going to look at an example image before running an assessment of how well it did so I'll select one at random here.</p>
<div class="highlight">
<pre><span></span>sample_face = numpy.random.choice(human_files, 1)[0]
sample_name = get_name(sample_face)
print(sample_name)
</pre></div>
<pre class="example">
David Anderson
</pre>
<div class="highlight">
<pre><span></span>figure, axe = display_image(sample_face, sample_name)
</pre></div>
<div class="figure" id="org796ca49">
<p><img alt="sample_human.png" src="posts/nano/dog-breed-classifier/dog-breed-classification/sample_human.png"></p>
</div>
</div>
<div class="outline-3" id="outline-container-orgd77c363">
<h3 id="orgd77c363">The Data Sets</h3>
<div class="outline-text-3" id="text-orgd77c363">
<p>To save some time I'm going to assess the detectors using random images from the data sets.</p>
<div class="highlight">
<pre><span></span>count = int(.1 * len(human_files))
human_files_short = numpy.random.choice(human_files, count)
dog_files_short = numpy.random.choice(dog_files, count)
print("{:,}".format(count))
</pre></div>
<pre class="example">
1323
</pre></div>
</div>
<div class="outline-3" id="outline-container-orgf5d593b">
<h3 id="orgf5d593b">The Scorer</h3>
<div class="outline-text-3" id="text-orgf5d593b">
<p>I'm going to re-use the same scorer for the dlib face-detector so to make it simpler I'll attach the correct images to the <code>F1Scorer</code> class.</p>
<div class="highlight">
<pre><span></span>human_scorer = partial(F1Scorer,
                       true_images=human_files_short,
                       false_images=dog_files_short)
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org5957acd">
<h3 id="org5957acd">OpenCV</h3>
<div class="outline-text-3" id="text-org5957acd">
<p>Here I'll use OpenCV's implementation of <a href="http://docs.opencv.org/trunk/d7/d8b/tutorial_py_face_detection.html">Haar feature-based cascade classifiers</a> (which you can grab from <a href="https://github.com/opencv/opencv/tree/master/data/haarcascades">github</a>) to detect human faces in images.</p>
</div>
<div class="outline-4" id="outline-container-org52c7d89">
<h4 id="org52c7d89">Extract the Pre-Trained Face Detector</h4>
<div class="outline-text-4" id="text-org52c7d89">
<p>First I'll grab the path to the XML file that defines the classifier.</p>
<div class="highlight">
<pre><span></span>haar_path = DataPathTwo("haarcascade_frontalface_alt.xml", folder_key="HAAR_CASCADES")
print(haar_path.from_folder)
assert haar_path.from_folder.is_file()
</pre></div>
<pre class="example">
/home/hades/data/datasets/dog-breed-classification/haarcascades/haarcascade_frontalface_alt.xml
</pre>
<p>Now we can load it.</p>
<div class="highlight">
<pre><span></span>face_cascade = cv2.CascadeClassifier(str(haar_path.from_folder))
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org46b8085">
<h4 id="org46b8085">Inspect An Image</h4>
<div class="outline-text-4" id="text-org46b8085">
<p>First let's see what the face detector detects by looking at a single image.</p>
</div>
<ul class="org-ul">
<li><a id="org7530027"></a>Load a Color (BGR) Image<br>
<div class="outline-text-5" id="text-org7530027">
<div class="highlight">
<pre><span></span>image = cv2.imread(str(sample_face))
print(image.shape)
</pre></div>
<pre class="example">
(250, 250, 3)
</pre>
<p>So the image is a 250x250 pixel image with three channels. Since we're loading it with <code>cv2</code> the three channels are Blue, Green, and Red.</p>
</div>
</li>
</ul>
</div>
<div class="outline-4" id="outline-container-org49a9f71">
<h4 id="org49a9f71">Convert the BGR Image To Grayscale</h4>
<div class="outline-text-4" id="text-org49a9f71">
<p>To do the face-detection we need to convert the image to a grayscale image.</p>
<div class="highlight">
<pre><span></span>gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org55de031">
<h4 id="org55de031">Find Some Faces In the Image</h4>
<div class="outline-text-4" id="text-org55de031">
<p>Now we can find the coordinates for bounding boxes for any faces that OpenCV finds in the image.</p>
<div class="highlight">
<pre><span></span>faces = face_cascade.detectMultiScale(gray)
</pre></div>
<div class="highlight">
<pre><span></span>print('Number of faces detected:', len(faces))
</pre></div>
<pre class="example">
Number of faces detected: 1
</pre></div>
</div>
<div class="outline-4" id="outline-container-org39f5034">
<h4 id="org39f5034">Show Us the Box</h4>
<div class="outline-text-4" id="text-org39f5034">
<p>The boxes are defined using a four-tuple with the <i>x</i> and <i>y</i> coordinates of the top-left corner of the box first followed by the width and height of the box. This next block adds the box to the image.</p>
<div class="highlight">
<pre><span></span>for (x,y,w,h) in faces:
    # add bounding box to color image
    cv2.rectangle(image, (x,y), (x+w,y+h), (255,0,0), 2)
</pre></div>
<p>To display the image we need to convert it to RGB.</p>
<div class="highlight">
<pre><span></span>cv_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
</pre></div>
<p>Now we can display the image with the bounding box.</p>
<div class="highlight">
<pre><span></span>figure, axe = display_image(cv_rgb, "OpenCV Face-Detection Bounding Box", False)
</pre></div>
<div class="figure" id="org280d4b3">
<p><img alt="face_bounded.png" src="posts/nano/dog-breed-classifier/dog-breed-classification/face_bounded.png"></p>
</div>
</div>
</div>
<div class="outline-4" id="outline-container-org319cf30">
<h4 id="org319cf30">Write a Human Face Detector</h4>
<div class="outline-text-4" id="text-org319cf30">
<p>Now that we know how it works, we can use the OpenCV face-recognizer to tell us if the image has a human in it (because there will be at least one bounding-box).</p>
<div class="highlight">
<pre><span></span># returns "True" if face is detected in image stored at img_path
def face_detector(image_path: str) -&gt; bool:
    """Detects human faces in an image

    Args:
     image_path: path to the image to check

    Returns:
     True if there was at least one face in the image
    """
    image = cv2.imread(image_path)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    faces = face_cascade.detectMultiScale(gray)
    return len(faces) &gt; 0
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org6778ceb">
<h4 id="org6778ceb">Assess the Human Face Detector</h4>
<div class="outline-text-4" id="text-org6778ceb">
<p>Here I'll check how well the face detector does using an F1 score. I'll also show some other metrics, but F1 is the single-value that I'll be focused on.</p>
<div class="highlight">
<pre><span></span>open_cv_scorer = human_scorer(face_detector)
open_cv_scorer()
</pre></div>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Metric</th>
<th class="org-right" scope="col">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Accuracy</td>
<td class="org-right">0.94</td>
</tr>
<tr>
<td class="org-left">Precision</td>
<td class="org-right">0.90</td>
</tr>
<tr>
<td class="org-left">Recall</td>
<td class="org-right">0.99</td>
</tr>
<tr>
<td class="org-left">Specificity</td>
<td class="org-right">0.89</td>
</tr>
<tr>
<td class="org-left">F1</td>
<td class="org-right">0.94</td>
</tr>
<tr>
<td class="org-left">Elapsed</td>
<td class="org-right">0:02:42.880287</td>
</tr>
</tbody>
</table>
<p>Overall the model seems to have done quite well. It was better at <i>recall</i> than <i>specificity</i> so it tended to classify some dogs as humans (around 11 %).</p>
<div class="highlight">
<pre><span></span>dogman_index = first_prediction(open_cv_scorer.false_image_predictions)
</pre></div>
<pre class="example">
2: True
</pre>
<p>It looks like the third dog image was classified as a human by OpenCV.</p>
<div class="highlight">
<pre><span></span>source = dog_files_short[dogman_index]
name = get_name(source)
figure, axe = display_image(source,
                            "Dog-Human OpenCV Prediction ({})".format(name))
</pre></div>
<div class="figure" id="orgd13e7cc">
<p><img alt="dog_man.png" src="posts/nano/dog-breed-classifier/dog-breed-classification/dog_man.png"></p>
</div>
<p>I guess I can see where this might look like a human face. Maybe.</p>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org9d345a0">
<h3 id="org9d345a0">DLIB</h3>
<div class="outline-text-3" id="text-org9d345a0">
<p>I'm also going to test <a href="https://github.com/ageitgey/face_recognition"><code>face_recognition</code></a>, a python interface to <a href="http://dlib.net/">dlib's</a> facial recognition code. Unlike <code>OpenCV</code>, <code>face_recognition</code> doesn't require you to do the image-conversions before looking for faces.</p>
</div>
<div class="outline-4" id="outline-container-org8d278de">
<h4 id="org8d278de">Inspect an Image</h4>
<div class="outline-text-4" id="text-org8d278de">
<div class="highlight">
<pre><span></span>image = face_recognition.load_image_file(sample_face)
locations = face_recognition.face_locations(image)
image = mpimage.imread(sample_face)
</pre></div>
<div class="highlight">
<pre><span></span>figure, axe = display_image(image, "dlib Face Recognition Bounding-Box", False)
top, right, bottom, left = locations[0]
width = right - left
height = top - bottom
rectangle = patches.Rectangle((top, right), width, height, fill=False)
patch = axe.add_patch(rectangle)
</pre></div>
<div class="figure" id="org438abf1">
<p><img alt="dlib_box.png" src="posts/nano/dog-breed-classifier/dog-breed-classification/dlib_box.png"></p>
</div>
<p>This box seems to be more tightly cropped than the Open CV version.</p>
</div>
</div>
<div class="outline-4" id="outline-container-org610f7f0">
<h4 id="org610f7f0">The Face Detecor</h4>
<div class="outline-text-4" id="text-org610f7f0">
<div class="highlight">
<pre><span></span>def face_recognition_check(image_path: str) -&gt; bool:
    """This decides if an image has a face in it

    Args:
     image_path: path to an image
    Returns:
     True if there's at least one face in the image
    """
    image = face_recognition.load_image_file(str(image_path))
    locations = face_recognition.face_locations(image)
    return len(locations) &gt; 0
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org6e92a3e">
<h4 id="org6e92a3e">Assess the Face Detector</h4>
<div class="outline-text-4" id="text-org6e92a3e">
<div class="highlight">
<pre><span></span>dlib_dog_humans = human_scorer(face_recognition_check)
dlib_dog_humans()
</pre></div>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Metric</th>
<th class="org-right" scope="col">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Accuracy</td>
<td class="org-right">0.95</td>
</tr>
<tr>
<td class="org-left">Precision</td>
<td class="org-right">0.92</td>
</tr>
<tr>
<td class="org-left">Recall</td>
<td class="org-right">1.00</td>
</tr>
<tr>
<td class="org-left">Specificity</td>
<td class="org-right">0.91</td>
</tr>
<tr>
<td class="org-left">F1</td>
<td class="org-right">0.96</td>
</tr>
<tr>
<td class="org-left">Elapsed</td>
<td class="org-right">0:09:28.752909</td>
</tr>
</tbody>
</table>
<p>Dlib took around four times as long to run as OpenCV did, but did better overall.</p>
<div class="highlight">
<pre><span></span>dlib_dog_human_index = first_prediction(dlib_dog_humans.false_image_predictions)
</pre></div>
<pre class="example">
5: True
</pre>
<p>The dlib model didn't have a false positive for the third image like the OpenCV model did, but it did get the sixth image wrong.</p>
<div class="highlight">
<pre><span></span>source = dog_files_short[dlib_dog_human_index]
name = get_name(source)
figure, axe = display_image(source,
                            "Dog-Human DLib Prediction ({})".format(name))
</pre></div>
<div class="figure" id="org9aefd45">
<p><img alt="dlib_dog_man.png" src="posts/nano/dog-breed-classifier/dog-breed-classification/dlib_dog_man.png"></p>
</div>
<p>These photos with humans and dogs in them seem problematic.</p>
<p><code>face_recognition</code> provides another model based on a CNN that I wanted to try but it gives me out-of-memory errors so I'll have to save that for later.</p>
</div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orga7f4688">
<h2 id="orga7f4688">A Dog Detector</h2>
<div class="outline-text-2" id="text-orga7f4688">
<p>Now I'll take two pre-trained CNNs and use <a href="https://en.wikipedia.org/wiki/Transfer_learning">transfer learning</a> to have them detect dogs in images.</p>
</div>
<div class="outline-3" id="outline-container-org1da6447">
<h3 id="org1da6447">A Dog Detector Function</h3>
<div class="outline-text-3" id="text-org1da6447">
<p>If you look at the imagenet <a href="https://gist.github.com/yrevar/942d3a0ac09ec9e5eb3a">dictionary</a>, you'll see that the categories for dogs have indices from 151 to 268, so without altering our models we can check if an image is a dog by seeing if they classify the image within this range of values.</p>
<div class="highlight">
<pre><span></span>DOG_LOWER, DOG_UPPER = 150, 260
</pre></div>
<div class="highlight">
<pre><span></span>def dog_detector(img_path: Path, predictor: object):
    """Predicts if the image is a dog

    Args:
     img_path: path to image file
     predictor: callable that maps the image to an ID

    Returns:
     is-dog: True if the image contains a dog
    """
    return DOG_LOWER &lt; predictor(img_path) &lt; DOG_UPPER
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgfbbf683">
<h3 id="orgfbbf683">The VGG-16 Model</h3>
<div class="outline-text-3" id="text-orgfbbf683">
<p>I'm going to use a VGG-16 model, along with weights that have been trained on <a href="http://www.image-net.org/">ImageNet</a>, a data set containing objects from one of <a href="https://gist.github.com/yrevar/942d3a0ac09ec9e5eb3a">1000 categories</a>.</p>
<p>Pytorch comes with a VGG 16 model built-in so we just have to declare it with the <code>pretrained=True</code> argument to download and load it.</p>
<div class="highlight">
<pre><span></span>timer.start()
VGG16 = models.vgg16(pretrained=True)
VGG16.eval()
VGG16.to(device)
MODELS.append(VGG16)
timer.end()
</pre></div>
<pre class="example">
Started: 2019-01-13 14:43:39.512124
Ended: 2019-01-13 14:44:07.819057
Elapsed: 0:00:28.306933
</pre>
<p><b>Note:</b> The first time you run this it has to download the state dictionary so it will take much longer than it would once you've run it at least once.</p>
</div>
<div class="outline-4" id="outline-container-org7c6aad8">
<h4 id="org7c6aad8">Making Predictions With the VGG 16 Model</h4>
<div class="outline-text-4" id="text-org7c6aad8">
<p>In order to use the images with our model we have to run them through a transform. Even then, the forward-pass expects you to pass it a batch, not a single image, so you have to add an extra (fourth) dimension to the images to represent the batch. I found out how to fix the dimensions (using <a href="https://pytorch.org/docs/stable/tensors.html?highlight=unsqueeze#torch.Tensor.unsqueeze">unsqueeze</a> to add an empty dimension) from <a href="http://blog.outcome.io/pytorch-quick-start-classifying-an-image/">this blog post</a>.</p>
<p>This next block sets up the transforms. Each pre-trained model expects a specific image-size for the inputs. In this case the <code>VGG16</code> model expects a 224 x 224 image (which is why I set the <code>IMAGE_SIZE</code> to 224).</p>
<p>The images also have to be normalized using a specific set of means and standard deviations, but since pytorch uses the same ones for all the models I defined them at the top of this document because I'll be using them later for the inception model as well.</p>
<div class="highlight">
<pre><span></span>IMAGE_SIZE = 224
IMAGE_HALF_SIZE = IMAGE_SIZE//2

vgg_transform = transforms.Compose([transforms.Resize(255),
                                    transforms.CenterCrop(IMAGE_SIZE),
                                    transforms.ToTensor(),
                                    transforms.Normalize(MEANS,
                                                         DEVIATIONS)])
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org6a16b9e">
<h4 id="org6a16b9e">VGG16 Predict</h4>
<div class="outline-text-4" id="text-org6a16b9e">
<p>This is a function to predict what class an image is.</p>
<div class="highlight">
<pre><span></span>def VGG16_predict(img_path: str) -&gt; int:
    '''
    Uses a pre-trained VGG-16 model to obtain the index corresponding to 
    predicted ImageNet class for image at specified path

    Args:
        img_path: path to an image

    Returns:
        Index corresponding to VGG-16 model's prediction
    '''
    image = Image.open(str(img_path))
    image = vgg_transform(image).unsqueeze(0).to(device)
    output = VGG16(image)
    probabilities = torch.exp(output)
    top_probability, top_class = probabilities.topk(1, dim=1)
    return top_class.item()
</pre></div>
<p>Let's see what the model predicts for an image.</p>
<div class="highlight">
<pre><span></span>path = numpy.random.choice(dog_files_short)
print(path)
classification = VGG16_predict(path)
print(imagenet[classification])
</pre></div>
<pre class="example">
/home/hades/data/datasets/dog-breed-classification/dogImages/valid/044.Cane_corso/Cane_corso_03122.jpg
American Staffordshire terrier, Staffordshire terrier, American pit bull terrier, pit bull terrier
</pre>
<p>Our classifier recognizes that the image is a dog, but thinks that it's a Terrire, not a Cane Corso. Here's what it saw.</p>
<div class="highlight">
<pre><span></span>name = get_name(path)
figure, axe = display_image(path, name)
</pre></div>
<div class="figure" id="org4df39a3">
<p><img alt="vgg_misclassified.png" src="posts/nano/dog-breed-classifier/dog-breed-classification/vgg_misclassified.png"></p>
</div>
<p>And this is what it thought it was (a bull-mastiff).</p>
<div class="figure" id="org2b5930a">
<p><img alt="american_staffordshire_terrier.jpg" src="posts/nano/dog-breed-classifier/dog-breed-classification/american_staffordshire_terrier.jpg"></p>
</div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org84fde7f">
<h3 id="org84fde7f">Assess the Dog Detector</h3>
<div class="outline-text-3" id="text-org84fde7f">
<p>Now, as with the human face-detectors, I'll calculate some metrics to see how the VGG16 dog-detector does.</p>
<div class="highlight">
<pre><span></span>dog_scorer = partial(F1Scorer, true_images=dog_files_short,
                     false_images=human_files_short)
vgg_predictor = partial(dog_detector, predictor=VGG16_predict)
</pre></div>
<div class="highlight">
<pre><span></span> vgg_scorer = dog_scorer(vgg_predictor)
 vgg_scorer()
</pre></div>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Metric</th>
<th class="org-right" scope="col">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Accuracy</td>
<td class="org-right">0.95</td>
</tr>
<tr>
<td class="org-left">Precision</td>
<td class="org-right">0.99</td>
</tr>
<tr>
<td class="org-left">Recall</td>
<td class="org-right">0.92</td>
</tr>
<tr>
<td class="org-left">Specificity</td>
<td class="org-right">0.99</td>
</tr>
<tr>
<td class="org-left">F1</td>
<td class="org-right">0.95</td>
</tr>
<tr>
<td class="org-left">Elapsed</td>
<td class="org-right">0:02:37.257690</td>
</tr>
</tbody>
</table>
<p>Unlike the face-detectors, the VGG16 dog detector did better at avoiding false-positives than it did at detecting dogs.</p>
</div>
</div>
<div class="outline-3" id="outline-container-org0ecf180">
<h3 id="org0ecf180">Inception</h3>
<div class="outline-text-3" id="text-org0ecf180">
<p>The previous detector used the VGG 16 model, but now I'll try the <a href="http://pytorch.org/docs/master/torchvision/models.html#inception-v3">Inception-v3</a> model, which was designed to use less resources than the VGG model, to do some dog-detection.</p>
<div class="highlight">
<pre><span></span> timer.start()
 inception = models.inception_v3(pretrained=True)
 inception.to(device)
 inception.eval()
 MODELS.append(inception)
 timer.end()
</pre></div>
<pre class="example">
Started: 2019-01-13 18:45:27.709998
Ended: 2019-01-13 18:45:31.775443
Elapsed: 0:00:04.065445
</pre></div>
<div class="outline-4" id="outline-container-orge6bd956">
<h4 id="orge6bd956">Making a Prediction</h4>
<div class="outline-text-4" id="text-orge6bd956">
<p>This was my original dog detector using the Inception model, but when I tried it out it raised an error. See the next section for more information and the fix.</p>
<div class="highlight">
<pre><span></span> def inception_predicts(image_path: str) -&gt; int:
     """Predicts the category of the image

     Args:
      image_path: path to the image file

     Returns:
      classification: the resnet ID for the image
     """
     image = Image.open(str(image_path))
     image = vgg_transform(image).unsqueeze(0).to(device)
     output = inception(image)
     probabilities = torch.exp(output)
     top_probability, top_class = probabilities.topk(1, dim=1)
     return top_class.item()
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orge9571bd">
<h4 id="orge9571bd">Troubleshooting the Error</h4>
<div class="outline-text-4" id="text-orge9571bd">
<p>The <code>inception_predicts</code> is throwing a Runtime Error saying that the sizes must be non-negative. I'll grab a file here to check it out.</p>
<div class="highlight">
<pre><span></span> for path in dog_files_short:
     try:
         prediction = inception_predicts(path)
     except RuntimeError as error:
         print(error)
         print(path)
         break
</pre></div>
<pre class="example">
Given input size: (2048x5x5). Calculated output size: (2048x0x0). Output size is too small at /pytorch/aten/src/THCUNN/generic/SpatialAveragePooling.cu:63
/home/hades/data/datasets/dog-breed-classification/dogImages/valid/044.Cane_corso/Cane_corso_03122.jpg
</pre>
<p>So this dog raised an error, let's see what it looks like.</p>
<div class="highlight">
<pre><span></span> name = get_name(path)
 figure, axe = display_image(path, "Error-Producing Image ({})".format(name))
</pre></div>
<div class="figure" id="org8f1d33d">
<p><img alt="inception_error.png" src="posts/nano/dog-breed-classifier/dog-breed-classification/inception_error.png"></p>
</div>
</div>
<ul class="org-ul">
<li><a id="orgbfbae5c"></a>Why did this raise an error?<br>
<div class="outline-text-5" id="text-orgbfbae5c">
<p>I couldn't find anyplace where pytorch documents it, but if you look at <a href="https://pytorch.org/docs/stable/_modules/torchvision/models/inception.html#inception_v3">the source code</a> you can see that they are expecting an image size of 299 pixels, so we need a diferent transform from that used by the VGG model.</p>
<div class="highlight">
<pre><span></span> INCEPTION_IMAGE_SIZE = 299
 inception_transforms = transforms.Compose([
     transforms.Resize(INCEPTION_IMAGE_SIZE),
     transforms.CenterCrop(INCEPTION_IMAGE_SIZE),
     transforms.ToTensor(),
     transforms.Normalize(MEANS,
                          DEVIATIONS)])
</pre></div>
<p>Now try it again with the new transforms.</p>
<div class="highlight">
<pre><span></span>def inception_predicts_two(image_path: str) -&gt; int:
    """Predicts the category of the image

    Args:
     image_path: path to the image file

    Returns:
     classification: the resnet ID for the image
    """
    image = Image.open(str(image_path))
    image = inception_transforms(image).unsqueeze(0).to(device)
    output = inception(image)
    probabilities = torch.exp(output)
    top_probability, top_class = probabilities.topk(1, dim=1)
    return top_class.item()
</pre></div>
<p>Does this fix it?</p>
</div>
</li>
</ul>
</div>
<div class="outline-4" id="outline-container-orga1ed93d">
<h4 id="orga1ed93d">The Score</h4>
<div class="outline-text-4" id="text-orga1ed93d">
<div class="highlight">
<pre><span></span>inception_predictor = partial(dog_detector, predictor=inception_predicts_two)
inception_scorer = dog_scorer(inception_predictor)
inception_scorer()
</pre></div>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Metric</th>
<th class="org-right" scope="col">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Accuracy</td>
<td class="org-right">0.95</td>
</tr>
<tr>
<td class="org-left">Precision</td>
<td class="org-right">0.99</td>
</tr>
<tr>
<td class="org-left">Recall</td>
<td class="org-right">0.91</td>
</tr>
<tr>
<td class="org-left">Specificity</td>
<td class="org-right">0.99</td>
</tr>
<tr>
<td class="org-left">F1</td>
<td class="org-right">0.95</td>
</tr>
<tr>
<td class="org-left">Elapsed</td>
<td class="org-right">0:03:00.836240</td>
</tr>
</tbody>
</table>
<p>The inception had a little more false positives but also more true positives so in the end it came up about the same on the F1 score as the VGG 16 model. They both took about the same amount of time.</p>
<div class="highlight">
<pre><span></span>inception_human_dog = first_prediction(inception_scorer.false_image_predictions)
</pre></div>
<pre class="example">
34: True
</pre>
<div class="highlight">
<pre><span></span>figure, axe = pyplot.subplots()
source = human_files_short[inception_human_dog]
name = " ".join(
    os.path.splitext(
        os.path.basename(source))[0].split("_")[:-1]).title()
figure.suptitle("Human-Dog Inception Prediction ({})".format(
    name), weight="bold")
image = Image.open(source)
image = axe.imshow(image)
</pre></div>
<div class="figure" id="orgb146716">
<p><img alt="inception_man_dog.png" src="posts/nano/dog-breed-classifier/dog-breed-classification/inception_man_dog.png"></p>
</div>
</div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgfcf95c1">
<h2 id="orgfcf95c1">Combine The Detectors</h2>
<div class="outline-text-2" id="text-orgfcf95c1">
<p>Since jupyter (or org-babel) lets you run cells out of sequence I've spent too much time chasing bugs that weren't really bugs, I just hadn't run the right cell. To try and ameliorate that I'm going to use class-based code for the actual implementations.</p>
</div>
<div class="outline-3" id="outline-container-org84f1089">
<h3 id="org84f1089">The Dog Detector</h3>
<div class="outline-text-3" id="text-org84f1089">
<p>The Dog Detector builds the parts of the deep learning model that are needed to check if there are dogs in the image.</p>
<div class="highlight">
<pre><span></span>class DogDetector:
    """Detects dogs

    Args:
     model_definition: definition for the model
     device: where to run the model (CPU or CUDA)
     image_size: what to resize the file to (depends on the model-definition)
     means: mean for each channel
     deviations: standard deviation for each channel
     dog_lower_bound: index below where dogs start
     dog_upper_bound: index above where dogs end
    """
    def __init__(self,
                 model_definition: nn.Module=models.inception_v3,
                 image_size: int=INCEPTION_IMAGE_SIZE,
                 means: list=MEANS,
                 deviations = DEVIATIONS,
                 dog_lower_bound: int=DOG_LOWER,
                 dog_upper_bound: int=DOG_UPPER,
                 device: torch.device=None) -&gt; None:
        self.model_definition = model_definition
        self.image_size = image_size
        self.means = means
        self.deviations = deviations
        self.dog_lower_bound = dog_lower_bound
        self.dog_upper_bound = dog_upper_bound
        self._device = device
        self._model = None
        self._transform = None
        return

    @property
    def device(self) -&gt; torch.device:
        """The device to add the model to"""
        if self._device is None:
            self._device = torch.device("cuda"
                                        if torch.cuda.is_available()
                                        else "cpu")
        return self._device

    @property
    def model(self) -&gt; nn.Module:
        """Build the model"""
        if self._model is None:
            self._model = self.model_definition(pretrained=True)
            self._model.to(self.device)
            self._model.eval()
        return self._model

    @property
    def transform(self) -&gt; transforms.Compose:
        """The transformer for the image data"""
        if self._transform is None:
            self._transform = transforms.Compose([
                transforms.Resize(self.image_size),
                transforms.CenterCrop(self.image_size),
                transforms.ToTensor(),
                transforms.Normalize(self.means,
                                     self.deviations)])
        return self._transform

    def __call__(self, image_path: str) -&gt; bool:
        """Checks if there is a dog in the image"""
        image = Image.open(str(image_path))
        image = self.transform(image).unsqueeze(0).to(self.device)
        output = self.model(image)
        probabilities = torch.exp(output)
        _, top_class = probabilities.topk(1, dim=1)
        return self.dog_lower_bound &lt; top_class.item() &lt; self.dog_upper_bound
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org755eb06">
<h3 id="org755eb06">The Species Detector</h3>
<div class="outline-text-3" id="text-org755eb06">
<p>The Species Detector holds the human and dog detectors.</p>
<div class="highlight">
<pre><span></span>class SpeciesDetector:
    """Detect dogs and humans

    Args:
     device: where to put the dog-detecting model
    """
    def __init__(self, device: torch.device=None) -&gt; None:
        self.device = device
        self._dog_detector = None
        return

    @property
    def dog_detector(self) -&gt; DogDetector:
        """Neural Network dog-detector"""
        if self._dog_detector is None:
            self._dog_detector = DogDetector(device=self.device)
        return self._dog_detector

    def is_human(self, image_path: str) -&gt; bool:
        """Checks if the image is a human

        Args:
         image_path: path to the image

        Returns:
         True if there is a human face in the image
        """
        image = face_recognition.load_image_file(str(image_path))
        faces = face_recognition.face_locations(image)
        return len(faces) &gt; 0

    def is_dog(self, image_path: str) -&gt; bool:        
        """Checks if there is a dog in the image"""
        return self.dog_detector(image_path)
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgc171a62">
<h2 id="orgc171a62">A Dog Breed Classifier</h2>
<div class="outline-text-2" id="text-orgc171a62">
<p>Although the Inception model does do some classification of dogs, we want an even more fine-tuned model. First I'm going to try to build a naive CNN from scratch, then I'm going to use the Inception model and transfer learning to build a better classifier.</p>
</div>
<div class="outline-3" id="outline-container-orgda38ec8">
<h3 id="orgda38ec8">A Naive Model</h3>
<div class="outline-text-3" id="text-orgda38ec8"></div>
<div class="outline-4" id="outline-container-org49ca445">
<h4 id="org49ca445">The Data Transformers</h4>
<div class="outline-text-4" id="text-org49ca445">
<p>For the naive model I'm going to use the image-size the VGG model uses (<a href="https://arxiv.org/abs/1409.1556">the original VGG paper</a> describes the input as being 224 x 224). No particular reason except I've worked with that size before so I think it might make troubleshooting a little easier. The <code>Resize</code> transform scales the image so that the smaller edge matches the size we give it. I found out the hard way that not all the input images are square so we need to then crop them back to the right size after scaling.</p>
<p>Here's the training tranforms:</p>
<ul class="org-ul">
<li><a href="https://pytorch.org/docs/stable/torchvision/transforms.html#torchvision.transforms.RandomRotation">RandomRotation</a></li>
<li><a href="https://pytorch.org/docs/stable/torchvision/transforms.html#torchvision.transforms.RandomResizedCrop">RandomResizedCrop</a></li>
<li><a href="https://pytorch.org/docs/stable/torchvision/transforms.html#torchvision.transforms.RandomHorizontalFlip">RandomHorizontalFlip</a></li>
</ul>
<p>For testing and using:</p>
<ul class="org-ul">
<li><a href="https://pytorch.org/docs/stable/torchvision/transforms.html#torchvision.transforms.Resize">Resize</a></li>
<li><a href="https://pytorch.org/docs/stable/torchvision/transforms.html#torchvision.transforms.CenterCrop">CenterCrop</a></li>
</ul>
<p>For both:</p>
<ul class="org-ul">
<li><a href="https://pytorch.org/docs/stable/torchvision/transforms.html#torchvision.transforms.ToTensor">ToTensor</a></li>
<li><a href="https://pytorch.org/docs/stable/torchvision/transforms.html#torchvision.transforms.Normalize">Normalize</a></li>
</ul>
<div class="highlight">
<pre><span></span>IMAGE_SIZE = 224
IMAGE_HALF_SIZE = IMAGE_SIZE//2

train_transform = transforms.Compose([
    transforms.RandomRotation(30),
    transforms.RandomResizedCrop(IMAGE_SIZE),
    transforms.RandomHorizontalFlip(),
    transforms.ToTensor(),
    transforms.Normalize(MEANS,
                         DEVIATIONS)])

test_transform = transforms.Compose([transforms.Resize(255),
                                      transforms.CenterCrop(IMAGE_SIZE),
                                      transforms.ToTensor(),
                                      transforms.Normalize(MEANS,
                                                           DEVIATIONS)])
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org6a7f938">
<h4 id="org6a7f938">Load the Data</h4>
<div class="outline-text-4" id="text-org6a7f938">
<div class="highlight">
<pre><span></span>training = datasets.ImageFolder(root=str(dog_paths.training.folder),
                                transform=train_transform)
validation = datasets.ImageFolder(root=str(dog_paths.validation.folder),
                                  transform=test_transform)
testing = datasets.ImageFolder(root=str(dog_paths.testing.folder),
                               transform=test_transform)
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org07b5f0d">
<h4 id="org07b5f0d">Build the Batch Loaders</h4>
<div class="outline-text-4" id="text-org07b5f0d">
<div class="highlight">
<pre><span></span>BATCH_SIZE = 35
WORKERS = 0

train_batches = torch.utils.data.DataLoader(training, batch_size=BATCH_SIZE,
                                            shuffle=True, num_workers=WORKERS)
validation_batches = torch.utils.data.DataLoader(
    validation, batch_size=BATCH_SIZE, shuffle=True, num_workers=WORKERS)
test_batches = torch.utils.data.DataLoader(
    testing, batch_size=BATCH_SIZE, shuffle=True, num_workers=WORKERS)

loaders_scratch = dict(train=train_batches,
                       validate=validation_batches,
                       test=test_batches)
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgd2c39a0">
<h4 id="orgd2c39a0">The Network</h4>
<div class="outline-text-4" id="text-orgd2c39a0">
<p>This is only going to be a three-layer model. I started out trying to make a really big one but between the computation time and running out of memory I decided to limit the scope since the transfer model is the real one I want anyway, this is just for practice. The first block defines the parameters for the network.</p>
<div class="highlight">
<pre><span></span>LAYER_ONE_OUT = 16
LAYER_TWO_OUT = LAYER_ONE_OUT * 2
LAYER_THREE_OUT = LAYER_TWO_OUT * 2

KERNEL = 3
PADDING = 1
FULLY_CONNECTED_OUT = 500
</pre></div>
<p>This next block does one pass through what the network is going to be doing so I can make sure the inputs and outputs are the correct size.</p>
<div class="highlight">
<pre><span></span>conv_1 = nn.Conv2d(3, LAYER_ONE_OUT, KERNEL, padding=PADDING)
conv_2 = nn.Conv2d(LAYER_ONE_OUT, LAYER_TWO_OUT, KERNEL, padding=PADDING)
conv_3 = nn.Conv2d(LAYER_TWO_OUT, LAYER_THREE_OUT, KERNEL, padding=PADDING)

pool = nn.MaxPool2d(2, 2)
dropout = nn.Dropout(0.25)

fully_connected_1 = nn.Linear((IMAGE_HALF_SIZE//4)**2 * LAYER_THREE_OUT, FULLY_CONNECTED_OUT)
fully_connected_2 = nn.Linear(FULLY_CONNECTED_OUT, dog_paths.breed_count)

dataiter = iter(loaders_scratch['train'])
images, labels = dataiter.next()

x = pool(F.relu(conv_1(images)))
print(x.shape)
assert x.shape == torch.Size([BATCH_SIZE, 16, IMAGE_HALF_SIZE, IMAGE_HALF_SIZE])

x = pool(F.relu(conv_2(x)))
print(x.shape)
assert x.shape == torch.Size([BATCH_SIZE, LAYER_TWO_OUT, IMAGE_HALF_SIZE//2, IMAGE_HALF_SIZE//2])

x = pool(F.relu(conv_3(x)))
print(x.shape)
assert x.shape == torch.Size([BATCH_SIZE, LAYER_THREE_OUT, IMAGE_HALF_SIZE//4, IMAGE_HALF_SIZE//4])

x = x.view(-1, ((IMAGE_HALF_SIZE//4)**2) * LAYER_THREE_OUT)
print(x.shape)
x = fully_connected_1(x)
print(x.shape)
x = fully_connected_2(x)
print(x.shape)
</pre></div>
<pre class="example">
torch.Size([10, 16, 112, 112])
torch.Size([10, 32, 56, 56])
torch.Size([10, 64, 28, 28])
torch.Size([10, 50176])
torch.Size([10, 500])
torch.Size([10, 133])
</pre></div>
</div>
<div class="outline-4" id="outline-container-org2429ba8">
<h4 id="org2429ba8">The Class</h4>
<div class="outline-text-4" id="text-org2429ba8">
<p>This is the actual implementation based on the previous code.</p>
<div class="highlight">
<pre><span></span>class NaiveNet(nn.Module):
    """Naive Neural Network to classify dog breeds"""
    def __init__(self) -&gt; None:
        super().__init__()
        self.conv1 = nn.Conv2d(3, LAYER_ONE_OUT,
                               KERNEL, padding=PADDING)
        self.conv2 = nn.Conv2d(LAYER_ONE_OUT, LAYER_TWO_OUT,
                               KERNEL, padding=PADDING)
        self.conv3 = nn.Conv2d(LAYER_TWO_OUT, LAYER_THREE_OUT,
                               KERNEL, padding=PADDING)
        # max pooling layer
        self.pool = nn.MaxPool2d(2, 2)
        # linear layer
        self.fc1 = nn.Linear((IMAGE_HALF_SIZE//4)**2 * LAYER_THREE_OUT, FULLY_CONNECTED_OUT)
        self.fc2 = nn.Linear(FULLY_CONNECTED_OUT, BREEDS)
        # dropout layer (p=0.25)
        self.dropout = nn.Dropout(0.25)
        return


    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:
        """The forward pass method

        Args:
         x: a n x 224 x 224 x 3 tensor

        Returns:
         tensor of probabilities
        """
        x = self.pool(F.relu(self.conv1(x)))
        x = self.pool(F.relu(self.conv2(x)))
        x = self.pool(F.relu(self.conv3(x)))

        x = x.view(-1, (IMAGE_HALF_SIZE//4)**2 * LAYER_THREE_OUT)
        x = self.dropout(x)

        x = self.dropout(F.relu(self.fc1(x)))
        x = self.fc2(x)        
        return x
</pre></div>
<div class="highlight">
<pre><span></span>naive_model = NaiveNet()
naive_model.to(device)
MODELS.append(naive_model)
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org687d12c">
<h4 id="org687d12c">The Loss Function and Optimizer</h4>
<div class="outline-text-4" id="text-org687d12c">
<p>For loss measurement I'm going to use <a href="https://pytorch.org/docs/stable/nn.html#torch.nn.CrossEntropyLoss">Cross Entropy Loss</a> and <a href="https://pytorch.org/docs/stable/optim.html#torch.optim.SGD">Stochastic Gradient Descent</a> for backward propagation.</p>
<div class="highlight">
<pre><span></span>criterion_scratch = nn.CrossEntropyLoss()
</pre></div>
<div class="highlight">
<pre><span></span>optimizer_scratch = optimizer.SGD(naive_model.parameters(),
                                  lr=0.001,
                                  momentum=0.9)
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orge363219">
<h4 id="orge363219">Train and Validate the Model</h4>
<div class="outline-text-4" id="text-orge363219"></div>
<ul class="org-ul">
<li><a id="org5bc7ccc"></a>The Trainer<br>
<div class="outline-text-5" id="text-org5bc7ccc">
<p>Another class to try and get everything bundled into one place.</p>
<div class="highlight">
<pre><span></span>class Trainer:
    """Trains, validates, and tests the model

    Args:
     training_batches: batch-loaders for training
     validation_batches: batch-loaders for validation
     testing_batches: batch-loaders for testing
     model: the network to train
     model_path: where to save the best model
     optimizer: the gradient descent object
     criterion: object to do backwards propagation
     device: where to put the data (cuda or cpu)
     epochs: number of times to train on the data set
     epoch_start: number to start the epoch count with
     load_model: whether to load the model from a file
     beep: whether timer should emit sounds
     is_inception: expecte two outputs in training
    """
    def __init__(self,
                 training_batches: torch.utils.data.DataLoader,
                 validation_batches: torch.utils.data.DataLoader,
                 testing_batches: torch.utils.data.DataLoader,
                 model: nn.Module,
                 model_path: Path,
                 optimizer: optimizer.SGD,
                 criterion: nn.CrossEntropyLoss,
                 device: torch.device=None,
                 epochs: int=10,
                 epoch_start: int=1,
                 is_inception: bool=False,
                 load_model: bool=False,
                 beep: bool=False) -&gt; None:
        self.training_batches = training_batches
        self.validation_batches = validation_batches
        self.testing_batches = testing_batches
        self.model = model
        self.model_path = model_path
        self.optimizer = optimizer
        self.criterion = criterion
        self.epochs = epochs
        self.is_inception = is_inception
        self.beep = beep
        self._epoch_start = None
        self.epoch_start = epoch_start
        self.load_model = load_model
        self._timer = None
        self._epoch_end = None
        self._device = device
        return

    @property
    def epoch_start(self) -&gt; int:
        """The number to start the epoch count"""
        return self._epoch_start

    @epoch_start.setter
    def epoch_start(self, new_start: int) -&gt; None:
        """Sets the epoch start, removes the epoch end"""
        self._epoch_start = new_start
        self._epoch_end = None
        return

    @property
    def device(self) -&gt; torch.device:
        """The device to put the data on"""
        if self._device is None:
            self._device = torch.device("cuda" if torch.cuda.is_available()
                                        else "cpu")
        return self._device

    @property
    def epoch_end(self) -&gt; int:
        """the end of the epochs (not inclusive)"""
        if self._epoch_end is None:
            self._epoch_end = self.epoch_start + self.epochs
        return self._epoch_end

    @property
    def timer(self) -&gt; Timer:
        """something to emit times"""
        if self._timer is None:
            self._timer = Timer(beep=self.beep)
        return self._timer

    def forward(self, batches: torch.utils.data.DataLoader,
                training: bool) -&gt; tuple:
        """runs the forward pass

        Args:
         batches: data-loader
         training: if true, runs the training, otherwise validates
        Returns:
         tuple: loss, correct, total
        """
        forward_loss = 0
        correct = 0

        if training:
            self.model.train()
        else:
            self.model.eval()
        for data, target in batches:
            data, target = data.to(self.device), target.to(self.device)
            if training:
                self.optimizer.zero_grad()
            if training and self.is_inception:
                # throw away the auxiliary output
                output, _ = self.model(data)
            output = self.model(data)
            loss = self.criterion(output, target)
            if training:
                loss.backward()
                self.optimizer.step()
            forward_loss += loss.item() * data.size(0)

            predictions = output.data.max(1, keepdim=True)[1]
            correct += numpy.sum(
                numpy.squeeze(
                    predictions.eq(
                        target.data.view_as(predictions))).cpu().numpy())
        forward_loss /= len(batches.dataset)
        return forward_loss, correct, len(batches.dataset)

    def train(self) -&gt; tuple:
        """Runs the training

        Returns:
         training loss, correct, count
        """
        return self.forward(batches=self.training_batches, training=True)

    def validate(self) -&gt; tuple:
        """Runs the validation

        Returns:
         validation loss, correct, count
        """
        return self.forward(batches=self.validation_batches, training=False)

    def test(self) -&gt; None:
        """Runs the testing

        """
        self.timer.start()
        self.model.load_state_dict(torch.load(self.model_path))
        loss, correct, total = self.forward(batches=self.testing_batches,
                                            training=False)
        print("Test Loss: {:.3f}".format(loss))
        print("Test Accuracy: {:.2f} ({}/{})".format(100 * correct/total,
                                                     correct, total))
        self.timer.end()
        return

    def train_and_validate(self):
        """Trains and Validates the model
        """
        validation_loss_min = numpy.Inf
        for epoch in range(self.epoch_start, self.epoch_end):
            self.timer.start()
            training_loss, training_correct, training_count = self.train()
            (validation_loss, validation_correct,
             validation_count) = self.validate()
            self.timer.end()
            print(("Epoch: {}\t"
                   "Training - Loss: {:.2f}\t"
                   "Accuracy: {:.2f}\t"
                   "Validation - Loss: {:.2f}\t"
                   "Accuracy: {:.2f}").format(
                       epoch,
                       training_loss,
                       training_correct/training_count,
                       validation_loss,
                       validation_correct/validation_count,
                ))

            if validation_loss &lt; validation_loss_min:
                print(
                    ("Validation loss decreased ({:.6f} --&gt; {:.6f}). "
                     "Saving model ...").format(
                         validation_loss_min,
                         validation_loss))
                torch.save(self.model.state_dict(), self.model_path)
                validation_loss_min = validation_loss
        return

    def __call__(self) -&gt; None:
        """Trains, Validates, and Tests the model"""
        if self.load_model and self.model_path.is_file():
            self.model.load_state_dict(torch.load(self.model_path))
        print("Starting Training")
        self.timer.start()
        self.train_and_validate()
        self.timer.end()
        print("\nStarting Testing")
        self.test()
        return
</pre></div>
</div>
</li>
</ul>
</div>
<div class="outline-4" id="outline-container-org26d95d0">
<h4 id="org26d95d0">Broken Images</h4>
<div class="outline-text-4" id="text-org26d95d0">
<p>I noted at the beginning of the notebook that at least one of the images is raising an OSError:</p>
<div class="highlight">
<pre><span></span><span class="ne">OSError</span><span class="p">:</span> <span class="n">image</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">truncated</span> <span class="p">(</span><span class="mi">150</span> <span class="nb">bytes</span> <span class="ow">not</span> <span class="n">processed</span><span class="p">)</span>
</pre></div>
<p>This is the part of the notebook where I originally found out what was going on (because it kept crashing during training).</p>
<div class="highlight">
<pre><span></span>timer.start()
broken = None
for image in dog_files:
    try:
        opened = Image.open(image)
        opened.convert("RGB")
    except OSError as error:
        print("{}: {}".format(error, image))
        broken = image
timer.end()
</pre></div>
<pre class="example">
image file is truncated (150 bytes not processed): /home/hades/datasets/dog-breed-classification/dogImages/train/098.Leonberger/Leonberger_06571.jpg
Ended: 2018-12-30 15:10:19.141003
Elapsed: 0:02:29.804925
</pre>
<div class="highlight">
<pre><span></span>figure, axe = pyplot.subplots()
name = " ".join(broken.name.split("_")[:-1]).title()
figure.suptitle("Truncated Image ({})".format(name), weight="bold")
image = Image.open(broken)
axe_image = axe.imshow(image)
</pre></div>
<div class="figure" id="org21df474">
<p><img alt="truncated_dog.png" src="posts/nano/dog-breed-classifier/dog-breed-classification/truncated_dog.png"></p>
</div>
<p>I got the solution from <a href="https://stackoverflow.com/questions/12984426/python-pil-ioerror-image-file-truncated-with-big-images">this Stack Overflow post</a>, I don't know why but the image seems to be missing some pixels or something. Oh, well. The key to making it work:</p>
<div class="highlight">
<pre><span></span><span class="n">ImageFile</span><span class="o">.</span><span class="n">LOAD_TRUNCATED_IMAGES</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgfe73f87">
<h4 id="orgfe73f87">Train the Model</h4>
<div class="outline-text-4" id="text-orgfe73f87">
<div class="highlight">
<pre><span></span>NAIVE_PATH = MODEL_PATH.folder.joinpath("model_scratch.pt")
scratch_log = Tee(log_name="scratch_train.log")
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org0df6d2a">
<h4 id="org0df6d2a">Test the Model</h4>
<div class="outline-text-4" id="text-org0df6d2a">
<div class="highlight">
<pre><span></span>def test(test_batches: torch.utils.data.DataLoader,
         model: nn.Module,
         criterion: nn.CrossEntropyLoss) -&gt; None:
    """Test the model

    Args:
     test_batches: batch loader of test images
     model: the network to test
     criterion: calculator for the loss
    """
    test_loss = 0.
    correct = 0.
    total = 0.

    model.eval()
    for data, target in test_batches:
        data, target = data.to(device), target.to(device)
        output = model(data)
        loss = criterion(output, target)
        test_loss += loss.item() * data.size(0)
        # convert output probabilities to predicted class
        predictions = output.data.max(1, keepdim=True)[1]
        # compare predictions to true label
        correct += numpy.sum(
            numpy.squeeze(
                predictions.eq(
                    target.data.view_as(predictions))).cpu().numpy())
        total += data.size(0)
    test_loss /= len(test_batches.dataset)
    print('Test Loss: {:.6f}\n'.format(test_loss))
    print('\nTest Accuracy: %2d%% (%2d/%2d)' % (
        100. * correct / total, correct, total))
    return
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orgbdd0c31">
<h3 id="orgbdd0c31">Train and Test</h3>
<div class="outline-text-3" id="text-orgbdd0c31">
<div class="highlight">
<pre><span></span>def train_and_test(train_batches: torch.utils.data.DataLoader,
                   validate_batches: torch.utils.data.DataLoader,
                   test_batches: torch.utils.data.DataLoader,
                   model: nn.Module,
                   model_path: Path,
                   optimizer: optimizer.SGD,
                   criterion: nn.CrossEntropyLoss,
                   epochs: int=10,
                   epoch_start: int=1,
                   load_model: bool=False) -&gt; None:
    """Trains and Tests the Model

    Args:
     train_batches: batch-loaders for training
     validate_batches: batch-loaders for validation
     test_batches: batch-loaders for testing
     model: the network to train
     model_path: where to save the best model
     optimizer: the gradient descent object
     criterion: object to do backwards propagation
     epochs: number of times to train on the data set
     epoch_start: number to start the epoch count with
     load_model: whether to load the model from a file
    """
    if load_model and model_path.is_file():
        model.load_state_dict(torch.load(model_path))
    print("Starting Training")
    timer.start()
    model_scratch = train(epochs=epochs,
                          epoch_start=epoch_start,
                          train_batches=train_batches,
                          validation_batches=validate_batches,
                          model=model,
                          optimizer=optimizer, 
                          criterion=criterion,
                          save_path=model_path)
    timer.end()
    # load the best model
    model.load_state_dict(torch.load(model_path))
    print("Starting Testing")
    timer.start()
    test(test_batches, model, criterion)
    timer.end()
    return
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org7a081cc">
<h3 id="org7a081cc">Train the Model</h3>
<div class="outline-text-3" id="text-org7a081cc">
<p>When I originally wrote this I was using this functional-style of training and testing, which was hard to use, but since it's so expensive to train the model (in terms of time, and to some degree server cost) I'm not going to re-do it so the code here looks a little different from the one I used for the transfer model.</p>
<div class="highlight">
<pre><span></span>model_path = DataPathTwo(
    folder_key="MODELS",
    filename="model_scratch.pt")
assert model_path.folder.is_dir()
</pre></div>
<div class="highlight">
<pre><span></span>train_and_test(epochs=10,
               train_batches=loaders_scratch["train"],
               validate_batches=loaders_scratch["validate"],
               test_batches=loaders_scratch["test"],
               model=model_scratch,
               optimizer=optimizer_scratch, 
               criterion=criterion_scratch,
               epoch_start=0,
               model_path=model_path.from_folder,
               load_model=False)
next_start = 11
</pre></div>
<pre class="example" id="orge3493ef">
Starting Training
Ended: 2019-01-01 16:35:14.192989
Elapsed: 0:03:23.778459
Epoch: 0        Training Loss: 3.946975         Validation Loss: 3.758706
Validation loss decreased (inf --&gt; 3.758706). Saving model ...
Ended: 2019-01-01 16:38:39.497147
Elapsed: 0:03:24.517456
Epoch: 1        Training Loss: 3.880984         Validation Loss: 3.695643
Validation loss decreased (3.758706 --&gt; 3.695643). Saving model ...
Ended: 2019-01-01 16:42:04.190248
Elapsed: 0:03:23.903292
Epoch: 2        Training Loss: 3.870710         Validation Loss: 3.718353
Ended: 2019-01-01 16:45:28.479552
Elapsed: 0:03:23.718292
Epoch: 3        Training Loss: 3.836664         Validation Loss: 3.740289
Ended: 2019-01-01 16:48:53.605419
Elapsed: 0:03:24.555708
Epoch: 4        Training Loss: 3.819701         Validation Loss: 3.659244
Validation loss decreased (3.695643 --&gt; 3.659244). Saving model ...
Ended: 2019-01-01 16:52:33.198097
Elapsed: 0:03:38.805586
Epoch: 5        Training Loss: 3.778872         Validation Loss: 3.756706
Ended: 2019-01-01 16:56:16.822584
Elapsed: 0:03:43.055469
Epoch: 6        Training Loss: 3.752981         Validation Loss: 3.679196
Ended: 2019-01-01 16:59:42.861936
Elapsed: 0:03:25.469331
Epoch: 7        Training Loss: 3.730930         Validation Loss: 3.608311
Validation loss decreased (3.659244 --&gt; 3.608311). Saving model ...
Ended: 2019-01-01 17:03:10.958002
Elapsed: 0:03:27.305644
Epoch: 8        Training Loss: 3.705110         Validation Loss: 3.636201
Ended: 2019-01-01 17:06:38.939991
Elapsed: 0:03:27.412824
Epoch: 9        Training Loss: 3.665519         Validation Loss: 3.595410
Validation loss decreased (3.608311 --&gt; 3.595410). Saving model ...
Ended: 2019-01-01 17:06:39.733176
Elapsed: 0:03:28.206009
Starting Testing
Test Loss: 3.642843


Test Accuracy: 14% (125/836)
Ended: 2019-01-01 17:07:11.142926
Elapsed: 0:00:30.815650
</pre>
<p>Hmm, seems suspiciously good all of a sudden. It looks like my GPU is faster than paper space's, too..</p>
<div class="highlight">
<pre><span></span>train_and_test(epochs=10,
               train_batches=loaders_scratch["train"],
               validate_batches=loaders_scratch["validate"],
               test_batches=loaders_scratch["test"],
               model=model_scratch,
               optimizer=optimizer_scratch, 
               criterion=criterion_scratch,
               epoch_start=next_start,
               model_path=model_path.from_folder,
               load_model=True)
next_start = 21
</pre></div>
<pre class="example" id="orgb283f11">
Starting Training
Ended: 2019-01-01 17:29:46.425198
Elapsed: 0:03:40.954699
Epoch: 0        Training Loss: 3.662736         Validation Loss: 3.631118
Validation loss decreased (inf --&gt; 3.631118). Saving model ...
Ended: 2019-01-01 17:33:12.797754
Elapsed: 0:03:25.528229
Epoch: 1        Training Loss: 3.612436         Validation Loss: 3.610919
Validation loss decreased (3.631118 --&gt; 3.610919). Saving model ...
Ended: 2019-01-01 17:36:49.466848
Elapsed: 0:03:35.831733
Epoch: 2        Training Loss: 3.612902         Validation Loss: 3.590953
Validation loss decreased (3.610919 --&gt; 3.590953). Saving model ...
Ended: 2019-01-01 17:40:17.511898
Elapsed: 0:03:27.192943
Epoch: 3        Training Loss: 3.564542         Validation Loss: 3.566365
Validation loss decreased (3.590953 --&gt; 3.566365). Saving model ...
Ended: 2019-01-01 17:43:45.639219
Elapsed: 0:03:27.309572
Epoch: 4        Training Loss: 3.551703         Validation Loss: 3.608934
Ended: 2019-01-01 17:47:32.854824
Elapsed: 0:03:46.646159
Epoch: 5        Training Loss: 3.542706         Validation Loss: 3.533696
Validation loss decreased (3.566365 --&gt; 3.533696). Saving model ...
Ended: 2019-01-01 17:51:02.330525
Elapsed: 0:03:28.506819
Epoch: 6        Training Loss: 3.532894         Validation Loss: 3.531388
Validation loss decreased (3.533696 --&gt; 3.531388). Saving model ...
Ended: 2019-01-01 17:54:25.844725
Elapsed: 0:03:22.697779
Epoch: 7        Training Loss: 3.482241         Validation Loss: 3.564429
Ended: 2019-01-01 17:57:48.563069
Elapsed: 0:03:22.148237
Epoch: 8        Training Loss: 3.485189         Validation Loss: 3.624133
Ended: 2019-01-01 18:01:11.755236
Elapsed: 0:03:22.621310
Epoch: 9        Training Loss: 3.461059         Validation Loss: 3.594314
Ended: 2019-01-01 18:01:12.326268
Elapsed: 0:03:23.192342
Starting Testing
Test Loss: 3.537503


Test Accuracy: 16% (138/836)
Ended: 2019-01-01 18:01:42.764907
Elapsed: 0:00:29.747148
</pre>
<div class="highlight">
<pre><span></span>train_and_test(epochs=10,
               train_batches=loaders_scratch["train"],
               validate_batches=loaders_scratch["validate"],
               test_batches=loaders_scratch["test"],
               model=model_scratch,
               optimizer=optimizer_scratch, 
               criterion=criterion_scratch,
               epoch_start=next_start,
               model_path=model_path.from_folder,
               load_model=True)
next_start = 31
</pre></div>
<pre class="example" id="org872f47d">
Starting Training
Ended: 2019-01-01 18:45:17.404562
Elapsed: 0:03:23.081286
Epoch: 21       Training Loss: 3.510303         Validation Loss: 3.555182
Validation loss decreased (inf --&gt; 3.555182). Saving model ...
Ended: 2019-01-01 18:48:41.215171
Elapsed: 0:03:22.949288
Epoch: 22       Training Loss: 3.485824         Validation Loss: 3.570289
Ended: 2019-01-01 18:52:04.635395
Elapsed: 0:03:22.849569
Epoch: 23       Training Loss: 3.438656         Validation Loss: 3.543221
Validation loss decreased (3.555182 --&gt; 3.543221). Saving model ...
Ended: 2019-01-01 18:55:28.409018
Elapsed: 0:03:22.980693
Epoch: 24       Training Loss: 3.387092         Validation Loss: 3.649569
Ended: 2019-01-01 18:58:51.555922
Elapsed: 0:03:22.576946
Epoch: 25       Training Loss: 3.381217         Validation Loss: 3.529994
Validation loss decreased (3.543221 --&gt; 3.529994). Saving model ...
Ended: 2019-01-01 19:02:15.743200
Elapsed: 0:03:23.359857
Epoch: 26       Training Loss: 3.379801         Validation Loss: 3.514583
Validation loss decreased (3.529994 --&gt; 3.514583). Saving model ...
Ended: 2019-01-01 19:05:40.243125
Elapsed: 0:03:23.700481
Epoch: 27       Training Loss: 3.334058         Validation Loss: 3.469988
Validation loss decreased (3.514583 --&gt; 3.469988). Saving model ...
Ended: 2019-01-01 19:09:04.218270
Elapsed: 0:03:23.150903
Epoch: 28       Training Loss: 3.347201         Validation Loss: 3.456167
Validation loss decreased (3.469988 --&gt; 3.456167). Saving model ...
Ended: 2019-01-01 19:12:27.711756
Elapsed: 0:03:22.677622
Epoch: 29       Training Loss: 3.320286         Validation Loss: 3.444669
Validation loss decreased (3.456167 --&gt; 3.444669). Saving model ...
Ended: 2019-01-01 19:15:51.375887
Elapsed: 0:03:22.875358
Epoch: 30       Training Loss: 3.314001         Validation Loss: 3.460704
Ended: 2019-01-01 19:15:51.946497
Elapsed: 0:03:23.445968
Starting Testing
Test Loss: 3.492875


Test Accuracy: 17% (146/836)
Ended: 2019-01-01 19:16:10.729405
Elapsed: 0:00:18.109680
</pre>
<div class="highlight">
<pre><span></span>train_and_test(epochs=10,
               train_batches=loaders_scratch["train"],
               validate_batches=loaders_scratch["validate"],
               test_batches=loaders_scratch["test"],
               model=model_scratch,
               optimizer=optimizer_scratch, 
               criterion=criterion_scratch,
               epoch_start=next_start,
               model_path=model_path.from_folder,
               load_model=True)
next_start = 41
</pre></div>
<pre class="example" id="org4c1b00a">
Starting Training
Ended: 2019-01-01 20:15:25.906348
Elapsed: 0:05:12.167322
Epoch: 31       Training Loss: 3.311046         Validation Loss: 3.446478
Validation loss decreased (inf --&gt; 3.446478). Saving model ...
Ended: 2019-01-01 20:19:13.168084
Elapsed: 0:03:46.461085
Epoch: 32       Training Loss: 3.270769         Validation Loss: 3.550049
Ended: 2019-01-01 20:22:38.973465
Elapsed: 0:03:25.195274
Epoch: 33       Training Loss: 3.221883         Validation Loss: 3.489280
Ended: 2019-01-01 20:26:02.049299
Elapsed: 0:03:22.483931
Epoch: 34       Training Loss: 3.271723         Validation Loss: 3.507546
Ended: 2019-01-01 20:29:24.932614
Elapsed: 0:03:22.292605
Epoch: 35       Training Loss: 3.197156         Validation Loss: 3.475409
Ended: 2019-01-01 20:32:47.569786
Elapsed: 0:03:22.046763
Epoch: 36       Training Loss: 3.210177         Validation Loss: 3.477707
Ended: 2019-01-01 20:36:09.752175
Elapsed: 0:03:21.592504
Epoch: 37       Training Loss: 3.199346         Validation Loss: 3.577469
Ended: 2019-01-01 20:39:32.831340
Elapsed: 0:03:22.489048
Epoch: 38       Training Loss: 3.158563         Validation Loss: 3.442629
Validation loss decreased (3.446478 --&gt; 3.442629). Saving model ...
Ended: 2019-01-01 20:42:56.293868
Elapsed: 0:03:22.664005
Epoch: 39       Training Loss: 3.152231         Validation Loss: 3.470943
Ended: 2019-01-01 20:46:18.983529
Elapsed: 0:03:22.098438
Epoch: 40       Training Loss: 3.124298         Validation Loss: 3.429367
Validation loss decreased (3.442629 --&gt; 3.429367). Saving model ...
Ended: 2019-01-01 20:46:19.801009
Elapsed: 0:03:22.915918
Starting Testing
Test Loss: 3.348011


Test Accuracy: 21% (179/836)
Ended: 2019-01-01 20:46:42.494502
Elapsed: 0:00:22.094465
</pre>
<div class="highlight">
<pre><span></span>train_and_test(epochs=10,
               train_batches=loaders_scratch["train"],
               validate_batches=loaders_scratch["validate"],
               test_batches=loaders_scratch["test"],
               model=model_scratch,
               optimizer=optimizer_scratch, 
               criterion=criterion_scratch,
               epoch_start=next_start,
               model_path=model_path.from_folder,
               load_model=True)
next_start = 51
</pre></div>
<pre class="example" id="org66284a0">
Starting Training
Ended: 2019-01-01 22:01:17.285699
Elapsed: 0:03:24.381614
Epoch: 41       Training Loss: 3.095166         Validation Loss: 3.418227
Validation loss decreased (inf --&gt; 3.418227). Saving model ...
Ended: 2019-01-01 22:04:43.173252
Elapsed: 0:03:25.033381
Epoch: 42       Training Loss: 3.089258         Validation Loss: 3.419117
Ended: 2019-01-01 22:08:07.709900
Elapsed: 0:03:23.945667
Epoch: 43       Training Loss: 3.071535         Validation Loss: 3.433646
Ended: 2019-01-01 22:11:33.153513
Elapsed: 0:03:24.853880
Epoch: 44       Training Loss: 3.058665         Validation Loss: 3.454817
Ended: 2019-01-01 22:14:59.899762
Elapsed: 0:03:26.156530
Epoch: 45       Training Loss: 3.072674         Validation Loss: 3.494963
Ended: 2019-01-01 22:18:26.207188
Elapsed: 0:03:25.746042
Epoch: 46       Training Loss: 3.043788         Validation Loss: 3.430311
Ended: 2019-01-01 22:21:51.975083
Elapsed: 0:03:25.177310
Epoch: 47       Training Loss: 3.015571         Validation Loss: 3.382248
Validation loss decreased (3.418227 --&gt; 3.382248). Saving model ...
Ended: 2019-01-01 22:25:18.237087
Elapsed: 0:03:25.403639
Epoch: 48       Training Loss: 2.972451         Validation Loss: 3.449296
Ended: 2019-01-01 22:28:44.315967
Elapsed: 0:03:25.498810
Epoch: 49       Training Loss: 2.989183         Validation Loss: 3.428347
Ended: 2019-01-01 22:32:10.738134
Elapsed: 0:03:25.832058
Epoch: 50       Training Loss: 2.966034         Validation Loss: 3.501775
Ended: 2019-01-01 22:32:11.326703
Elapsed: 0:03:26.420627
Starting Testing
Test Loss: 3.485910


Test Accuracy: 18% (156/836)
Ended: 2019-01-01 22:32:41.884173
Elapsed: 0:00:29.644028
</pre>
<div class="highlight">
<pre><span></span>train_and_test(epochs=10,
               train_batches=loaders_scratch["train"],
               validate_batches=loaders_scratch["validate"],
               test_batches=loaders_scratch["test"],
               model=model_scratch,
               optimizer=optimizer_scratch, 
               criterion=criterion_scratch,
               epoch_start=next_start,
               model_path=model_path.from_folder,
               load_model=True)
next_start = 61
</pre></div>
<pre class="example" id="orgb1d3764">
Starting Training
Ended: 2019-01-01 22:39:53.821378
Elapsed: 0:04:15.535643
Epoch: 51       Training Loss: 3.024161         Validation Loss: 3.409968
Validation loss decreased (inf --&gt; 3.409968). Saving model ...
Ended: 2019-01-01 22:43:47.462698
Elapsed: 0:03:52.776151
Epoch: 52       Training Loss: 2.979377         Validation Loss: 3.512004
Ended: 2019-01-01 22:47:35.580770
Elapsed: 0:03:47.528679
Epoch: 53       Training Loss: 2.983352         Validation Loss: 3.499196
Ended: 2019-01-01 22:50:58.662565
Elapsed: 0:03:22.501398
Epoch: 54       Training Loss: 2.944738         Validation Loss: 3.458440
Ended: 2019-01-01 22:54:21.531858
Elapsed: 0:03:22.279749
Epoch: 55       Training Loss: 2.921185         Validation Loss: 3.581930
Ended: 2019-01-01 22:57:44.017339
Elapsed: 0:03:21.925483
Epoch: 56       Training Loss: 2.928508         Validation Loss: 3.449956
Ended: 2019-01-01 23:01:06.668710
Elapsed: 0:03:22.061753
Epoch: 57       Training Loss: 2.887215         Validation Loss: 3.559204
Ended: 2019-01-01 23:04:29.439919
Elapsed: 0:03:22.181396
Epoch: 58       Training Loss: 2.909253         Validation Loss: 3.458249
Ended: 2019-01-01 23:07:51.804139
Elapsed: 0:03:21.803807
Epoch: 59       Training Loss: 2.864969         Validation Loss: 3.599446
Ended: 2019-01-01 23:11:14.184534
Elapsed: 0:03:21.789954
Epoch: 60       Training Loss: 2.820693         Validation Loss: 3.432991
Ended: 2019-01-01 23:11:14.775507
Elapsed: 0:03:22.380927
Starting Testing
Test Loss: 3.370016


Test Accuracy: 21% (176/836)
Ended: 2019-01-01 23:11:44.949942
Elapsed: 0:00:29.259563
</pre>
<div class="highlight">
<pre><span></span>next_start = 61
train_and_test(epochs=10,
               train_batches=loaders_scratch["train"],
               validate_batches=loaders_scratch["validate"],
               test_batches=loaders_scratch["test"],
               model=model_scratch,
               optimizer=optimizer_scratch, 
               criterion=criterion_scratch,
               epoch_start=next_start,
               model_path=model_path.from_folder,
               load_model=True)
next_start = 71
</pre></div>
<pre class="example" id="org1a9aee8">
Starting Training
Ended: 2019-01-01 23:31:00.034455
Elapsed: 0:03:21.658811
Epoch: 61       Training Loss: 2.968425         Validation Loss: 3.469985
Validation loss decreased (inf --&gt; 3.469985). Saving model ...
Ended: 2019-01-01 23:34:24.012685
Elapsed: 0:03:22.630721
Epoch: 62       Training Loss: 2.980103         Validation Loss: 3.449017
Validation loss decreased (3.469985 --&gt; 3.449017). Saving model ...
Ended: 2019-01-01 23:37:47.137370
Elapsed: 0:03:22.315870
Epoch: 63       Training Loss: 2.945722         Validation Loss: 3.497296
Ended: 2019-01-01 23:41:09.932696
Elapsed: 0:03:22.226620
Epoch: 64       Training Loss: 2.940117         Validation Loss: 3.398626
Validation loss decreased (3.449017 --&gt; 3.398626). Saving model ...
Ended: 2019-01-01 23:44:33.204607
Elapsed: 0:03:22.484337
Epoch: 65       Training Loss: 2.913762         Validation Loss: 3.465828
Ended: 2019-01-01 23:47:55.682608
Elapsed: 0:03:21.909285
Epoch: 66       Training Loss: 2.877373         Validation Loss: 3.525525
Ended: 2019-01-01 23:51:18.110150
Elapsed: 0:03:21.859021
Epoch: 67       Training Loss: 2.889807         Validation Loss: 3.499459
Ended: 2019-01-01 23:54:40.142934
Elapsed: 0:03:21.464199
Epoch: 68       Training Loss: 2.882748         Validation Loss: 3.364801
Validation loss decreased (3.398626 --&gt; 3.364801). Saving model ...
Ended: 2019-01-01 23:58:02.359285
Elapsed: 0:03:21.435096
Epoch: 69       Training Loss: 2.886337         Validation Loss: 3.488435
Ended: 2019-01-02 00:01:26.616419
Elapsed: 0:03:23.688341
Epoch: 70       Training Loss: 2.867836         Validation Loss: 3.417904
Ended: 2019-01-02 00:01:27.309412
Elapsed: 0:03:24.381334
Starting Testing
Test Loss: 3.359312


Test Accuracy: 22% (191/836)
Ended: 2019-01-02 00:02:29.963462
Elapsed: 0:01:01.964477
</pre>
<div class="highlight">
<pre><span></span>train_and_test(epochs=10,
               train_batches=loaders_scratch["train"],
               validate_batches=loaders_scratch["validate"],
               test_batches=loaders_scratch["test"],
               model=model_scratch,
               optimizer=optimizer_scratch, 
               criterion=criterion_scratch,
               epoch_start=next_start,
               model_path=model_path.from_folder,
               load_model=True)
next_start = 81
</pre></div>
<pre class="example" id="org967af19">
Starting Training
Ended: 2019-01-02 00:13:59.560043
Elapsed: 0:09:26.402859
Epoch: 71       Training Loss: 2.847764         Validation Loss: 3.462033
Validation loss decreased (inf --&gt; 3.462033). Saving model ...
Ended: 2019-01-02 00:21:40.896206
Elapsed: 0:07:40.511212
Epoch: 72       Training Loss: 2.852644         Validation Loss: 3.469687
Ended: 2019-01-02 00:29:05.309753
Elapsed: 0:07:23.845532
Epoch: 73       Training Loss: 2.840424         Validation Loss: 3.545896
Ended: 2019-01-02 00:33:46.928392
Elapsed: 0:04:41.026761
Epoch: 74       Training Loss: 2.813888         Validation Loss: 3.552435
Ended: 2019-01-02 00:37:18.057707
Elapsed: 0:03:30.560704
Epoch: 75       Training Loss: 2.807452         Validation Loss: 3.491534
Ended: 2019-01-02 00:40:41.064242
Elapsed: 0:03:22.438088
Epoch: 76       Training Loss: 2.802119         Validation Loss: 3.429099
Validation loss decreased (3.462033 --&gt; 3.429099). Saving model ...
Ended: 2019-01-02 00:44:04.191818
Elapsed: 0:03:22.138587
Epoch: 77       Training Loss: 2.809226         Validation Loss: 3.482573
Ended: 2019-01-02 00:47:26.187167
Elapsed: 0:03:21.427162
Epoch: 78       Training Loss: 2.767340         Validation Loss: 3.473212
Ended: 2019-01-02 00:50:48.717819
Elapsed: 0:03:21.962244
Epoch: 79       Training Loss: 2.750881         Validation Loss: 3.435359
Ended: 2019-01-02 00:54:11.744891
Elapsed: 0:03:22.458406
Epoch: 80       Training Loss: 2.739076         Validation Loss: 3.466524
Ended: 2019-01-02 00:54:12.313860
Elapsed: 0:03:23.027375
Starting Testing
Test Loss: 3.505263


Test Accuracy: 21% (183/836)
Ended: 2019-01-02 00:54:42.938753
Elapsed: 0:00:29.924658
</pre></div>
</div>
<div class="outline-3" id="outline-container-org1be1833">
<h3 id="org1be1833">Debug the CUDA Error</h3>
<div class="outline-text-3" id="text-org1be1833">
<p>The previous blocks of code raised an exception when I first ran it.</p>
<div class="highlight">
<pre><span></span><span class="ne">RuntimeError</span><span class="p">:</span> <span class="n">cuda</span> <span class="n">runtime</span> <span class="n">error</span> <span class="p">(</span><span class="mi">59</span><span class="p">)</span> <span class="p">:</span> <span class="n">device</span><span class="o">-</span><span class="n">side</span> <span class="k">assert</span> <span class="n">triggered</span> <span class="n">at</span> <span class="o">/</span><span class="n">pytorch</span><span class="o">/</span><span class="n">aten</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">THC</span><span class="o">/</span><span class="n">generic</span><span class="o">/</span><span class="n">THCTensorMath</span><span class="o">.</span><span class="n">cu</span><span class="p">:</span><span class="mi">26</span>
</pre></div>
<p>And points to this line as the point where it crashes.</p>
<div class="highlight">
<pre><span></span><span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
</pre></div>
<p>Re-running it gives a similar but different error.</p>
<div class="highlight">
<pre><span></span><span class="ne">RuntimeError</span><span class="p">:</span> <span class="n">CUDA</span> <span class="n">error</span><span class="p">:</span> <span class="n">device</span><span class="o">-</span><span class="n">side</span> <span class="k">assert</span> <span class="n">triggered</span>
</pre></div>
<p>Happening here:</p>
<div class="highlight">
<pre><span></span><span class="n">data</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">target</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
</pre></div>
<p>According to <a href="https://github.com/pytorch/pytorch/issues/1010">this bug report</a> on GitHub, there's two things happening. One is that once the exception happens the CUDA session is dead so trying to move the data to CUDA raises an error just because we are trying to use it (and you can't until you restart the python session). In that same thread they note that the original exception indicates something wrong with the classes being output by the network. One error they list is if there's a negative label, another if the label is out of range for the number of categories, but In my case it might be that I was only outputting 10 classes (I copied the CIFAR model), not the 133 you need for the dog-breeds.</p>
</div>
<div class="outline-4" id="outline-container-org6fd8c1c">
<h4 id="org6fd8c1c">Load The Best Model</h4>
<div class="outline-text-4" id="text-org6fd8c1c">
<div class="highlight">
<pre><span></span>model_scratch.load_state_dict(torch.load('model_scratch.pt'))
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org844b898">
<h4 id="org844b898">Test It</h4>
<div class="outline-text-4" id="text-org844b898">
<div class="highlight">
<pre><span></span>test(loaders_scratch["test"], model_scratch, criterion_scratch)
</pre></div>
<pre class="example">
Test Loss: 3.492875


Test Accuracy: 17% (146/836)
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgee4bf4e">
<h3 id="orgee4bf4e">Transfer Learning Model</h3>
<div class="outline-text-3" id="text-orgee4bf4e">
<p>Now I'm going to use transfer learning to make a model to classify dog images by breed.</p>
</div>
<div class="outline-4" id="outline-container-org527aa25">
<h4 id="org527aa25">The Data Transformer</h4>
<div class="outline-text-4" id="text-org527aa25">
<p>As I noted earlier, the <code>Inception V3</code> model expects a different image size so we can't re-use the previous data-transforms.</p>
<div class="highlight">
<pre><span></span>class Transformer:
    """builds the data-sets

    Args:
     means: list of means for each channel
     deviations: list of standard deviations for each channel
     image_size: size to crop the image to
    """
    def __init__(self,
                 means: list=[0.485, 0.456, 0.406],
                 deviations: list=[0.229, 0.224, 0.225],
                 image_size: int=299) -&gt; None:
        self.means = means
        self.deviations = deviations
        self.image_size = image_size
        self._training = None
        self._testing = None
        return

    @property
    def training(self) -&gt; transforms.Compose:
        """The image transformers for the training"""
        if self._training is None:
            self._training = transforms.Compose([
                transforms.RandomRotation(30),
                transforms.RandomResizedCrop(self.image_size),
                transforms.RandomHorizontalFlip(),
                transforms.ToTensor(),
                transforms.Normalize(self.means,
                                     self.deviations)])
        return self._training

    @property
    def testing(self) -&gt; transforms.Compose:
        """Image transforms for the testing"""
        if self._testing is None:
            self._testing = transforms.Compose(
                [transforms.Resize(350),
                 transforms.CenterCrop(self.image_size),
                 transforms.ToTensor(),
                 transforms.Normalize(self.means,
                                      self.deviations)])
        return self._testing
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org1d8fcc0">
<h4 id="org1d8fcc0">The Data Set Loader</h4>
<div class="outline-text-4" id="text-org1d8fcc0">
<div class="highlight">
<pre><span></span>class DataSets:
    """Builds the data-sets

    Args:
     paths: object with the paths to the data-sets
    """
    def __init__(self, paths: DogPaths=None, transformer: Transformer=None) -&gt; None:
        self._paths = paths
        self._transformer = transformer
        self._training = None
        self._validation = None
        self._testing = None
        return

    @property
    def paths(self) -&gt; DogPaths:
        """Object with the paths to the image files"""
        if self._paths is None:
            self._paths = DogPaths()
        return self._paths

    @property
    def transformer(self) -&gt; Transformer:
        """Object with the image transforms"""
        if self._transformer is None:
            self._transformer = Transformer()
        return self._transformer

    @property
    def training(self) -&gt; datasets.ImageFolder:
        """The training data set"""
        if self._training is None:
            self._training = datasets.ImageFolder(
                root=self.paths.training.folder,
                transform=self.transformer.training)
        return self._training

    @property
    def validation(self) -&gt; datasets.ImageFolder:
        """The validation dataset"""
        if self._validation is None:
            self._validation = datasets.ImageFolder(
                root=self.paths.validation.folder,
                transform=self.transformer.testing)
        return self._validation

    @property
    def testing(self) -&gt; datasets.ImageFolder:
        """The test set"""
        if self._testing is None:
            self._testing = datasets.ImageFolder(
                root=self.paths.testing.folder,
                transform=self.transformer.testing)
        return self._testing
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org95cb6c9">
<h4 id="org95cb6c9">The Batch Loader</h4>
<div class="outline-text-4" id="text-org95cb6c9">
<div class="highlight">
<pre><span></span>class Batches:
    """The data batch loaders

    Args:
     datasets: a data-set builder
     batch_size: the size of each batch loaded
     workers: the number of processes to use
    """
    def __init__(self, datasets: DataSets,
                 batch_size: int=20,
                 workers: int=0) -&gt; None:
        self.datasets = datasets
        self.batch_size = batch_size
        self.workers = workers
        self._training = None
        self._validation = None
        self._testing = None
        return

    @property
    def training(self) -&gt; torch.utils.data.DataLoader:
        """The training batches"""
        if self._training is None:
            self._training = torch.utils.data.DataLoader(
                self.datasets.training,
                batch_size=self.batch_size,
                shuffle=True, num_workers=self.workers)
        return self._training

    @property
    def validation(self) -&gt; torch.utils.data.DataLoader:
        """The validation batches"""
        if self._validation is None:
            self._validation = torch.utils.data.DataLoader(
                self.datasets.validation,
                batch_size=self.batch_size,
                shuffle=True, num_workers=self.workers)
        return self._validation

    @property
    def testing(self) -&gt; torch.utils.data.DataLoader:
        """The testing batches"""
        if self._testing is None:
            self._testing = torch.utils.data.DataLoader(
                self.datasets.testing,
                batch_size=self.batch_size,
                shuffle=True, num_workers=self.workers)
        return self._testing
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org54767c6">
<h4 id="org54767c6">The Inception Dog Classifier</h4>
<div class="outline-text-4" id="text-org54767c6">
<p>Although the constructor for the pytorch Inception model takes an <code>aux_logits</code> parameter, if you set it to false then it will raise an error saying there are unexpected keys in the state dict. But if you don't set it False it will return a tuple from the <code>forward</code> method so either set it to False after the constructor or catch a tuple as the output <code>(x, aux)</code> and throw away the second part (or figure out how to combine them). I decided to leave it set because it is supposed to help with training and changed the training function to handle it. But I don't really show that in this notebook. I'll have to re-write things later.</p>
<div class="highlight">
<pre><span></span>class Inception:
    """Sets up the model, criterion, and optimizer for the transfer learning

    Args:
     classes: number of outputs for the final layer
     device: processor to use
     model_path: path to a saved model
     learning_rate: learning rate for the optimizer
     momentum: momentum for the optimizer
    """
    def __init__(self, classes: int,
                 device: torch.device=None,
                 model_path: str=None,
                 learning_rate: float=0.001, momentum: float=0.9) -&gt; None:
        self.classes = classes
        self.model_path = model_path
        self.learning_rate = learning_rate
        self.momentum = momentum
        self._device = device
        self._model = None
        self._classifier_inputs = None
        self._criterion = None
        self._optimizer = None
        return

    @property
    def device(self) -&gt; torch.device:
        """Processor to use (cpu or cuda)"""
        if self._device is None:
            self._device = torch.device(
                "cuda" if torch.cuda.is_available() else "cpu")
        return self._device

    @property
    def model(self) -&gt; models.inception_v3:
        """The inception model"""
        if self._model is None:
            self._model = models.inception_v3(pretrained=True)
            for parameter in self._model.parameters():
                parameter.requires_grad = False
            classifier_inputs = self._model.fc.in_features
            self._model.fc = nn.Linear(in_features=classifier_inputs,
                                       out_features=self.classes,
                                       bias=True)
            self._model.to(self.device)
            if self.model_path:
                self._model.load_state_dict(torch.load(self.model_path))
        return self._model

    @property
    def criterion(self) -&gt; nn.CrossEntropyLoss:
        """The loss callable"""
        if self._criterion is None:
            self._criterion = nn.CrossEntropyLoss()
        return self._criterion

    @property
    def optimizer(self) -&gt; optimizer.SGD:
        """The Gradient Descent object"""
        if self._optimizer is None:
            self._optimizer = optimizer.SGD(
                self.model.parameters(),
                lr=self.learning_rate,
                momentum=self.momentum)
        return self._optimizer
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org9f47f37">
<h4 id="org9f47f37">Disecting the Inception Class</h4>
<div class="outline-text-4" id="text-org9f47f37">
<p>The <code>Inception</code> class bundles together a bunch of stuff that was originally being done in separate cells. Rather than putting comments all over it I'm going to show what it's doing by describing how I was doing it before I created the class.</p>
</div>
<ul class="org-ul">
<li><a id="org5a10c56"></a>The Model Property<br>
<div class="outline-text-5" id="text-org5a10c56">
<p>The last layer of the classifier in the <code>Inception.model</code> property is the only layer of the pre-trained model that I change. In the case of the <code>Inception V3</code> model there is a single layer called <i>fc</i>, as opposed to multiple layers called <i>classifier</i> as with the <code>VGG16</code> model, so I just re-assign it to a fully-connected layer with the number of outputs that matches the number of dog breeds.</p>
<p>Here's a little inspection to show what it's doing.</p>
<div class="highlight">
<pre><span></span>model_transfer = models.inception_v3(pretrained=True)
print(model_transfer.fc)
</pre></div>
<pre class="example">
Linear(in_features=2048, out_features=1000, bias=True)
</pre>
<div class="highlight">
<pre><span></span>CLASSIFIER_INPUTS = model_transfer.fc.in_features
</pre></div>
<div class="highlight">
<pre><span></span>print(CLASSIFIER_INPUTS) 
print(model_transfer.fc.out_features)
</pre></div>
<pre class="example">
2048
1000
</pre>
<p>The layer we're going to replace has 2,048 inputs and 1,000 outputs. We'll have to match the number of inputs and change it to our 133.</p>
</div>
</li>
<li><a id="org5f04fe1"></a>Freeze the Features Layers<br>
<div class="outline-text-5" id="text-org5f04fe1">
<p>In the <code>model</code> property I'm also freezing the parameters so that the pre-trained parameters don't change when training the last layer.</p>
<div class="highlight">
<pre><span></span>for parameter in model_transfer.parameters():
    parameter.requires_grad = False
</pre></div>
</div>
</li>
<li><a id="org50b8680"></a>The New Classifier<br>
<div class="outline-text-5" id="text-org50b8680">
<p>This next block of code is also in the <code>Inception.model</code> definition and is where I'm replacing the last layer with out dog-breed-classification layer.</p>
<div class="highlight">
<pre><span></span>model_transfer.fc = nn.Linear(in_features=CLASSIFIER_INPUTS,
                              out_features=BREEDS,
                              bias=True)
</pre></div>
</div>
</li>
<li><a id="org665fe1b"></a>The Loss Function and Optimizer<br>
<div class="outline-text-5" id="text-org665fe1b">
<p>The <code>Inception</code> class uses the same loss and gradient descent definitions as the naive model did (in the <code>criterion</code> and <code>optimizer</code> properties).</p>
<div class="highlight">
<pre><span></span>criterion_transfer = nn.CrossEntropyLoss()
optimizer_transfer = optimizer.SGD(model_transfer.parameters(),
                                  lr=0.001,
                                  momentum=0.9)
</pre></div>
</div>
</li>
</ul>
</div>
<div class="outline-4" id="outline-container-orgbb6681d">
<h4 id="orgbb6681d">Transfer CLI</h4>
<div class="outline-text-4" id="text-orgbb6681d">
<p>I made this in order to run the model on paperspace without needing to keep the connection to the server alive (it hadn't occured to me to just save a log file).</p>
<div class="highlight">
<pre><span></span><span class="c1"># python</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="kn">import</span> <span class="nn">argparse</span>

<span class="c1"># pypi</span>
<span class="kn">from</span> <span class="nn">dotenv</span> <span class="kn">import</span> <span class="n">load_dotenv</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">ImageFile</span>
<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">datasets</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">torch.optim</span> <span class="k">as</span> <span class="nn">optimizer</span>
<span class="kn">import</span> <span class="nn">torchvision.models</span> <span class="k">as</span> <span class="nn">models</span>
<span class="kn">import</span> <span class="nn">torchvision.transforms</span> <span class="k">as</span> <span class="nn">transforms</span>

<span class="c1"># this project</span>
<span class="kn">from</span> <span class="nn">neurotic.tangles.data_paths</span> <span class="kn">import</span> <span class="n">DataPathTwo</span>
<span class="kn">from</span> <span class="nn">neurotic.tangles.timer</span> <span class="kn">import</span> <span class="n">Timer</span>

<span class="c1"># the output won't show up if you don't flush it when redirecting it to a file</span>
<span class="nb">print</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">"__main__"</span><span class="p">:</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span>
        <span class="n">description</span><span class="o">=</span><span class="s2">"Test or Train the Inception V3 Dog Classifier"</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">"--test-only"</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">"store_true"</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">"Only run the test"</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">"--epochs"</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">"Training epochs (default: </span><span class="si">%(default)s</span><span class="s2">)"</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
        <span class="s2">"--epoch-offset"</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">"Offset for the output of epochs (default: </span><span class="si">%(default)s</span><span class="s2">)"</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">"--restart"</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">"store_true"</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">"Wipe out old model."</span><span class="p">)</span>

    <span class="n">arguments</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="n">data_sets</span> <span class="o">=</span> <span class="n">DataSets</span><span class="p">(</span><span class="n">training_path</span><span class="o">=</span><span class="n">dog_training_path</span><span class="o">.</span><span class="n">folder</span><span class="p">,</span>
                         <span class="n">validation_path</span><span class="o">=</span><span class="n">dog_validation_path</span><span class="o">.</span><span class="n">folder</span><span class="p">,</span>
                         <span class="n">testing_path</span><span class="o">=</span><span class="n">dog_testing_path</span><span class="o">.</span><span class="n">folder</span><span class="p">)</span>
    <span class="n">batches</span> <span class="o">=</span> <span class="n">Batches</span><span class="p">(</span><span class="n">datasets</span><span class="o">=</span><span class="n">data_sets</span><span class="p">)</span>
    <span class="n">inception</span> <span class="o">=</span> <span class="n">Inception</span><span class="p">(</span><span class="n">classes</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">data_sets</span><span class="o">.</span><span class="n">training</span><span class="o">.</span><span class="n">classes</span><span class="p">)</span>
    <span class="n">trainer</span> <span class="o">=</span> <span class="n">Trainer</span><span class="p">(</span><span class="n">epochs</span><span class="o">=</span><span class="n">arguments</span><span class="o">.</span><span class="n">epochs</span><span class="p">,</span>
                      <span class="n">epoch_start</span><span class="o">=</span><span class="n">arguments</span><span class="o">.</span><span class="n">epoch_offset</span><span class="p">,</span>
                      <span class="n">training_batches</span><span class="o">=</span><span class="n">batches</span><span class="o">.</span><span class="n">training</span><span class="p">,</span>
                      <span class="n">validation_batches</span><span class="o">=</span><span class="n">batches</span><span class="o">.</span><span class="n">validation</span><span class="p">,</span>
                      <span class="n">testing_batches</span><span class="o">=</span><span class="n">batches</span><span class="o">.</span><span class="n">testing</span><span class="p">,</span>
                      <span class="n">model</span><span class="o">=</span><span class="n">inception</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                      <span class="n">device</span><span class="o">=</span><span class="n">inception</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
                      <span class="n">optimizer</span><span class="o">=</span><span class="n">inception</span><span class="o">.</span><span class="n">optimizer</span><span class="p">,</span>
                      <span class="n">criterion</span><span class="o">=</span><span class="n">inception</span><span class="o">.</span><span class="n">criterion</span><span class="p">,</span>
                      <span class="n">model_path</span><span class="o">=</span><span class="n">transfer_path</span><span class="o">.</span><span class="n">from_folder</span><span class="p">,</span>
                      <span class="n">load_model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">beep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">arguments</span><span class="o">.</span><span class="n">test_only</span><span class="p">:</span>
        <span class="n">trainer</span><span class="o">.</span><span class="n">test</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">trainer</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orga93aa66">
<h4 id="orga93aa66">The Training</h4>
<div class="outline-text-4" id="text-orga93aa66">
<p>I re-trained the naive model and trained the inception model on paperspace for 100 epochs each. This took around five hours each so I'm not going to re-run it here, but I'll show how I would train the model and some of the output from the real training. The <code>Tee</code> class isn't integrated with my <code>trainer</code> so I can't really show how to train it that way, so I'll show it the orignal function-based way.</p>
<div class="highlight">
<pre><span></span>transfer_path = MODEL_PATH.folder.joinpath("model_transfer.pt")
transfer_log = Tee(log_name="transfer_train.log")
</pre></div>
<div class="highlight">
<pre><span></span>EPOCHS = 100
inception = Inception()
train(EPOCHS,
      loaders=loaders_transfer,
      model=inception.model,
      optimizer=inception.optimizer,
      criterion=inception.criterion,
      use_cuda=use_cuda,
      save_path=transfer_model_path,
      print_function=transfer_log,
      is_inception=True)
</pre></div>
<p>And the last lines of the output.</p>
<pre class="example" id="org7d8be2b">
Epoch: 98       Training Loss: 0.973978         Validation Loss: 0.416819       Elapsed: 0:03:12.167687
Validation loss decreased (0.417785 --&gt; 0.416819). Saving model ...
Epoch: 99       Training Loss: 0.994163         Validation Loss: 0.418498       Elapsed: 0:03:17.225706
Epoch: 100      Training Loss: 0.998819         Validation Loss: 0.423518       Elapsed: 0:03:18.415953
Training Ended: 2019-01-07 10:55:04.465024
Total Training Time: 5:29:54.161034
</pre></div>
</div>
<div class="outline-4" id="outline-container-org6f8127e">
<h4 id="org6f8127e">Test It</h4>
<div class="outline-text-4" id="text-org6f8127e">
<div class="highlight">
<pre><span></span>model_transfer.load_state_dict(torch.load(transfer_model_path))
transfer_test_log = Tee("transfer_test.log")
test(loaders_transfer, model_transfer, criterion_transfer, use_cuda, print_function=transfer_test_log)
</pre></div>
<pre class="example" id="orged9348f">
Test Loss: 0.425383


Test Accuracy: 87% (734/836)
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org7448652">
<h2 id="org7448652">The Dog Breed Classifier</h2>
<div class="outline-text-2" id="text-org7448652"></div>
<div class="outline-3" id="outline-container-orgb4fbbcb">
<h3 id="orgb4fbbcb">Dog Predictor</h3>
<div class="outline-text-3" id="text-orgb4fbbcb">
<div class="highlight">
<pre><span></span>class DogPredictor:
    """Makes dog-breed predictions

    Args:
     model_path: path to the model's state-dict
     device: processor to run the model on
     data_sets: a DataSets object
     inception: an Inception object
    """
    def __init__(self, model_path: str=None,
                 device: torch.device=None,
                 data_sets: DataSets=None,
                 inception: Inception=None) -&gt; None:
        self.model_path = model_path
        self.device = device
        self._data_sets = data_sets
        self._inception = inception
        self._breeds = None
        return

    @property
    def data_sets(self) -&gt; DataSets:
        if self._data_sets is None:
            self._data_sets = DataSets()
        return self._data_sets

    @property
    def inception(self) -&gt; Inception:
        """An Inception object"""
        if self._inception is None:
            self._inception = Inception(
                classes=len(self.data_sets.training.classes),
                model_path=self.model_path,
                device=self.device)
            self._inception.model.eval()
        return self._inception

    @property
    def breeds(self) -&gt; list:
        """A list of dog-breeds"""
        if self._breeds is None:
            self._breeds = [name[4:].replace("_", " ")
                            for name in self.data_sets.training.classes]
        return self._breeds

    def predict_index(self, image_path:str) -&gt; int:
        """Predicts the index of the breed of the dog in the image

        Args:
         image_path: path to the image
        Returns:
         index in the breeds list for the image
        """
        model = self.inception.model        
        image = Image.open(image_path)
        tensor = self.data_sets.transformer.testing(image)
        # add a batch number
        tensor = tensor.unsqueeze_(0)
        tensor = tensor.to(self.inception.device)
        x = torch.autograd.Variable(tensor)
        output = model(x)
        return output.data.cpu().numpy().argmax()

    def __call__(self, image_path) -&gt; str:
        """Predicts the breed of the dog in the image

        Args:
         image_path: path to the image
        Returns:
         name of the breed
        """
        return self.breeds[self.predict_index(image_path)]
</pre></div>
<div class="highlight">
<pre><span></span>predictor = DogPredictor(model_path=transfer_path)
files = list(predictor.data_sets.paths.testing.folder.glob("*/*.jpg"))
</pre></div>
<div class="highlight">
<pre><span></span>case = numpy.random.choice(files, 1)[0]
print("Sample: {}".format(case))
predicted = predictor(case)
print("Predicted: {}".format(predicted))
</pre></div>
<pre class="example">
Sample: /home/hades/data/datasets/dog-breed-classification/dogImages/test/109.Norwegian_elkhound/Norwegian_elkhound_07137.jpg
Predicted: Norwegian elkhound
</pre>
<div class="highlight">
<pre><span></span>for model in MODELS:
    model.cpu()
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org4539b46">
<h3 id="org4539b46">The Dog Breed Classifier</h3>
<div class="outline-text-3" id="text-org4539b46">
<div class="highlight">
<pre><span></span>class DogBreedClassifier:
    """Tries To predict the dog-breed for an image

    Args:
     model_path: path to the inception-model
    """
    def __init__(self, model_path: str) -&gt; None:
        self.model_path = model_path
        self._breed_predictor = None
        self._species_detector = None
        return

    @property
    def breed_predictor(self) -&gt; DogPredictor:
        """Predictor of dog-breeds"""
        if self._breed_predictor is None:
            self._breed_predictor = DogPredictor(model_path=self.model_path)
        return self._breed_predictor

    @property
    def species_detector(self) -&gt; SpeciesDetector:
        """Detector of humans and dogs"""
        if self._species_detector is None:
            self._species_detector = SpeciesDetector(
                device=self.breed_predictor.inception.device)
        return self._species_detector

    def render(self, image_path: str, species: str, breed: str) -&gt; None:
        """Renders the image

        Args:
         image_path: path to the image to render
         species: identified species
         breed: identified breed
        """
        name = " ".join(image_path.name.split(".")[0].split("_")).title()
        figure, axe = pyplot.subplots()
        figure.suptitle("{} ({})".format(species, name), weight="bold")
        axe.set_xlabel("Looks like a {}.".format(breed))
        image = Image.open(image_path)
        axe.tick_params(dict(axis="both",
                             which="both",
                             bottom=False,
                             top=False))
        axe.get_xaxis().set_ticks([])
        axe.get_yaxis().set_ticks([])
        axe_image = axe.imshow(image)
        return

    def __call__(self, image_path:str) -&gt; None:
        """detects the dog-breed and displays the image

        Args:
         image_path: path to the image
        """
        image_path = Path(image_path)
        is_dog = self.species_detector.is_dog(image_path)
        is_human = self.species_detector.is_human(image_path)

        if not is_dog and not is_human:
            species = "Error: Neither Human nor Dog"
            breed = "?"
        else:
            breed = self.breed_predictor(image_path)

        if is_dog and is_human:
            species = "Human-Dog Hybrid"
        elif is_dog:
            species = "Dog"
        elif is_human:
            species = "Human"
        self.render(image_path, species, breed)
        return
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgcdf230c">
<h2 id="orgcdf230c">Some Sample applications</h2>
<div class="outline-text-2" id="text-orgcdf230c">
<div class="highlight">
<pre><span></span>classifier = DogBreedClassifier(model_path=transfer_path)
</pre></div>
<div class="highlight">
<pre><span></span>case = numpy.random.choice(human_files, 1)[0]
classifier(case)
</pre></div>
<div class="figure" id="org570ca02">
<p><img alt="test_one.png" src="posts/nano/dog-breed-classifier/dog-breed-classification/test_one.png"></p>
</div>
<div class="highlight">
<pre><span></span>case = numpy.random.choice(dog_files, 1)[0]
classifier(case)
</pre></div>
<div class="figure" id="orgba18153">
<p><img alt="test_two.png" src="posts/nano/dog-breed-classifier/dog-breed-classification/test_two.png"></p>
</div>
<div class="highlight">
<pre><span></span>case = "rabbit.jpg"
classifier(case)
</pre></div>
<div class="figure" id="orgdd671b6">
<p><img alt="test_three.png" src="posts/nano/dog-breed-classifier/dog-breed-classification/test_three.png"></p>
</div>
<p>Rabbit image from <a href="https://commons.wikimedia.org/wiki/File:Oryctolagus_cuniculus_Tasmania_2.jpg">Wikimedia</a>.</p>
<div class="highlight">
<pre><span></span>case = "hot_dog.jpg"
classifier(case)
</pre></div>
<div class="figure" id="org4113b80">
<p><img alt="test_four.png" src="posts/nano/dog-breed-classifier/dog-breed-classification/test_four.png"></p>
</div>
<p>The Hot Dog is also from <a href="https://commons.wikimedia.org/wiki/File:NCI_Visuals_Food_Hot_Dog.jpg">Wikimedia</a>.</p>
<div class="highlight">
<pre><span></span>case = human_files_short[34]
classifier(case)
</pre></div>
<div class="figure" id="org93a39a9">
<p><img alt="test_five.png" src="posts/nano/dog-breed-classifier/dog-breed-classification/test_five.png"></p>
</div>
<p>So, somehow my class-based detector got smarter than my function based one and can now tell that this isn't a dog…</p>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/nano/cnn/mnist-mlp/">MNIST MLP</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/nano/cnn/mnist-mlp/" rel="bookmark"><time class="published dt-published" datetime="2018-11-25T17:29:13-08:00" itemprop="datePublished" title="2018-11-25 17:29">2018-11-25 17:29</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/nano/cnn/mnist-mlp/#org6a7e27e">Introduction</a></li>
<li><a href="posts/nano/cnn/mnist-mlp/#orgf4cced8">Imports</a></li>
<li><a href="posts/nano/cnn/mnist-mlp/#org5dc7baf">Setup the Plotting</a></li>
<li><a href="posts/nano/cnn/mnist-mlp/#org6cdb1db">The Data</a></li>
<li><a href="posts/nano/cnn/mnist-mlp/#org757eab1">Visualize a Batch of Training Data</a></li>
<li><a href="posts/nano/cnn/mnist-mlp/#orgf4faf6a">Define the Network Architecture</a></li>
<li><a href="posts/nano/cnn/mnist-mlp/#org338ab1f">Specify the Loss Function and Optimizer</a></li>
<li><a href="posts/nano/cnn/mnist-mlp/#orgfbe5e4e">Train the Network</a></li>
<li><a href="posts/nano/cnn/mnist-mlp/#orgbe4fdef">Test the Trained Network</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org6a7e27e">
<h2 id="org6a7e27e">Introduction</h2>
<div class="outline-text-2" id="text-org6a7e27e">
<p>This is from <a href="https://github.com/udacity/deep-learning-v2-pytorch.git">Udacity's Deep Learning Repository</a> which supports their Deep Learning Nanodegree.</p>
<p>We are going to train a <a href="https://en.wikipedia.org/wiki/Multilayer_perceptron">Multi-Layer Perceptron</a> to classify images from the <a href="http://yann.lecun.com/exdb/mnist/">MNIST database</a> of hand-written digits.</p>
<p>We're going to do it using the following steps.</p>
<ol class="org-ol">
<li>Load and visualize the data</li>
<li>Define a neural network</li>
<li>Train the model</li>
<li>Evaluate the performance of our trained model on a test dataset</li>
</ol>
</div>
</div>
<div class="outline-2" id="outline-container-orgf4cced8">
<h2 id="orgf4cced8">Imports</h2>
<div class="outline-text-2" id="text-orgf4cced8"></div>
<div class="outline-3" id="outline-container-orga1939e5">
<h3 id="orga1939e5">From Python</h3>
<div class="outline-text-3" id="text-orga1939e5">
<div class="highlight">
<pre><span></span>from datetime import datetime
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org9669ffd">
<h3 id="org9669ffd">From PyPi</h3>
<div class="outline-text-3" id="text-org9669ffd">
<div class="highlight">
<pre><span></span>from dotenv import load_dotenv
from torchvision import datasets
import matplotlib.pyplot as pyplot
import seaborn
import torch.nn as nn
import torch.nn.functional as F
import torchvision.transforms as transforms
import torch
import numpy
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgbcf6a93">
<h3 id="orgbcf6a93">This Project</h3>
<div class="outline-text-3" id="text-orgbcf6a93">
<div class="highlight">
<pre><span></span>from neurotic.tangles.data_paths import DataPathTwo
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org5dc7baf">
<h2 id="org5dc7baf">Setup the Plotting</h2>
<div class="outline-text-2" id="text-org5dc7baf">
<div class="highlight">
<pre><span></span>get_ipython().run_line_magic('matplotlib', 'inline')
seaborn.set(style="whitegrid",
            rc={"axes.grid": False,
                "font.family": ["sans-serif"],
                "font.sans-serif": ["Latin Modern Sans", "Lato"],
                "figure.figsize": (8, 6)},
            font_scale=3)
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-org6cdb1db">
<h2 id="org6cdb1db">The Data</h2>
<div class="outline-text-2" id="text-org6cdb1db"></div>
<div class="outline-3" id="outline-container-orgcc7c8c3">
<h3 id="orgcc7c8c3">The Path To the Data</h3>
<div class="outline-text-3" id="text-orgcc7c8c3">
<div class="highlight">
<pre><span></span>load_dotenv()
path = DataPathTwo(folder_key="MNIST")
</pre></div>
<div class="highlight">
<pre><span></span>print(path.folder)
print(path.folder.exists())
</pre></div>
<pre class="example">
/home/hades/datasets/MNIST
True
</pre></div>
</div>
<div class="outline-3" id="outline-container-org36664c3">
<h3 id="org36664c3">Some Settings</h3>
<div class="outline-text-3" id="text-org36664c3">
<p>Since I downloaded the data earlier for some other exercise forking sub-processes is probably unnecessary, and for the training and testing we'll use a relatively small batch-size of 20.</p>
<div class="highlight">
<pre><span></span>WORKERS = 0
BATCH_SIZE = 20
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org7bc43a4">
<h3 id="org7bc43a4">A Transform</h3>
<div class="outline-text-3" id="text-org7bc43a4">
<p>We're just going to convert the images to tensors.</p>
<div class="highlight">
<pre><span></span>transform = transforms.ToTensor()
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org9b843df">
<h3 id="org9b843df">Split Up the Training and Testing Data</h3>
<div class="outline-text-3" id="text-org9b843df">
<div class="highlight">
<pre><span></span>train_data = datasets.MNIST(root=path.folder, train=True,
                            download=True, transform=transform)
test_data = datasets.MNIST(root=path.folder, train=False,
                           download=True, transform=transform)
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgc844846">
<h3 id="orgc844846">Create the Batch Loaders</h3>
<div class="outline-text-3" id="text-orgc844846">
<div class="highlight">
<pre><span></span>train_batches = torch.utils.data.DataLoader(train_data, batch_size=BATCH_SIZE,
                                            num_workers=WORKERS)
test_batches = torch.utils.data.DataLoader(test_data, batch_size=BATCH_SIZE, 
                                           num_workers=WORKERS)
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org757eab1">
<h2 id="org757eab1">Visualize a Batch of Training Data</h2>
<div class="outline-text-2" id="text-org757eab1">
<p>The first step in a classification task is to take a look at the data, make sure it is loaded in correctly, then make any initial observations about patterns in that data.</p>
</div>
<div class="outline-3" id="outline-container-org7b13a2a">
<h3 id="org7b13a2a">Grab a batch</h3>
<div class="outline-text-3" id="text-org7b13a2a">
<div class="highlight">
<pre><span></span>images, labels = iter(train_batches).next()
images = images.numpy()
</pre></div>
<p>Now that we have a batch we're going to plot the images in the batch, along with the corresponding labels.</p>
<div class="highlight">
<pre><span></span>figure = pyplot.figure(figsize=(25, 4))
figure.suptitle("First Batch", weight="bold")
for index in numpy.arange(BATCH_SIZE):
    ax = figure.add_subplot(2, BATCH_SIZE/2, index+1, xticks=[], yticks=[])
    ax.imshow(numpy.squeeze(images[index]), cmap='gray')
    # print out the correct label for each image
    # .item() gets the value contained in a Tensor
    ax.set_title(str(labels[index].item()))
</pre></div>
<div class="figure" id="org019a470">
<p><img alt="batch.png" src="posts/nano/cnn/mnist-mlp/batch.png"></p>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orge487814">
<h3 id="orge487814">View a Single Image</h3>
<div class="outline-text-3" id="text-orge487814">
<p>Now we're going to take a closer look at the second image in the batch.</p>
<div class="highlight">
<pre><span></span>image = numpy.squeeze(images[1])

figure = pyplot.figure(figsize = (12,12)) 
ax = figure.add_subplot(111)
ax.imshow(image, cmap='gray')
width, height = image.shape
threshold = image.max()/2.5
for x in range(width):
    for y in range(height):
        val = round(image[x][y],2) if image[x][y] !=0 else 0
        ax.annotate(str(val), xy=(y,x),
                    horizontalalignment='center',
                    verticalalignment='center',
                    color='white' if image[x][y]&lt;threshold else 'black')
</pre></div>
<div class="figure" id="org146cfdb">
<p><img alt="image.png" src="posts/nano/cnn/mnist-mlp/image.png"></p>
</div>
<p>We're looking at a single image with the normalized values for each pixel superimposed on it. It looks like black is 0 and white is 1, although for this image most of the 'white' pixels are just a little less than one.</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgf4faf6a">
<h2 id="orgf4faf6a">Define the Network <a href="http://pytorch.org/docs/stable/nn.html">Architecture</a></h2>
<div class="outline-text-2" id="text-orgf4faf6a">
<p>The architecture will be responsible for seeing as input a 784-dim Tensor of pixel values for each image, and producing a Tensor of length 10 (our number of classes) that indicates the class scores for an input image. This particular example uses two hidden layers and dropout to avoid overfitting.</p>
<p>These values are based on the <a href="https://github.com/keras-team/keras/blob/master/examples/mnist_mlp.py">keras</a> example implementation.</p>
<div class="highlight">
<pre><span></span>INPUT_NODES = 28 * 28
HIDDEN_NODES = 512
DROPOUT = 0.2
CLASSES = 10
</pre></div>
<div class="highlight">
<pre><span></span>class Net(nn.Module):
    def __init__(self):
        super().__init__()        
        self.fully_connected_layer_1 = nn.Linear(INPUT_NODES, HIDDEN_NODES)
        self.fully_connected_layer_2 = nn.Linear(HIDDEN_NODES, HIDDEN_NODES)
        self.output = nn.Linear(HIDDEN_NODES, CLASSES)
        self.dropout = nn.Dropout(p=DROPOUT)
        return

    def forward(self, x):
        # flatten image input
        x = x.view(-1, 28 * 28)
        # add hidden layer, with relu activation function
        x = self.dropout(F.relu(self.fully_connected_layer_1(x)))
        x = self.dropout(F.relu(self.fully_connected_layer_2(x)))        
        return self.output(x)
</pre></div>
</div>
<div class="outline-3" id="outline-container-orgd841e77">
<h3 id="orgd841e77">Initialize the NN</h3>
<div class="outline-text-3" id="text-orgd841e77">
<div class="highlight">
<pre><span></span>model = Net()
print(model)
</pre></div>
<pre class="example">
Net(
  (fully_connected_layer_1): Linear(in_features=784, out_features=512, bias=True)
  (fully_connected_layer_2): Linear(in_features=512, out_features=512, bias=True)
  (output): Linear(in_features=512, out_features=10, bias=True)
  (dropout): Dropout(p=0.2)
)
</pre></div>
</div>
<div class="outline-3" id="outline-container-org3c431ba">
<h3 id="org3c431ba">A Little CUDA</h3>
<div class="outline-text-3" id="text-org3c431ba">
<div class="highlight">
<pre><span></span>device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model.to(device)
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org338ab1f">
<h2 id="org338ab1f">Specify the <a href="http://pytorch.org/docs/stable/nn.html#loss-functions">Loss Function</a> and <a href="http://pytorch.org/docs/stable/optim.html">Optimizer</a></h2>
<div class="outline-text-2" id="text-org338ab1f">
<p>It's recommended that you use <a href="http://pytorch.org/docs/stable/nn.html#loss-functions">cross-entropy loss</a> for classification. If you look at the documentation you can see that PyTorch's cross entropy function applies a softmax function to the output layer <b>and</b> then calculates the log loss (so you don't want to do softmax as part of the model output).</p>
<div class="highlight">
<pre><span></span>criterion = nn.CrossEntropyLoss()
optimizer = torch.optim.SGD(model.parameters(), lr=0.01)
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-orgfbe5e4e">
<h2 id="orgfbe5e4e">Train the Network</h2>
<div class="outline-text-2" id="text-orgfbe5e4e">
<p>The steps for training/learning from a batch of data are:</p>
<ol class="org-ol">
<li>Clear the gradients of all optimized variables</li>
<li>Forward pass: compute predicted outputs by passing inputs to the model</li>
<li>Calculate the loss</li>
<li>Backward pass: compute gradient of the loss with respect to model parameters</li>
<li>Perform a single optimization step (parameter update)</li>
<li>Update average training loss</li>
</ol>
<p>The following loop trains for 30 epochs; feel free to change this number. For now, we suggest somewhere between 20-50 epochs. As you train, take a look at how the values for the training loss decrease over time. We want it to decrease while also avoiding overfitting the training data.</p>
<div class="highlight">
<pre><span></span>EPOCHS = 30
</pre></div>
<div class="highlight">
<pre><span></span>start = datetime.now()
model.train() # prep model for training

for epoch in range(EPOCHS):
    # monitor training loss
    train_loss = 0.0
    train_losses = []
    # train the model
    for data, target in train_batches:
        # move it to the GPU or CPU
        data, target = data.to(device), target.to(device)
        # clear the gradients of all optimized variables
        optimizer.zero_grad()
        # forward pass: compute predicted outputs by passing inputs to the model
        output = model(data)
        # calculate the loss
        loss = criterion(output, target)
        # backward pass: compute gradient of the loss with respect to model parameters
        loss.backward()
        # perform a single optimization step (parameter update)
        optimizer.step()
        # update running training loss
        train_loss += loss.item() * data.size(0)

        # print training statistics 
        # calculate average loss over an epoch
    train_loss = train_loss/len(train_batches.dataset)
    train_losses.append(train_loss)
    print('Epoch: {} \tTraining Loss: {:.6f}'.format(
        epoch+1, 
        train_loss
        ))
print("Training Time: {}".format(datetime.now() - start))
</pre></div>
<pre class="example" id="org8dccbc0">
Epoch: 1        Training Loss: 0.826836
Epoch: 2        Training Loss: 0.324859
Epoch: 3        Training Loss: 0.251608
Epoch: 4        Training Loss: 0.202294
Epoch: 5        Training Loss: 0.170231
Epoch: 6        Training Loss: 0.146775
Epoch: 7        Training Loss: 0.127352
Epoch: 8        Training Loss: 0.115026
Epoch: 9        Training Loss: 0.104332
Epoch: 10       Training Loss: 0.093575
Epoch: 11       Training Loss: 0.084913
Epoch: 12       Training Loss: 0.077826
Epoch: 13       Training Loss: 0.071506
Epoch: 14       Training Loss: 0.067273
Epoch: 15       Training Loss: 0.063749
Epoch: 16       Training Loss: 0.058150
Epoch: 17       Training Loss: 0.054770
Epoch: 18       Training Loss: 0.051584
Epoch: 19       Training Loss: 0.047762
Epoch: 20       Training Loss: 0.045219
Epoch: 21       Training Loss: 0.041732
Epoch: 22       Training Loss: 0.040526
Epoch: 23       Training Loss: 0.038247
Epoch: 24       Training Loss: 0.035713
Epoch: 25       Training Loss: 0.033801
Epoch: 26       Training Loss: 0.031963
Epoch: 27       Training Loss: 0.031082
Epoch: 28       Training Loss: 0.028971
Epoch: 29       Training Loss: 0.027500
Epoch: 30       Training Loss: 0.026876
Training Time: 0:05:59.808071
</pre></div>
</div>
<div class="outline-2" id="outline-container-orgbe4fdef">
<h2 id="orgbe4fdef">Test the Trained Network</h2>
<div class="outline-text-2" id="text-orgbe4fdef">
<p>Finally, we test our best model on previously unseen <b>test data</b> and evaluate it's performance. Testing on unseen data is a good way to check that our model generalizes well. It may also be useful to be granular in this analysis and take a look at how this model performs on each class as well as looking at its overall loss and accuracy.</p>
</div>
<div class="outline-3" id="outline-container-orga118ab7">
<h3 id="orga118ab7"><code>model.eval()</code></h3>
<div class="outline-text-3" id="text-orga118ab7">
<p><code>model.eval(</code>) will set all the layers in your model to evaluation mode. This affects layers like dropout layers that turn "off" nodes during training with some probability, but should allow every node to be "on" for evaluation!</p>
</div>
</div>
<div class="outline-3" id="outline-container-org4720875">
<h3 id="org4720875">Set Up the Testing</h3>
<div class="outline-text-3" id="text-org4720875">
<div class="highlight">
<pre><span></span><span class="n">test_loss</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">class_correct</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="mf">0.</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">class_total</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="mf">0.</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

<span class="k">for</span> <span class="n">data</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">test_batches</span><span class="p">:</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">target</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="c1"># forward pass: compute predicted outputs by passing inputs to the model</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="c1"># calculate the loss</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
    <span class="c1"># update test loss </span>
    <span class="n">test_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># convert output probabilities to predicted class</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">prediction</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># compare predictions to true label</span>
    <span class="n">correct</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">prediction</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">view_as</span><span class="p">(</span><span class="n">prediction</span><span class="p">)))</span>
    <span class="c1"># calculate test accuracy for each object class</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">BATCH_SIZE</span><span class="p">):</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">class_correct</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">+=</span> <span class="n">correct</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">class_total</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Test Time: </span><span class="si">{}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
</pre></div>
<pre class="example">
Test Time: 0:00:01.860151
</pre></div>
</div>
<div class="outline-3" id="outline-container-org713eaaa">
<h3 id="org713eaaa">Calculate and Print Average Test Loss</h3>
<div class="outline-text-3" id="text-org713eaaa">
<div class="highlight">
<pre><span></span><span class="n">test_loss</span> <span class="o">=</span> <span class="n">test_loss</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">test_batches</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Test Loss: </span><span class="si">{:.6f}</span><span class="se">\n</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">test_loss</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">class_total</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Test Accuracy of Batch </span><span class="si">{}</span><span class="s1">: </span><span class="si">{:.2f}</span><span class="s1"> (</span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">)'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">class_correct</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">class_total</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">class_correct</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">class_total</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Test Accuracy of </span><span class="si">{}</span><span class="s1">: N/A (no training examples)'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">classes</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">Test Accuracy (Overall): </span><span class="si">%2d%%</span><span class="s1"> (</span><span class="si">%2d</span><span class="s1">/</span><span class="si">%2d</span><span class="s1">)'</span> <span class="o">%</span> <span class="p">(</span>
    <span class="mf">100.</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">class_correct</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">class_total</span><span class="p">),</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">class_correct</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">class_total</span><span class="p">)))</span>
</pre></div>
<pre class="example" id="org9c488fa">
Test Loss: 0.056054

Test Accuracy of Batch 0: 99.18 (972.0/980.0)
Test Accuracy of Batch 1: 99.21 (1126.0/1135.0)
Test Accuracy of Batch 2: 98.16 (1013.0/1032.0)
Test Accuracy of Batch 3: 98.02 (990.0/1010.0)
Test Accuracy of Batch 4: 98.47 (967.0/982.0)
Test Accuracy of Batch 5: 98.43 (878.0/892.0)
Test Accuracy of Batch 6: 98.12 (940.0/958.0)
Test Accuracy of Batch 7: 97.47 (1002.0/1028.0)
Test Accuracy of Batch 8: 97.13 (946.0/974.0)
Test Accuracy of Batch 9: 98.12 (990.0/1009.0)

Test Accuracy (Overall): 98% (9824/10000)
</pre></div>
</div>
<div class="outline-3" id="outline-container-orgddd42dc">
<h3 id="orgddd42dc">Visualize Sample Test Results</h3>
<div class="outline-text-3" id="text-orgddd42dc">
<p>This cell displays test images and their labels in this format: <code>predicted (ground-truth)</code>. The text will be green for accurately classified examples and red for incorrect predictions.</p>
</div>
<div class="outline-4" id="outline-container-org2976828">
<h4 id="org2976828">Obtain One Batch of Test Images</h4>
<div class="outline-text-4" id="text-org2976828">
<div class="highlight">
<pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
<span class="n">dataiter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">test_batches</span><span class="p">)</span>
<span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">dataiter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>

<span class="c1"># get sample outputs</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
<span class="c1"># convert output probabilities to predicted class</span>
<span class="n">_</span><span class="p">,</span> <span class="n">preds</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1"># prep images for display</span>
<span class="n">images</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="c1"># plot the images in the batch, along with predicted and true labels</span>
<span class="n">fig</span> <span class="o">=</span> <span class="n">pyplot</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">xticks</span><span class="o">=</span><span class="p">[],</span> <span class="n">yticks</span><span class="o">=</span><span class="p">[])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'gray'</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2"> (</span><span class="si">{}</span><span class="s2">)"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">preds</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()),</span> <span class="nb">str</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())),</span>
                 <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="s2">"green"</span> <span class="k">if</span> <span class="n">preds</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">==</span><span class="n">labels</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">else</span> <span class="s2">"red"</span><span class="p">))</span>
</pre></div>
<div class="figure" id="orgd0abe7f">
<p><img alt="test.png" src="posts/nano/cnn/mnist-mlp/test.png"></p>
</div>
<p>This model is surprisingly accurate. I say surprising, even though we created a very accurate model previously, because in my original implementation I used <code>RMSprop</code> as the optimizer, because that's what the Keras implementation used, but then I only got 11%. I'm guessing that there's some extra tuning you need to do to the parameters for <code>RMSprop</code> but I just naively used the defaults. In any case, it semms that SGD is still the champ.</p>
</div>
</div>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/nano/dog-breed-classifier/dog-classification-project-overview/">Dog Classification Project Overview</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/nano/dog-breed-classifier/dog-classification-project-overview/" rel="bookmark"><time class="published dt-published" datetime="2018-11-25T16:33:14-08:00" itemprop="datePublished" title="2018-11-25 16:33">2018-11-25 16:33</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/nano/dog-breed-classifier/dog-classification-project-overview/#org2078e55">Project Overview</a></li>
<li><a href="posts/nano/dog-breed-classifier/dog-classification-project-overview/#org04778e1">The Data</a></li>
<li><a href="posts/nano/dog-breed-classifier/dog-classification-project-overview/#orgbdf7fd0">Some Rules</a></li>
<li><a href="posts/nano/dog-breed-classifier/dog-classification-project-overview/#org6bf7c5d">(Optionally) Accelerating the Training Process</a></li>
<li><a href="posts/nano/dog-breed-classifier/dog-classification-project-overview/#orgad2e37c">Evaluation</a></li>
<li><a href="posts/nano/dog-breed-classifier/dog-classification-project-overview/#orgf6b1e6b">Project Submission</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org2078e55">
<h2 id="org2078e55">Project Overview</h2>
<div class="outline-text-2" id="text-org2078e55">
<p>In this project we will build a pipeline that can be used within a web or mobile app to process real-world, user-supplied images. Given an image of a dog, our algorithm will identify an estimate of the canine’s breed. If supplied an image of a human, the code will identify the dog breed that the person most resembles.</p>
</div>
</div>
<div class="outline-2" id="outline-container-org04778e1">
<h2 id="org04778e1">The Data</h2>
<div class="outline-text-2" id="text-org04778e1">
<p>The <a href="https://s3-us-west-1.amazonaws.com/udacity-aind/dog-project/dogImages.zip">dog dataset</a> is in a zip-file hosted on Amazon Web Services. The folder should contain three folders (<code>test</code>, <code>train</code>, and <code>valid</code>) and each of these folders should have 133 folders, one for each dog-breed. It looks like the <a href="http://vision.stanford.edu/aditya86/ImageNetDogs/">Stanford Dogs Dataset</a>, but the Stanford data set has 120 breeds, so I don't know the actual source. The <a href="http://vis-www.cs.umass.edu/lfw/lfw.tgz">human dataset</a> seems to be the <a href="http://vis-www.cs.umass.edu/lfw/">Labeled Faces in the Wild</a> data set which was built to study the problem of facial recognition. It's made up of real photos of people taken from the web. Each photo sits in a sub-folder that was given the name of the person (e.g. <code>Michelle_Yeoh</code>). The folder hasn't been split into train-test-validiation folders the way the dog dataset was.</p>
</div>
</div>
<div class="outline-2" id="outline-container-orgbdf7fd0">
<h2 id="orgbdf7fd0">Some Rules</h2>
<div class="outline-text-2" id="text-orgbdf7fd0">
<ul class="org-ul">
<li><b>Unless requested, do not modify code that has already been included.</b></li>
<li>In the notebook, you will need to train CNNs in PyTorch. If your CNN is taking too long to train, feel free to pursue one of the options under the section <i>Accelerating the Training Process</i> below.</li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org6bf7c5d">
<h2 id="org6bf7c5d">(Optionally) Accelerating the Training Process</h2>
<div class="outline-text-2" id="text-org6bf7c5d">
<p>If your code is taking too long to run, you will need to either reduce the complexity of your chosen CNN architecture or switch to running your code on a GPU. If you'd like to use a GPU, you can spin up an instance of your own:</p>
</div>
<div class="outline-3" id="outline-container-orge869614">
<h3 id="orge869614">Amazon Web Services</h3>
<div class="outline-text-3" id="text-orge869614">
<p>You can use Amazon Web Services to launch an EC2 GPU instance. (This costs money, but enrolled students should see a coupon code in their student <code>resources</code>.)</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgad2e37c">
<h2 id="orgad2e37c">Evaluation</h2>
<div class="outline-text-2" id="text-orgad2e37c">
<p>Your project will be reviewed by a Udacity reviewer against the CNN project rubric. Review this rubric thoroughly and self-evaluate your project before submission. All criteria found in the rubric must meet specifications for you to pass.</p>
</div>
</div>
<div class="outline-2" id="outline-container-orgf6b1e6b">
<h2 id="orgf6b1e6b">Project Submission</h2>
<div class="outline-text-2" id="text-orgf6b1e6b">
<p>Your submission should consist of the github link to your repository. Your repository should contain:</p>
<ul class="org-ul">
<li>The <code>dog_app.ipynb</code> file with fully functional code, all code cells executed and displaying output, and all questions answered.</li>
<li>An HTML or PDF export of the project notebook with the name <code>report.html</code> or <code>report.pdf</code>.</li>
</ul>
<p>Please do <i>NOT</i> include any of the project data sets provided in the <code>dogImages/</code> or <code>lfw/</code> folders.</p>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/nano/pytorch/transfer-learning-one-more-time/">Transfer Learning One More Time</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/nano/pytorch/transfer-learning-one-more-time/" rel="bookmark"><time class="published dt-published" datetime="2018-11-25T14:55:58-08:00" itemprop="datePublished" title="2018-11-25 14:55">2018-11-25 14:55</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/nano/pytorch/transfer-learning-one-more-time/#org0ab6d65">Introduction</a></li>
<li><a href="posts/nano/pytorch/transfer-learning-one-more-time/#org4c1df65">Set Up</a></li>
<li><a href="posts/nano/pytorch/transfer-learning-one-more-time/#orgf32d2db">The Data</a></li>
<li><a href="posts/nano/pytorch/transfer-learning-one-more-time/#org90fe166">The DenseNet Model</a></li>
<li><a href="posts/nano/pytorch/transfer-learning-one-more-time/#org264951a">Add Some CUDA</a></li>
<li><a href="posts/nano/pytorch/transfer-learning-one-more-time/#orgbdb60e6">Train It</a></li>
</ul>
</div>
</div>
<p>I spent so much time debugging the original post that I though I'd re-do it without all the flailing around.</p>
<div class="outline-2" id="outline-container-org0ab6d65">
<h2 id="org0ab6d65">Introduction</h2>
<div class="outline-text-2" id="text-org0ab6d65">
<p>This is from <a href="https://github.com/udacity/deep-learning-v2-pytorch.git">Udacity's Deep Learning Repository</a> which supports their Deep Learning Nanodegree.</p>
<p>This uses a model trained on <a href="http://www.image-net.org/">ImageNet</a> (<a href="http://pytorch.org/docs/0.3.0/torchvision/models.html">available from torchvision</a>) to classify the <a href="https://www.kaggle.com/c/dogs-vs-cats">dataset of cat and dog photos</a> that we used earlier. We're going to use a method called <a href="https://en.wikipedia.org/wiki/Transfer_learning">transfer learning</a> where we will use the layers of the pretrained model all the way up until the final classifier which we will define ourselves and train on our new data-set. This way we can take advantage of what the model has already learned for image detection and only train a few layers.</p>
</div>
</div>
<div class="outline-2" id="outline-container-org4c1df65">
<h2 id="org4c1df65">Set Up</h2>
<div class="outline-text-2" id="text-org4c1df65"></div>
<div class="outline-3" id="outline-container-orga5e9000">
<h3 id="orga5e9000">Imports</h3>
<div class="outline-text-3" id="text-orga5e9000"></div>
<div class="outline-4" id="outline-container-orgf4bee6f">
<h4 id="orgf4bee6f">Python</h4>
<div class="outline-text-4" id="text-orgf4bee6f">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orge95afd9">
<h4 id="orge95afd9">PyPi</h4>
<div class="outline-text-4" id="text-orge95afd9">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">optim</span>
<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">transforms</span><span class="p">,</span> <span class="n">models</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org06c7563">
<h4 id="org06c7563">This Project</h4>
<div class="outline-text-4" id="text-org06c7563">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">neurotic.tangles.data_paths</span> <span class="kn">import</span> <span class="n">DataPathTwo</span>
<span class="kn">from</span> <span class="nn">neurotic.models.fashion</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">train_only</span><span class="p">,</span>
    <span class="n">test_only</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org785548a">
<h3 id="org785548a">Dotenv</h3>
<div class="outline-text-3" id="text-org785548a">
<p>For some reason dotenv has stopped working unless it's called in the notebook. Maybe this will fix it</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgf32d2db">
<h2 id="orgf32d2db">The Data</h2>
<div class="outline-text-2" id="text-orgf32d2db">
<p>We're going to have to resize the images to be 224x224 to work with the pre-trained models and match the means (<code>[0.485, 0.456, 0.406]</code>) and the standard deviations (<code>[0.229, 0.224, 0.225]</code>) that were used to normalize the original data set.</p>
<div class="highlight">
<pre><span></span><span class="n">means</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.485</span><span class="p">,</span> <span class="mf">0.456</span><span class="p">,</span> <span class="mf">0.406</span><span class="p">]</span>
<span class="n">deviations</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.229</span><span class="p">,</span> <span class="mf">0.224</span><span class="p">,</span> <span class="mf">0.225</span><span class="p">]</span>
<span class="n">PIXELS</span> <span class="o">=</span> <span class="mi">224</span>

<span class="n">train_transforms</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span><span class="n">transforms</span><span class="o">.</span><span class="n">RandomRotation</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
                                       <span class="n">transforms</span><span class="o">.</span><span class="n">RandomResizedCrop</span><span class="p">(</span><span class="n">PIXELS</span><span class="p">),</span>
                                       <span class="n">transforms</span><span class="o">.</span><span class="n">RandomHorizontalFlip</span><span class="p">(),</span>
                                       <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
                                       <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">means</span><span class="p">,</span>
                                                            <span class="n">deviations</span><span class="p">)])</span>

<span class="n">test_transforms</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span><span class="n">transforms</span><span class="o">.</span><span class="n">Resize</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
                                      <span class="n">transforms</span><span class="o">.</span><span class="n">CenterCrop</span><span class="p">(</span><span class="n">PIXELS</span><span class="p">),</span>
                                      <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
                                      <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">means</span><span class="p">,</span>
                                                           <span class="n">deviations</span><span class="p">)])</span>
</pre></div>
</div>
<div class="outline-3" id="outline-container-org6f570c1">
<h3 id="org6f570c1">Load the Data</h3>
<div class="outline-text-3" id="text-org6f570c1">
<p>As I mentioned we're using the same Cat and Dog images as before. So first I make my path-setter (which maybe isn't as useful as it was when I had dotenv working better).</p>
<div class="highlight">
<pre><span></span><span class="n">train_path</span> <span class="o">=</span> <span class="n">DataPathTwo</span><span class="p">(</span><span class="n">folder_key</span><span class="o">=</span><span class="s2">"CAT_DOG_TRAIN"</span><span class="p">)</span>
<span class="n">test_path</span> <span class="o">=</span> <span class="n">DataPathTwo</span><span class="p">(</span><span class="n">folder_key</span><span class="o">=</span><span class="s2">"CAT_DOG_TEST"</span><span class="p">)</span>
</pre></div>
<p>So now we set up the testing and training data sets.</p>
<div class="highlight">
<pre><span></span><span class="n">train_data</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">ImageFolder</span><span class="p">(</span><span class="n">train_path</span><span class="o">.</span><span class="n">folder</span><span class="p">,</span>
                                  <span class="n">transform</span><span class="o">=</span><span class="n">train_transforms</span><span class="p">)</span>
<span class="n">test_data</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">ImageFolder</span><span class="p">(</span><span class="n">test_path</span><span class="o">.</span><span class="n">folder</span><span class="p">,</span>
                                 <span class="n">transform</span><span class="o">=</span><span class="n">test_transforms</span><span class="p">)</span>
</pre></div>
<p>And create the batch-iterators with a batch-size of 64.</p>
<div class="highlight">
<pre><span></span><span class="n">BATCH_SIZE</span> <span class="o">=</span> <span class="mi">64</span>
<span class="n">train_batches</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">BATCH_SIZE</span><span class="p">,</span>
                                            <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">test_batches</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">test_data</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">BATCH_SIZE</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org90fe166">
<h2 id="org90fe166">The DenseNet Model</h2>
<div class="outline-text-2" id="text-org90fe166">
<p>I'm going to load the <a href="http://pytorch.org/docs/0.3.0/torchvision/models.html#id5">DenseNet</a> model.</p>
<div class="highlight">
<pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">densenet121</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
<p>It actually emits a warning that the code is using an incorrect method call somewhere, but I'll ignore that.</p>
<pre class="example" id="orgeae3579">
UserWarning: nn.init.kaiming_normal is now deprecated in favor of nn.init.kaiming_normal_.
 nn.init.kaiming_normal(m.weight.data)
</pre></div>
<div class="outline-3" id="outline-container-org0cdbc6f">
<h3 id="org0cdbc6f">Freeze The Model Parameters</h3>
<div class="outline-text-3" id="text-org0cdbc6f">
<p>We need to freeze the parameters before training so we don't end up trying to re-train our pre-trained network.</p>
<div class="highlight">
<pre><span></span><span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
    <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgd913d7d">
<h3 id="orgd913d7d">The Classifier</h3>
<div class="outline-text-3" id="text-orgd913d7d">
<p>So this is the part where we add our own classifier at the end so that we can train it on cats and dogs. I'll use the original 500 fully connected nodes instead of the 256 I ended up with in my previous attempt.</p>
<p>To figure out the inputs to the layer we can just look at the original <code>classifier</code> layer in the model.</p>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">classifier</span><span class="p">)</span>
</pre></div>
<pre class="example">
Linear(in_features=1024, out_features=1000, bias=True)
</pre>
<p>So we need to make sure we have 1,024 inputs to our classification layer and change the number of outputs to 2 (since we have only dogs and cats). We're also going to use two layers, the first one will have a ReLU activation and the second (the output) will have a <a href="https://pytorch.org/docs/stable/nn.html?highlight=logsoftmax#torch.nn.LogSoftmax">Log-Softmax</a> activation.</p>
<div class="highlight">
<pre><span></span><span class="n">HIDDEN_NODES</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">INPUT_NODES</span> <span class="o">=</span> <span class="mi">1024</span>
<span class="n">OUTPUT_NODES</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">([</span>
                          <span class="p">(</span><span class="s1">'fully_connected_layer'</span><span class="p">,</span>
                           <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">INPUT_NODES</span><span class="p">,</span> <span class="n">HIDDEN_NODES</span><span class="p">)),</span>
                          <span class="p">(</span><span class="s1">'relu'</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()),</span>
                          <span class="p">(</span><span class="s2">"dropout"</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)),</span>
                          <span class="p">(</span><span class="s1">'fully_connected_layer_2'</span><span class="p">,</span>
                           <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">HIDDEN_NODES</span><span class="p">,</span> <span class="n">OUTPUT_NODES</span><span class="p">)),</span>
                          <span class="p">(</span><span class="s1">'output'</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">LogSoftmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                          <span class="p">]))</span>
<span class="n">model</span><span class="o">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">classifier</span>
</pre></div>
<p>So we now have a (mostly) pre-trained deep neural network with an untrained classifier.</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org264951a">
<h2 id="org264951a">Add Some CUDA</h2>
<div class="outline-text-2" id="text-org264951a">
<p>To speed this up somewhat I'll add (if it's available) a little cuda.</p>
<div class="highlight">
<pre><span></span><span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">"cuda"</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">"cpu"</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
</pre></div>
</div>
<div class="outline-3" id="outline-container-org00f14ec">
<h3 id="org00f14ec">Add some more CUDA</h3>
<div class="outline-text-3" id="text-org00f14ec">
<p>This next bit doesn't work on any of my machines, but maybe someday.</p>
<div class="highlight">
<pre><span></span><span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">device_count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Using </span><span class="si">{}</span><span class="s2"> GPUs"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">device_count</span><span class="p">()))</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">DataParallel</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Only 1 GPU available"</span><span class="p">)</span>
</pre></div>
<pre class="example">
Only 1 GPU available
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-orgbdb60e6">
<h2 id="orgbdb60e6">Train It</h2>
<div class="outline-text-2" id="text-orgbdb60e6">
<p>First we'll set up our criterion - Negative Log Likelihood Loss (<a href="https://pytorch.org/docs/stable/nn.html?highlight=nllloss#torch.nn.NLLLoss">NLLLoss</a>) and optimizer - <a href="https://pytorch.org/docs/stable/optim.html?highlight=adam#torch.optim.Adam">Adam</a> Optimization. Amazingly this only needs one pass through the data set. There's 352 batches in the training data-set so I won't print out each of the outcomes for the epochs.</p>
<div class="highlight">
<pre><span></span><span class="n">LEARNING_RATE</span> <span class="o">=</span> <span class="mf">0.003</span>
<span class="n">EPOCHS</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">NLLLoss</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">LEARNING_RATE</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="n">outcome</span> <span class="o">=</span> <span class="n">train_only</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span>
                     <span class="n">train_batches</span><span class="p">,</span>
                     <span class="n">epochs</span><span class="o">=</span><span class="n">EPOCHS</span><span class="p">,</span> <span class="n">emit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Training Time: </span><span class="si">{}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
</pre></div>
<pre class="example">
Training Time: 0:10:35.847469
</pre>
<div class="highlight">
<pre><span></span><span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="n">test_outcome</span> <span class="o">=</span> <span class="n">test_only</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">test_batches</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Test Time: </span><span class="si">{}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
</pre></div>
<pre class="example">
Test Time: 0:00:46.695136
</pre>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">test_outcome</span><span class="p">)</span>
</pre></div>
<pre class="example">
0.9788
</pre>
<p>The key bit here was that I was earlier forgetting to add dropout, dropping the accuracy to between .5 and .6.</p>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/nano/pytorch/tips-tricks-and-other-notes/">Tips, Tricks and Other Notes</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/nano/pytorch/tips-tricks-and-other-notes/" rel="bookmark"><time class="published dt-published" datetime="2018-11-25T14:13:27-08:00" itemprop="datePublished" title="2018-11-25 14:13">2018-11-25 14:13</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/nano/pytorch/tips-tricks-and-other-notes/#orgaf8ba03">On Shapes</a></li>
<li><a href="posts/nano/pytorch/tips-tricks-and-other-notes/#org628a516">Troubleshooting Training</a></li>
<li><a href="posts/nano/pytorch/tips-tricks-and-other-notes/#org5c43663">CUDA Problems</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-orgaf8ba03">
<h2 id="orgaf8ba03">On Shapes</h2>
<div class="outline-text-2" id="text-orgaf8ba03">
<p>As the tensors go through the model you should check the shapes to make sure they are correct (or at least what you expect).</p>
</div>
</div>
<div class="outline-2" id="outline-container-org628a516">
<h2 id="org628a516">Troubleshooting Training</h2>
<div class="outline-text-2" id="text-org628a516">
<ul class="org-ul">
<li>Make sure you are clearing the gradients in the training loop with <code>optimizer.zero_grad()</code></li>
<li>In the validation loop, set the network to evaluation mode with <code>model.eval()</code> and then back to training mode with <code>model.train</code></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org5c43663">
<h2 id="org5c43663">CUDA Problems</h2>
<div class="outline-text-2" id="text-org5c43663">
<p>If you see an error saying pytorch <code>Expected an object of type torch.FloatTensor but found type torch.cuda.FloatTensor</code> then it means something is trying to be run on the CPU but something else wants to use the GPU. Make sure you called <code>.to(device)</code> on the model and all your tensors (including the data).</p>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/nano/pytorch/part-8-transfer-learning/">Part 8 - Transfer Learning</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/nano/pytorch/part-8-transfer-learning/" rel="bookmark"><time class="published dt-published" datetime="2018-11-23T18:01:33-08:00" itemprop="datePublished" title="2018-11-23 18:01">2018-11-23 18:01</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/nano/pytorch/part-8-transfer-learning/#orgb222003">Introduction</a></li>
<li><a href="posts/nano/pytorch/part-8-transfer-learning/#org17a923d">Set Up</a></li>
<li><a href="posts/nano/pytorch/part-8-transfer-learning/#org7f032f7">The Data</a></li>
<li><a href="posts/nano/pytorch/part-8-transfer-learning/#org080bbe5">The DenseNet Model</a></li>
<li><a href="posts/nano/pytorch/part-8-transfer-learning/#orge761454">Using CUDA</a></li>
<li><a href="posts/nano/pytorch/part-8-transfer-learning/#org55d39c7">Train the Model</a></li>
<li><a href="posts/nano/pytorch/part-8-transfer-learning/#org89c696e">Train Some More</a></li>
<li><a href="posts/nano/pytorch/part-8-transfer-learning/#org156f8bd">Another Model</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-orgb222003">
<h2 id="orgb222003">Introduction</h2>
<div class="outline-text-2" id="text-orgb222003">
<p>This is from <a href="https://github.com/udacity/deep-learning-v2-pytorch.git">Udacity's Deep Learning Repository</a> which supports their Deep Learning Nanodegree.</p>
<p>In this notebook, you'll learn how to use pre-trained networks to solved challenging problems in computer vision. Specifically, you'll use networks trained on <a href="http://www.image-net.org/">ImageNet</a> (<a href="http://pytorch.org/docs/0.3.0/torchvision/models.html">available from torchvision</a>).</p>
<p>ImageNet is a massive dataset with over 1 million labeled images in 1000 categories. It's used to train deep neural networks using an architecture called convolutional layers. I'm not going to get into the details of convolutional networks here, but if you want to learn more about them, please <a href="https://www.youtube.com/watch?v=2-Ol7ZB0MmU">watch this</a>.</p>
<p>Once trained, these models work astonishingly well as feature detectors for images they weren't trained on. Using a pre-trained network on images not in the training set is called transfer learning. Here we'll use transfer learning to train a network that can classify our cat and dog photos with near perfect accuracy.</p>
<p>With <a href="https://pytorch.org/docs/stable/torchvision/models.html"><code>torchvision.models</code></a> you can download these pre-trained networks and use them in your applications. We'll include <code>models</code> in our imports now.</p>
</div>
</div>
<div class="outline-2" id="outline-container-org17a923d">
<h2 id="org17a923d">Set Up</h2>
<div class="outline-text-2" id="text-org17a923d"></div>
<div class="outline-3" id="outline-container-orgb545d59">
<h3 id="orgb545d59">Imports</h3>
<div class="outline-text-3" id="text-orgb545d59"></div>
<div class="outline-4" id="outline-container-org6614eca">
<h4 id="org6614eca">Python</h4>
<div class="outline-text-4" id="text-org6614eca">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org4058a13">
<h4 id="org4058a13">PyPi</h4>
<div class="outline-text-4" id="text-org4058a13">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">optim</span>
<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">transforms</span><span class="p">,</span> <span class="n">models</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgb9f97fc">
<h4 id="orgb9f97fc">This Project</h4>
<div class="outline-text-4" id="text-orgb9f97fc">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">neurotic.tangles.data_paths</span> <span class="kn">import</span> <span class="n">DataPathTwo</span>
<span class="kn">from</span> <span class="nn">neurotic.models.fashion</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">test_only</span><span class="p">,</span>
    <span class="n">train_only</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org641b0de">
<h3 id="org641b0de">Dotenv</h3>
<div class="outline-text-3" id="text-org641b0de">
<p>For some reason dotenv has stopped working unless it's called in the notebook. Maybe this will fix it</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org7f032f7">
<h2 id="org7f032f7">The Data</h2>
<div class="outline-text-2" id="text-org7f032f7">
<p>Most of the pretrained models require the input to be 224x224 images. Also, we'll need to match the normalization used when the models were trained. Each color channel was normalized separately, the means are <code>[0.485, 0.456, 0.406]</code> and the standard deviations are <code>[0.229, 0.224, 0.225]</code>.</p>
<div class="highlight">
<pre><span></span><span class="n">means</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.485</span><span class="p">,</span> <span class="mf">0.456</span><span class="p">,</span> <span class="mf">0.406</span><span class="p">]</span>
<span class="n">deviations</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.229</span><span class="p">,</span> <span class="mf">0.224</span><span class="p">,</span> <span class="mf">0.225</span><span class="p">]</span>

<span class="n">train_transforms</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span><span class="n">transforms</span><span class="o">.</span><span class="n">RandomRotation</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
                                       <span class="n">transforms</span><span class="o">.</span><span class="n">RandomResizedCrop</span><span class="p">(</span><span class="mi">224</span><span class="p">),</span>
                                       <span class="n">transforms</span><span class="o">.</span><span class="n">RandomHorizontalFlip</span><span class="p">(),</span>
                                       <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
                                       <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">means</span><span class="p">,</span>
                                                            <span class="n">deviations</span><span class="p">)])</span>

<span class="n">test_transforms</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span><span class="n">transforms</span><span class="o">.</span><span class="n">Resize</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
                                      <span class="n">transforms</span><span class="o">.</span><span class="n">CenterCrop</span><span class="p">(</span><span class="mi">224</span><span class="p">),</span>
                                      <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
                                      <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">means</span><span class="p">,</span>
                                                           <span class="n">deviations</span><span class="p">)])</span>
</pre></div>
</div>
<div class="outline-3" id="outline-container-orgff1e2fa">
<h3 id="orgff1e2fa">Load the Data</h3>
<div class="outline-text-3" id="text-orgff1e2fa">
<p>We're going to load the Cat-Dog data set again.</p>
<div class="highlight">
<pre><span></span><span class="n">train_path</span> <span class="o">=</span> <span class="n">DataPathTwo</span><span class="p">(</span><span class="n">folder_key</span><span class="o">=</span><span class="s2">"CAT_DOG_TRAIN"</span><span class="p">)</span>
<span class="n">test_path</span> <span class="o">=</span> <span class="n">DataPathTwo</span><span class="p">(</span><span class="n">folder_key</span><span class="o">=</span><span class="s2">"CAT_DOG_TEST"</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">train_data</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">ImageFolder</span><span class="p">(</span><span class="n">train_path</span><span class="o">.</span><span class="n">folder</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">train_transforms</span><span class="p">)</span>
<span class="n">test_data</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">ImageFolder</span><span class="p">(</span><span class="n">test_path</span><span class="o">.</span><span class="n">folder</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">test_transforms</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">train_batches</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span>
                                            <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">test_batches</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">test_data</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org080bbe5">
<h2 id="org080bbe5">The DenseNet Model</h2>
<div class="outline-text-2" id="text-org080bbe5">
<p>We are going to load the <a href="http://pytorch.org/docs/0.3.0/torchvision/models.html#id5">DenseNet</a> model.</p>
<div class="highlight">
<pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">densenet121</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
<pre class="example" id="org244f214">
DenseNet(
  (features): Sequential(
    (conv0): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)
    (norm0): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
    (relu0): ReLU(inplace)
    (pool0): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False)
    (denseblock1): _DenseBlock(
      (denselayer1): _DenseLayer(
        (norm1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(64, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer2): _DenseLayer(
        (norm1): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(96, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer3): _DenseLayer(
        (norm1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(128, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer4): _DenseLayer(
        (norm1): BatchNorm2d(160, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(160, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer5): _DenseLayer(
        (norm1): BatchNorm2d(192, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(192, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer6): _DenseLayer(
        (norm1): BatchNorm2d(224, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(224, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
    )
    (transition1): _Transition(
      (norm): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (relu): ReLU(inplace)
      (conv): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
      (pool): AvgPool2d(kernel_size=2, stride=2, padding=0)
    )
    (denseblock2): _DenseBlock(
      (denselayer1): _DenseLayer(
        (norm1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(128, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer2): _DenseLayer(
        (norm1): BatchNorm2d(160, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(160, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer3): _DenseLayer(
        (norm1): BatchNorm2d(192, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(192, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer4): _DenseLayer(
        (norm1): BatchNorm2d(224, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(224, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer5): _DenseLayer(
        (norm1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer6): _DenseLayer(
        (norm1): BatchNorm2d(288, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(288, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer7): _DenseLayer(
        (norm1): BatchNorm2d(320, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(320, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer8): _DenseLayer(
        (norm1): BatchNorm2d(352, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(352, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer9): _DenseLayer(
        (norm1): BatchNorm2d(384, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(384, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer10): _DenseLayer(
        (norm1): BatchNorm2d(416, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(416, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer11): _DenseLayer(
        (norm1): BatchNorm2d(448, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(448, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer12): _DenseLayer(
        (norm1): BatchNorm2d(480, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(480, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
    )
    (transition2): _Transition(
      (norm): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (relu): ReLU(inplace)
      (conv): Conv2d(512, 256, kernel_size=(1, 1), stride=(1, 1), bias=False)
      (pool): AvgPool2d(kernel_size=2, stride=2, padding=0)
    )
    (denseblock3): _DenseBlock(
      (denselayer1): _DenseLayer(
        (norm1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(256, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer2): _DenseLayer(
        (norm1): BatchNorm2d(288, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(288, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer3): _DenseLayer(
        (norm1): BatchNorm2d(320, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(320, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer4): _DenseLayer(
        (norm1): BatchNorm2d(352, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(352, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer5): _DenseLayer(
        (norm1): BatchNorm2d(384, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(384, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer6): _DenseLayer(
        (norm1): BatchNorm2d(416, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(416, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer7): _DenseLayer(
        (norm1): BatchNorm2d(448, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(448, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer8): _DenseLayer(
        (norm1): BatchNorm2d(480, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(480, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer9): _DenseLayer(
        (norm1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer10): _DenseLayer(
        (norm1): BatchNorm2d(544, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(544, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer11): _DenseLayer(
        (norm1): BatchNorm2d(576, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(576, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer12): _DenseLayer(
        (norm1): BatchNorm2d(608, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(608, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer13): _DenseLayer(
        (norm1): BatchNorm2d(640, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(640, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer14): _DenseLayer(
        (norm1): BatchNorm2d(672, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(672, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer15): _DenseLayer(
        (norm1): BatchNorm2d(704, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(704, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer16): _DenseLayer(
        (norm1): BatchNorm2d(736, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(736, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer17): _DenseLayer(
        (norm1): BatchNorm2d(768, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(768, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer18): _DenseLayer(
        (norm1): BatchNorm2d(800, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(800, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer19): _DenseLayer(
        (norm1): BatchNorm2d(832, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(832, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer20): _DenseLayer(
        (norm1): BatchNorm2d(864, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(864, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer21): _DenseLayer(
        (norm1): BatchNorm2d(896, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(896, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer22): _DenseLayer(
        (norm1): BatchNorm2d(928, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(928, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer23): _DenseLayer(
        (norm1): BatchNorm2d(960, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(960, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer24): _DenseLayer(
        (norm1): BatchNorm2d(992, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(992, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
    )
    (transition3): _Transition(
      (norm): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (relu): ReLU(inplace)
      (conv): Conv2d(1024, 512, kernel_size=(1, 1), stride=(1, 1), bias=False)
      (pool): AvgPool2d(kernel_size=2, stride=2, padding=0)
    )
    (denseblock4): _DenseBlock(
      (denselayer1): _DenseLayer(
        (norm1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(512, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer2): _DenseLayer(
        (norm1): BatchNorm2d(544, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(544, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer3): _DenseLayer(
        (norm1): BatchNorm2d(576, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(576, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer4): _DenseLayer(
        (norm1): BatchNorm2d(608, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(608, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer5): _DenseLayer(
        (norm1): BatchNorm2d(640, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(640, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer6): _DenseLayer(
        (norm1): BatchNorm2d(672, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(672, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer7): _DenseLayer(
        (norm1): BatchNorm2d(704, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(704, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer8): _DenseLayer(
        (norm1): BatchNorm2d(736, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(736, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer9): _DenseLayer(
        (norm1): BatchNorm2d(768, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(768, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer10): _DenseLayer(
        (norm1): BatchNorm2d(800, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(800, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer11): _DenseLayer(
        (norm1): BatchNorm2d(832, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(832, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer12): _DenseLayer(
        (norm1): BatchNorm2d(864, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(864, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer13): _DenseLayer(
        (norm1): BatchNorm2d(896, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(896, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer14): _DenseLayer(
        (norm1): BatchNorm2d(928, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(928, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer15): _DenseLayer(
        (norm1): BatchNorm2d(960, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(960, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
      (denselayer16): _DenseLayer(
        (norm1): BatchNorm2d(992, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu1): ReLU(inplace)
        (conv1): Conv2d(992, 128, kernel_size=(1, 1), stride=(1, 1), bias=False)
        (norm2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
        (relu2): ReLU(inplace)
        (conv2): Conv2d(128, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      )
    )
    (norm5): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
  )
  (classifier): Linear(in_features=1024, out_features=1000, bias=True)
)
</pre>
<p>This model is built out of two main parts, the features and the classifier. The features part is a stack of convolutional layers and overall works as a feature detector that can be fed into a classifier. The classifier part is a single fully-connected layer <code>(classifier): Linear(in_features=1024, out_features=1000)</code>. This layer was trained on the ImageNet dataset, so it won't work for our specific problem. That means we need to replace the classifier, but the features will work perfectly on their own. In general, I think about pre-trained networks as amazingly good feature detectors that can be used as the input for simple feed-forward classifiers.</p>
<p>Next we want to freeze the parameters so we don't backprop through them.</p>
<div class="highlight">
<pre><span></span><span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
    <span class="n">param</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
<p>And now we build our classifier model.</p>
<div class="highlight">
<pre><span></span><span class="n">classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">([</span>
                          <span class="p">(</span><span class="s1">'fc1'</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">500</span><span class="p">)),</span>
                          <span class="p">(</span><span class="s1">'relu'</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()),</span>
                          <span class="p">(</span><span class="s1">'fc2'</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
                          <span class="p">(</span><span class="s1">'output'</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">LogSoftmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                          <span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-orge761454">
<h2 id="orge761454">Using CUDA</h2>
<div class="outline-text-2" id="text-orge761454">
<p>With our model built, we need to train the classifier. However, now we're using a <b>really deep</b> neural network. If you try to train this on a CPU like normal, it will take a long, long time. Instead, we're going to use the GPU to do the calculations. The linear algebra computations are done in parallel on the GPU leading to 100x increased training speeds. It's also possible to train on multiple GPUs, further decreasing training time.</p>
<p>PyTorch, along with pretty much every other deep learning framework, uses <a href="https://developer.nvidia.com/cuda-zone">CUDA</a> to efficiently compute the forward and backwards passes on the GPU. In PyTorch, you move your model parameters and other tensors to the GPU memory using <code>model.to('cuda')</code>. You can move them back from the GPU with <code>model.to('cpu')</code> which you'll commonly do when you need to operate on the network output outside of PyTorch. As a demonstration of the increased speed, I'll compare how long it takes to perform a forward and backward pass with and without a GPU.</p>
<div class="highlight">
<pre><span></span><span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">NLLLoss</span><span class="p">()</span>
<span class="n">device</span> <span class="o">=</span> <span class="s2">"cpu"</span>
<span class="c1"># Only train the classifier parameters, feature parameters are frozen</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.003</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">train_batches</span><span class="p">):</span>
    <span class="c1"># Move input and label tensors to the GPU</span>
    <span class="n">inputs</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">labels</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

    <span class="n">outputs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">index</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="k">break</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Device = </span><span class="si">{}</span><span class="s2">; Time per batch: </span><span class="si">{}</span><span class="s2"> seconds"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">device</span><span class="p">,</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span>
    <span class="p">))</span>
</pre></div>
<pre class="example">
Device = cpu; Time per batch: 0:00:12.372973 seconds
</pre>
<div class="highlight">
<pre><span></span><span class="n">device</span> <span class="o">=</span> <span class="s2">"cuda"</span>
<span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">NLLLoss</span><span class="p">()</span>
<span class="c1"># Only train the classifier parameters, feature parameters are frozen</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.003</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">train_batches</span><span class="p">):</span>
    <span class="c1"># Move input and label tensors to the GPU</span>
    <span class="n">inputs</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">labels</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>

    <span class="n">outputs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">index</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="k">break</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">"Device = </span><span class="si">{}</span><span class="s2">; Time per batch: </span><span class="si">{}</span><span class="s2"> seconds"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">device</span><span class="p">,</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span>
<span class="p">))</span>
</pre></div>
<pre class="example">
Device = cuda; Time per batch: 0:00:00.008037 seconds
</pre>
<p>So, it takes less than a second compared to 12 seconds. Interestingly, I kept getting a CUDA out of memory error when I had seaborn and matplotlib imported at the top. I don't know what the conflict is, but it's something to watch out for.</p>
<p>You can write device agnostic code which will automatically use CUDA if it's enabled like so at the beginning of your code:</p>
<div class="highlight">
<pre><span></span><span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">"cuda:0"</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">"cpu"</span><span class="p">)</span>
</pre></div>
<p>Then whenever you get a new Tensor or Module it won't copy if they are already on the desired device (it will just return the original object).</p>
<div class="highlight">
<pre><span></span><span class="nb">input</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">MyModule</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
</pre></div>
<p>First a short test to make sure this works.</p>
<div class="highlight">
<pre><span></span><span class="n">train_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">train_batches</span><span class="p">)</span>
<span class="n">train_small</span> <span class="o">=</span> <span class="p">[</span><span class="n">train_iter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="n">test_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">test_batches</span><span class="p">)</span>
<span class="n">test_small</span> <span class="o">=</span> <span class="p">[</span><span class="n">test_iter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="n">outcome</span> <span class="o">=</span> <span class="n">train</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">train_small</span><span class="p">,</span> <span class="n">test_small</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">"cuda"</span><span class="p">)</span>
</pre></div>
<pre class="example">
Epoch: 1/30 Training loss: 0.43 Test Loss: 2.63 Test Accuracy: 0.56
</pre></div>
</div>
<div class="outline-2" id="outline-container-org55d39c7">
<h2 id="org55d39c7">Train the Model</h2>
<div class="outline-text-2" id="text-org55d39c7">
<p>Okay, so now for a long one. Time to get some coffee.</p>
</div>
<div class="outline-3" id="outline-container-org0280dd0">
<h3 id="org0280dd0">Setup CUDA If It's Available</h3>
<div class="outline-text-3" id="text-org0280dd0">
<div class="highlight">
<pre><span></span><span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">"cuda"</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span> <span class="k">else</span> <span class="s2">"cpu"</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org9e2e221">
<h3 id="org9e2e221">The Training</h3>
<div class="outline-text-3" id="text-org9e2e221">
<div class="highlight">
<pre><span></span><span class="o">%</span><span class="n">time</span>

<span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">NLLLoss</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
<span class="n">outcome</span> <span class="o">=</span> <span class="n">train_only</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">train_batches</span><span class="p">,</span>
                     <span class="n">epochs</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
<span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="s2">"cat_dog_model.pth"</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgbb33302">
<h3 id="orgbb33302">The Accuracy</h3>
<div class="outline-text-3" id="text-orgbb33302">
<div class="highlight">
<pre><span></span><span class="n">test_loss</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">accuracy</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">accuracies</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">test_losses</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">test_batches</span><span class="p">:</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">),</span> <span class="n">labels</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">test_loss</span> <span class="o">+=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">probabilities</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="n">top_p</span><span class="p">,</span> <span class="n">top_class</span> <span class="o">=</span> <span class="n">probabilities</span><span class="o">.</span><span class="n">topk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">equals</span> <span class="o">=</span> <span class="n">top_class</span> <span class="o">==</span> <span class="n">labels</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">*</span><span class="n">top_class</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">accuracy</span> <span class="o">+=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">equals</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">FloatTensor</span><span class="p">))</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">mean_accuracy</span> <span class="o">=</span> <span class="n">accuracy</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">test_batches</span><span class="p">)</span>
        <span class="n">test_losses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test_loss</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">test_batches</span><span class="p">))</span>
        <span class="n">accuracies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_accuracy</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">"Final Loss: </span><span class="si">{:.2f}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">test_losses</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Final Accuracy: </span><span class="si">{:.2f}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">accuracies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
<pre class="example">
Final Loss: 1.22
Final Accuracy: 0.64
</pre>
<p>So still not quite good enough.</p>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org89c696e">
<h2 id="org89c696e">Train Some More</h2>
<div class="outline-text-2" id="text-org89c696e">
<div class="highlight">
<pre><span></span><span class="n">outcome</span> <span class="o">=</span> <span class="n">train_only</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">train_batches</span><span class="p">,</span>
                     <span class="n">epochs</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
<span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="s2">"cat_dog_model.pth"</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">test_outcome</span> <span class="o">=</span> <span class="n">test_only</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">test_batches</span><span class="p">,</span> <span class="n">devicej</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">test_outcome</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
<pre class="example">
Test Loss        1.532174
Test Accuracy    0.630859
Name: 39, dtype: float64
</pre>
<p>So, it hasn't actually gotten better, if anything it got worse. Does this mean it's overfitting?</p>
</div>
</div>
<div class="outline-2" id="outline-container-org156f8bd">
<h2 id="org156f8bd">Another Model</h2>
<div class="outline-text-2" id="text-org156f8bd">
<p>I peeked at the solution notebook and it has fewer nodes in the first linear layer and adds dropout. Interestingly the lecture has more nodes in the first layer, but I'll try fewer first.</p>
</div>
<div class="outline-3" id="outline-container-orgd271ef3">
<h3 id="orgd271ef3">The Classifier</h3>
<div class="outline-text-3" id="text-orgd271ef3">
<div class="highlight">
<pre><span></span><span class="n">classifier</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">([</span>
                          <span class="p">(</span><span class="s2">"fully_connected_layer"</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">256</span><span class="p">)),</span>
                          <span class="p">(</span><span class="s1">'relu'</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()),</span>
                          <span class="p">(</span><span class="s2">"dropout"</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)),</span>
                          <span class="p">(</span><span class="s1">'fully_connected_2'</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
                          <span class="p">(</span><span class="s1">'output'</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">LogSoftmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                          <span class="p">]))</span>
<span class="n">model</span><span class="o">.</span><span class="n">classifier</span> <span class="o">=</span> <span class="n">classifier</span>
<span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
</pre></div>
<p>Note that I had to do the <code>model.to(device)</code> call again since I added the classifier. I think I could also have done <code>classifier.to(device)</code>, but this seemed to work.</p>
</div>
</div>
<div class="outline-3" id="outline-container-org1b6eee2">
<h3 id="org1b6eee2">More Parallelization</h3>
<div class="outline-text-3" id="text-org1b6eee2">
<p>I noticed on the <a href="https://pytorch.org/tutorials/beginner/blitz/data_parallel_tutorial.html">pytorch data parallelization</a> tutorial that they said you need to tell pytorch to use more than one GPU (if you want it to) so I'm going to try and add it here.</p>
<div class="highlight">
<pre><span></span><span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">device_count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Using </span><span class="si">{}</span><span class="s2"> GPUs"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">device_count</span><span class="p">()))</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">DataParallel</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Only 1 GPU available"</span><span class="p">)</span>
</pre></div>
<pre class="example">
Only 1 GPU available
</pre>
<p>Oh, well.</p>
</div>
</div>
<div class="outline-3" id="outline-container-org037a43e">
<h3 id="org037a43e">The Criterion and Optimizer</h3>
<div class="outline-text-3" id="text-org037a43e">
<p>The other notebook also used a slightly higher learning rate which I'll copy. It also managed to get 95% with one epoch, which is totally out of whack with what I'm seeing. I'll try it again.</p>
<div class="highlight">
<pre><span></span><span class="n">LEARNING_RATE</span> <span class="o">=</span> <span class="mf">0.003</span>
<span class="n">EPOCHS</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
<p>Our loss and optimizer.</p>
<div class="highlight">
<pre><span></span><span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">NLLLoss</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">LEARNING_RATE</span><span class="p">)</span>
</pre></div>
<p>Now train on one epoch.</p>
<div class="highlight">
<pre><span></span><span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="n">outcome</span> <span class="o">=</span> <span class="n">train_only</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">train_batches</span><span class="p">,</span>
                     <span class="n">epochs</span><span class="o">=</span><span class="n">EPOCHS</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
<span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="s2">"cat_dog_model.pth"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Training Time: </span><span class="si">{}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
</pre></div>
<pre class="example">
Training Time: 0:06:28.712052
</pre>
<div class="highlight">
<pre><span></span><span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="n">test_outcome</span> <span class="o">=</span> <span class="n">test_only</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">test_batches</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Test Time: </span><span class="si">{}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
</pre></div>
<pre class="example">
Test Time: 0:00:42.637106
</pre>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">test_outcome</span><span class="p">)</span>
</pre></div>
<pre class="example">
0.9776
</pre>
<p>Okay, so I changed the test_only function to use <code>model.eval</code> instead of <code>model.no_grad</code> like we were doing before and it went from 51% to 98%. Hmm…</p>
</div>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/nano/pytorch/part-7-loading-image-data/">Part 7 - Loading Image Data</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/nano/pytorch/part-7-loading-image-data/" rel="bookmark"><time class="published dt-published" datetime="2018-11-22T17:08:56-08:00" itemprop="datePublished" title="2018-11-22 17:08">2018-11-22 17:08</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/nano/pytorch/part-7-loading-image-data/#orgaf8f58c">Introduction</a></li>
<li><a href="posts/nano/pytorch/part-7-loading-image-data/#org06d1e95">Set Up</a></li>
<li><a href="posts/nano/pytorch/part-7-loading-image-data/#orgb96d5c3">The Data</a></li>
<li><a href="posts/nano/pytorch/part-7-loading-image-data/#orga3f88b9">Data Augmentation</a></li>
<li><a href="posts/nano/pytorch/part-7-loading-image-data/#orgfde9e82">A Naive Dropout model</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-orgaf8f58c">
<h2 id="orgaf8f58c">Introduction</h2>
<div class="outline-text-2" id="text-orgaf8f58c">
<p>This is from <a href="https://github.com/udacity/deep-learning-v2-pytorch.git">Udacity's Deep Learning Repository</a> which supports their Deep Learning Nanodegree.</p>
<p>So far we've been working with fairly artificial datasets that you wouldn't typically be using in real projects (28 x 28 pixels is very low resolution). Instead, you'll likely be dealing with full-sized images like you'd get from cameras. In this notebook, we'll look at how to load images and use them to train neural networks.</p>
<p>We'll be using a <a href="https://www.kaggle.com/c/dogs-vs-cats">dataset of cat and dog photos</a> available from Kaggle that was created to test whether a machine would be able to defeat the <a href="https://www.microsoft.com/en-us/research/publication/asirra-a-captcha-that-exploits-interest-aligned-manual-image-categorization/">Asirra</a> <a href="https://en.wikipedia.org/wiki/CAPTCHA">CAPTCHA</a> system by identifying whether an image had a cat or a dog.</p>
<p>We'll use this dataset to train a neural network that can differentiate between cats and dogs. These days it doesn't seem like a big accomplishment, but five years ago it was a serious challenge for computer vision systems.</p>
</div>
</div>
<div class="outline-2" id="outline-container-org06d1e95">
<h2 id="org06d1e95">Set Up</h2>
<div class="outline-text-2" id="text-org06d1e95"></div>
<div class="outline-3" id="outline-container-org5237a18">
<h3 id="org5237a18">Imports</h3>
<div class="outline-text-3" id="text-org5237a18"></div>
<div class="outline-4" id="outline-container-orga1947f5">
<h4 id="orga1947f5">PyPi</h4>
<div class="outline-text-4" id="text-orga1947f5">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span><span class="p">,</span> <span class="n">optim</span>
<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">transforms</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">pyplot</span>
<span class="kn">import</span> <span class="nn">seaborn</span>
<span class="kn">import</span> <span class="nn">torch</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgdcbf8e0">
<h4 id="orgdcbf8e0">Udacity Code</h4>
<div class="outline-text-4" id="text-orgdcbf8e0">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">nano.pytorch</span> <span class="kn">import</span> <span class="n">helper</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgb98ee54">
<h4 id="orgb98ee54">This Project</h4>
<div class="outline-text-4" id="text-orgb98ee54">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">neurotic.tangles.data_paths</span> <span class="kn">import</span> <span class="n">DataPathTwo</span>
<span class="kn">from</span> <span class="nn">neurotic.models.fashion</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DropoutModel</span><span class="p">,</span>
    <span class="n">train</span><span class="p">,</span>
    <span class="n">HyperParameters</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org249c174">
<h3 id="org249c174">Plotting</h3>
<div class="outline-text-3" id="text-org249c174">
<div class="highlight">
<pre><span></span><span class="n">get_python</span><span class="p">()</span><span class="o">.</span><span class="n">run_line_magic</span><span class="p">(</span><span class="s1">'matplotlib'</span><span class="p">,</span> <span class="s1">'inline'</span><span class="p">)</span>
<span class="n">get_python</span><span class="p">()</span><span class="o">.</span><span class="n">run_line_magic</span><span class="p">(</span><span class="s1">'config'</span><span class="p">,</span> <span class="s2">"InlineBackend.figure_format = 'retina'"</span><span class="p">)</span>

<span class="n">seaborn</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s2">"whitegrid"</span><span class="p">,</span>
            <span class="n">rc</span><span class="o">=</span><span class="p">{</span><span class="s2">"axes.grid"</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">"font.family"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"sans-serif"</span><span class="p">],</span>
                <span class="s2">"font.sans-serif"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"Latin Modern Sans"</span><span class="p">,</span> <span class="s2">"Lato"</span><span class="p">],</span>
                <span class="s2">"figure.figsize"</span><span class="p">:</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">)},</span>
            <span class="n">font_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orgb96d5c3">
<h2 id="orgb96d5c3">The Data</h2>
<div class="outline-text-2" id="text-orgb96d5c3">
<p>The easiest way to load image data is with <a href="http://pytorch.org/docs/master/torchvision/datasets.html#imagefolder"><code>datasets.ImageFolder</code></a> from <code>torchvision</code>. In general you'll use <code>ImageFolder</code> like so:</p>
<div class="highlight">
<pre><span></span><span class="n">dataset</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">ImageFolder</span><span class="p">(</span><span class="s1">'path/to/data'</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transforms</span><span class="p">)</span>
</pre></div>
<p>where <code>path/to/data</code> is the file path to the data directory and <code>transforms</code> is a list of processing steps built with the <a href="http://pytorch.org/docs/master/torchvision/transforms.html"><code>transforms</code></a> module from <code>torchvision</code>. ImageFolder expects the files and directories to be constructed like so:</p>
<pre class="example" id="orgd61df54">
root/dog/xxx.png
root/dog/xxy.png
root/dog/xxz.png

root/cat/123.png
root/cat/nsdf3.png
root/cat/asd932_.png
</pre>
<p>where each class has it's own directory (<code>cat</code> and <code>dog</code>) for the images. The images are then labeled with the class taken from the directory name. So here, the image <code>123.png</code> would be loaded with the class label <code>cat</code>. You can download the dataset already structured like this <a href="https://s3.amazonaws.com/content.udacity-data.com/nd089/Cat_Dog_data.zip">from here</a>. I've also split it into a training set and test set (note that the data-set is almost 600 Megabytes so make sure you have broadband if you want to download it).</p>
</div>
<div class="outline-3" id="outline-container-org4a2fb8d">
<h3 id="org4a2fb8d">Transforms</h3>
<div class="outline-text-3" id="text-org4a2fb8d">
<p>When you load in the data with <code>ImageFolder</code>, you'll need to define some transforms. For example, the images are different sizes but we'll need them to all be the same size for training. You can either resize them with <code>transforms.Resize()</code> or crop with <code>transforms.CenterCrop()</code>, <code>transforms.RandomResizedCrop()</code>, etc. We'll also need to convert the images to PyTorch tensors with <code>transforms.ToTensor()</code>. Typically you'll combine these transforms into a pipeline with <code>transforms.Compose()</code>, which accepts a list of transforms and runs them in sequence. It looks something like this to scale, then crop, then convert to a tensor:</p>
<div class="highlight">
<pre><span></span><span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span><span class="n">transforms</span><span class="o">.</span><span class="n">Resize</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
                                 <span class="n">transforms</span><span class="o">.</span><span class="n">CenterCrop</span><span class="p">(</span><span class="mi">224</span><span class="p">),</span>
                                 <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">()])</span>
</pre></div>
<p>There are plenty of transforms available, you should read through the <a href="http://pytorch.org/docs/master/torchvision/transforms.html">documentation</a>.</p>
</div>
</div>
<div class="outline-3" id="outline-container-orgb20dbc7">
<h3 id="orgb20dbc7">Data Loaders</h3>
<div class="outline-text-3" id="text-orgb20dbc7">
<p>With the <code>ImageFolder</code> loaded, you have to pass it to a <a href="http://pytorch.org/docs/master/data.html#torch.utils.data.DataLoader"><code>DataLoader</code></a>. The <code>DataLoader</code> takes a dataset (such as you would get from <code>ImageFolder</code>) and returns batches of images and the corresponding labels. You can set various parameters like the batch size and if the data is shuffled after each epoch.</p>
<div class="highlight">
<pre><span></span><span class="n">dataloader</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
<p>Here <code>dataloader</code> is a <a href="https://jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained">generator</a>. To get data out of it, you need to loop through it or convert it to an iterator and call <code>next()</code>.</p>
<p>Looping through it, get a batch on each loop:</p>
<div class="highlight">
<pre><span></span><span class="k">for</span> <span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">dataloader</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="c1"># Get one batch</span>
<span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">dataloader</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org5dd5edf">
<h3 id="org5dd5edf">Actually Load the Data</h3>
<div class="outline-text-3" id="text-org5dd5edf">
<p>Now we're going to actually do what we spoke of earlier.</p>
</div>
<div class="outline-4" id="outline-container-orgcf1da9f">
<h4 id="orgcf1da9f">Set the Path</h4>
<div class="outline-text-4" id="text-orgcf1da9f">
<p>This is where we set the folder path. The actual data-set was a zipped folder on an amazon web server so I downloaded it by hand instead of using the <code>datasets</code> method like we did with the earlier data sets.</p>
<div class="highlight">
<pre><span></span><span class="n">train_path</span> <span class="o">=</span> <span class="n">DataPathTwo</span><span class="p">(</span><span class="n">folder_key</span><span class="o">=</span><span class="s2">"CAT_DOG_TRAIN"</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgb9a5f2c">
<h4 id="orgb9a5f2c">Transform the Data</h4>
<div class="outline-text-4" id="text-orgb9a5f2c">
<p>We're going to:</p>
<ul class="org-ul">
<li>resize the images (passing in a single number means it will match the smallest side (height or width))</li>
<li>crop the images (CenterCrop means it measures from the center, and a single value makes it a square)</li>
<li>convert the image to a tensor</li>
</ul>
<div class="highlight">
<pre><span></span><span class="n">transformations</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span><span class="n">transforms</span><span class="o">.</span><span class="n">Resize</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
                                      <span class="n">transforms</span><span class="o">.</span><span class="n">CenterCrop</span><span class="p">(</span><span class="mi">224</span><span class="p">),</span>
                                      <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">()])</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgd8c01bd">
<h4 id="orgd8c01bd">Load the Training Image Folder</h4>
<div class="outline-text-4" id="text-orgd8c01bd">
<div class="highlight">
<pre><span></span><span class="n">training</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">ImageFolder</span><span class="p">(</span><span class="n">train_path</span><span class="o">.</span><span class="n">folder</span><span class="p">,</span>
                                <span class="n">transform</span><span class="o">=</span><span class="n">transformations</span><span class="p">)</span>
</pre></div>
<p>The <code>ImageLoader</code> couldn't handle the <code>~</code> in my path so I changed the <code>DataPathTwo</code> to expand it by default. Now we'll load the data into an iterator that hands out batches of 32 images.</p>
<div class="highlight">
<pre><span></span><span class="n">training_batches</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span>
    <span class="n">training</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
    <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
<p>Now we can test the data loader.</p>
<div class="highlight">
<pre><span></span><span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">training_batches</span><span class="p">))</span>
<span class="n">plot</span> <span class="o">=</span> <span class="n">helper</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
<div class="figure" id="org08d54f7">
<p><img alt="test_loader.png" src="posts/nano/pytorch/part-7-loading-image-data/test_loader.png"></p>
</div>
<p>If it worked we should see something that looks like a dog or a cat in a square image.</p>
</div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-orga3f88b9">
<h2 id="orga3f88b9">Data Augmentation</h2>
<div class="outline-text-2" id="text-orga3f88b9">
<p>A common strategy for training neural networks is to introduce randomness in the input data itself. For example, you can randomly rotate, mirror, scale, and/or crop your images during training. This will help your network generalize as it's seeing the same images but in different locations, with different sizes, in different orientations, etc.</p>
<p>To randomly rotate, scale and crop, then flip your images you would define your transforms like this:</p>
<div class="highlight">
<pre><span></span><span class="n">train_transforms</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span><span class="n">transforms</span><span class="o">.</span><span class="n">RandomRotation</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
                                       <span class="n">transforms</span><span class="o">.</span><span class="n">RandomResizedCrop</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
                                       <span class="n">transforms</span><span class="o">.</span><span class="n">RandomHorizontalFlip</span><span class="p">(),</span>
                                       <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
                                       <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> 
                                                            <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])])</span>
</pre></div>
<p>You'll also typically want to normalize images with <code>transforms.Normalize</code>. You pass in a list of means and list of standard deviations, then the color channels are normalized like so</p>
<div class="highlight">
<pre><span></span><span class="nb">input</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean</span><span class="p">[</span><span class="n">channel</span><span class="p">])</span> <span class="o">/</span> <span class="n">std</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span>
</pre></div>
<p>Subtracting <code>mean</code> centers the data around zero and dividing by <code>std</code> squishes the values to be between -1 and 1. Normalizing helps keep the network work weights near zero which in turn makes backpropagation more stable. Without normalization, networks will tend to fail to learn.</p>
<p>You can find a list of all the available transforms <a href="http://pytorch.org/docs/0.3.0/torchvision/transforms.html">here</a> . When you're testing however, you'll want to use images that aren't altered (except you'll need to normalize the same way). So, for validation/test images, you'll typically just resize and crop.</p>
<p>The Training Transformations:</p>
<ul class="org-ul">
<li>RandomRotation: takes the maximum number of degrees to rotate the image</li>
<li>RandomResizedCrop: scales and crops the image - we're only passing in the expected output size</li>
<li>RandomHorizontalFlip: 50-50 chance that the image will be flipped horizontally.</li>
</ul>
<div class="highlight">
<pre><span></span><span class="n">means</span> <span class="o">=</span> <span class="n">deviations</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>
<span class="n">train_transforms</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span><span class="n">transforms</span><span class="o">.</span><span class="n">RandomRotation</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
                                       <span class="n">transforms</span><span class="o">.</span><span class="n">RandomResizedCrop</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
                                       <span class="n">transforms</span><span class="o">.</span><span class="n">RandomHorizontalFlip</span><span class="p">(),</span>
                                       <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
                                       <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> 
                                                            <span class="n">deviations</span><span class="p">)])</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">test_transforms</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span><span class="n">transforms</span><span class="o">.</span><span class="n">Resize</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
                                      <span class="n">transforms</span><span class="o">.</span><span class="n">CenterCrop</span><span class="p">(</span><span class="mi">224</span><span class="p">),</span>
                                      <span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
                                      <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">mean</span><span class="o">=</span><span class="n">means</span><span class="p">,</span>
                                                           <span class="n">std</span><span class="o">=</span><span class="n">deviations</span><span class="p">)])</span>
</pre></div>
<p>Now we create the testing and training data. Although I loaded the training data before, I didn't apply all the extra transforms so I'm going to re-load it</p>
<div class="highlight">
<pre><span></span><span class="n">test_path</span> <span class="o">=</span> <span class="n">DataPathTwo</span><span class="p">(</span><span class="n">folder_key</span><span class="o">=</span><span class="s2">"CAT_DOG_TEST"</span><span class="p">)</span>
<span class="n">train_data</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">ImageFolder</span><span class="p">(</span><span class="n">train_path</span><span class="o">.</span><span class="n">folder</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">train_transforms</span><span class="p">)</span>
<span class="n">test_data</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">ImageFolder</span><span class="p">(</span><span class="n">test_path</span><span class="o">.</span><span class="n">folder</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">test_transforms</span><span class="p">)</span>

<span class="n">train_batches</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
<span class="n">test_batches</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">test_data</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
</pre></div>
<p>Here are the first four images in the training set after they were transformed.</p>
<div class="highlight">
<pre><span></span><span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">train_batches</span><span class="p">)</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">pyplot</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="n">helper</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
</pre></div>
<div class="figure" id="org51e5ad7">
<p><img alt="transformed_train_image.png" src="posts/nano/pytorch/part-7-loading-image-data/transformed_train_image.png"></p>
</div>
<p>At this point you should be able to load data for training and testing. Now, you should try building a network that can classify cats vs dogs. This is quite a bit more complicated than before with the MNIST and Fashion-MNIST datasets. To be honest, you probably won't get it to work with a fully-connected network, no matter how deep. These images have three color channels and at a higher resolution (so far you've seen 28x28 images which are tiny).</p>
</div>
</div>
<div class="outline-2" id="outline-container-orgfde9e82">
<h2 id="orgfde9e82">A Naive Dropout model</h2>
<div class="outline-text-2" id="text-orgfde9e82">
<p>I'm just going to try and apply the Dropout Model from the FASHION-MNIST examples and see what happens. But, it turns out that the input shapes are wrong. Each image is a (3, 100, 100) tensor.</p>
<div class="highlight">
<pre><span></span><span class="n">parameters</span> <span class="o">=</span> <span class="n">HyperParameters</span><span class="p">()</span>
<span class="n">parameters</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">*</span> <span class="mi">100</span>
<span class="n">parameters</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">DropoutModel</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
<span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">NLLLoss</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">)</span>
<span class="n">outcomes</span> <span class="o">=</span> <span class="n">train</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
                 <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span>
                 <span class="n">criterion</span><span class="o">=</span><span class="n">criterion</span><span class="p">,</span>
                 <span class="n">train_batches</span><span class="o">=</span><span class="n">train_batches</span><span class="p">,</span>
                 <span class="n">test_batches</span><span class="o">=</span><span class="n">test_batches</span><span class="p">)</span>
</pre></div>
<p>Okay, this doesn't work, there's a mismatched size problem that I can't figure out. Maybe I'll come back to this.</p>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/nano/pytorch/part-6-saving-and-loading-models/">Part 6 - Saving and Loading Models</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/nano/pytorch/part-6-saving-and-loading-models/" rel="bookmark"><time class="published dt-published" datetime="2018-11-21T17:38:28-08:00" itemprop="datePublished" title="2018-11-21 17:38">2018-11-21 17:38</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/nano/pytorch/part-6-saving-and-loading-models/#orgd2c939b">Introduction</a></li>
<li><a href="posts/nano/pytorch/part-6-saving-and-loading-models/#orgd9d2a84">Set Up</a></li>
<li><a href="posts/nano/pytorch/part-6-saving-and-loading-models/#org224906c">The Data</a></li>
<li><a href="posts/nano/pytorch/part-6-saving-and-loading-models/#org41b9c56">Training the Network</a></li>
<li><a href="posts/nano/pytorch/part-6-saving-and-loading-models/#orgb5bc6f4">Saving and loading networks</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-orgd2c939b">
<h2 id="orgd2c939b">Introduction</h2>
<div class="outline-text-2" id="text-orgd2c939b">
<p>This is from <a href="https://github.com/udacity/deep-learning-v2-pytorch.git">Udacity's Deep Learning Repository</a> which supports their Deep Learning Nanodegree.</p>
<p>In this notebook we're going to look at how to save and load models with PyTorch.</p>
</div>
</div>
<div class="outline-2" id="outline-container-orgd9d2a84">
<h2 id="orgd9d2a84">Set Up</h2>
<div class="outline-text-2" id="text-orgd9d2a84"></div>
<div class="outline-3" id="outline-container-orgd31fd02">
<h3 id="orgd31fd02">Imports</h3>
<div class="outline-text-3" id="text-orgd31fd02"></div>
<div class="outline-4" id="outline-container-orgd6aca04">
<h4 id="orgd6aca04">Python</h4>
<div class="outline-text-4" id="text-orgd6aca04">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org547f95e">
<h4 id="org547f95e">PyPi</h4>
<div class="outline-text-4" id="text-org547f95e">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">dotenv</span> <span class="kn">import</span> <span class="n">load_dotenv</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">pyplot</span>
<span class="kn">import</span> <span class="nn">seaborn</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">optim</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>
<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">transforms</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgcd75327">
<h4 id="orgcd75327">Nano Program</h4>
<div class="outline-text-4" id="text-orgcd75327">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">nano.pytorch</span> <span class="kn">import</span> <span class="n">helper</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgdb73a6d">
<h4 id="orgdb73a6d">This Project</h4>
<div class="outline-text-4" id="text-orgdb73a6d">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">neurotic.tangles.data_paths</span> <span class="kn">import</span> <span class="n">DataPathTwo</span>
<span class="kn">from</span> <span class="nn">fashion</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">label_decoder</span><span class="p">,</span>
    <span class="n">train</span><span class="p">,</span>
    <span class="n">DropoutModel</span><span class="p">,</span>
    <span class="n">HyperParameters</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orgfa753ca">
<h3 id="orgfa753ca">Plotting</h3>
<div class="outline-text-3" id="text-orgfa753ca">
<div class="highlight">
<pre><span></span><span class="n">get_python</span><span class="p">()</span><span class="o">.</span><span class="n">run_line_magic</span><span class="p">(</span><span class="s1">'matplotlib'</span><span class="p">,</span> <span class="s1">'inline'</span><span class="p">)</span>
<span class="n">get_python</span><span class="p">()</span><span class="o">.</span><span class="n">run_line_magic</span><span class="p">(</span><span class="s1">'config'</span><span class="p">,</span> <span class="s2">"InlineBackend.figure_format = 'retina'"</span><span class="p">)</span>
<span class="n">seaborn</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s2">"whitegrid"</span><span class="p">,</span>
            <span class="n">rc</span><span class="o">=</span><span class="p">{</span><span class="s2">"axes.grid"</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">"font.family"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"sans-serif"</span><span class="p">],</span>
                <span class="s2">"font.sans-serif"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"Latin Modern Sans"</span><span class="p">,</span> <span class="s2">"Lato"</span><span class="p">],</span>
                <span class="s2">"figure.figsize"</span><span class="p">:</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">)},</span>
            <span class="n">font_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org224906c">
<h2 id="org224906c">The Data</h2>
<div class="outline-text-2" id="text-org224906c">
<p>Once again we're going to use the <code>fashion-MNIST</code> data.</p>
</div>
<div class="outline-3" id="outline-container-org22da504">
<h3 id="org22da504">The Path</h3>
<div class="outline-text-3" id="text-org22da504">
<div class="highlight">
<pre><span></span><span class="n">path</span> <span class="o">=</span> <span class="n">DataPathTwo</span><span class="p">(</span><span class="n">folder_key</span><span class="o">=</span><span class="s2">"FASHION_MNIST"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">folder</span><span class="p">)</span>
</pre></div>
<pre class="example">
~/datasets/F_MNIST
</pre></div>
</div>
<div class="outline-3" id="outline-container-orge8c0e17">
<h3 id="orge8c0e17">Define a transform to normalize the data</h3>
<div class="outline-text-3" id="text-orge8c0e17">
<div class="highlight">
<pre><span></span><span class="n">transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span><span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
                                <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">((</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))])</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org01ef7c1">
<h3 id="org01ef7c1">Download and Load the Training Data</h3>
<div class="outline-text-3" id="text-org01ef7c1">
<div class="highlight">
<pre><span></span><span class="n">trainset</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">FashionMNIST</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">folder</span><span class="p">,</span> <span class="n">download</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">train</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">)</span>
<span class="n">training</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">trainset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span>
                                          <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org8322593">
<h3 id="org8322593">Download and Load the Test Data</h3>
<div class="outline-text-3" id="text-org8322593">
<div class="highlight">
<pre><span></span><span class="n">testset</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">FashionMNIST</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">folder</span><span class="p">,</span> <span class="n">download</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">train</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">)</span>
<span class="n">testing</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">testset</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
<p>Here's one of the images.</p>
<div class="highlight">
<pre><span></span><span class="n">image</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">trainloader</span><span class="p">))</span>
<span class="n">helper</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]);</span>
</pre></div>
<div class="figure" id="org003f414">
<p><img alt="image_one.png" src="posts/nano/pytorch/part-6-saving-and-loading-models/image_one.png"></p>
</div>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">label_decoder</span><span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()])</span>
</pre></div>
<pre class="example">
Sneaker
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-org41b9c56">
<h2 id="org41b9c56">Training the Network</h2>
<div class="outline-text-2" id="text-org41b9c56">
<p>I'm re-using the <code>DropoutModel</code> from the previous lesson about avoiding over-fitting using dropout. I'm also re-using the (somewhat updated) <code>train</code> function.</p>
<div class="highlight">
<pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">DropoutModel</span><span class="p">()</span>
<span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">NLLLoss</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">train</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">optimizer</span><span class="o">=</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="n">criterion</span><span class="p">,</span>
      <span class="n">train_batches</span><span class="o">=</span><span class="n">training</span><span class="p">,</span> <span class="n">test_batches</span><span class="o">=</span><span class="n">testing</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
<pre class="example">
Epoch: 1/30 Training loss: 2.41 Test Loss: 2.40 Test Accuracy: 0.09
Epoch: 2/30 Training loss: 2.41 Test Loss: 2.40 Test Accuracy: 0.09
</pre></div>
</div>
<div class="outline-2" id="outline-container-orgb5bc6f4">
<h2 id="orgb5bc6f4">Saving and loading networks</h2>
<div class="outline-text-2" id="text-orgb5bc6f4">
<p>Rather than re-training your model every time you want to use it you can instead save it an re-load the pre-trained model when you need it.</p>
<p>The parameters for PyTorch networks are stored in a model's <code>state_dict</code>.</p>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">"Our model: </span><span class="se">\n\n</span><span class="s2">"</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"The state dict keys: </span><span class="se">\n\n</span><span class="s2">"</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">state_dict</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</pre></div>
<pre class="example" id="org8cc393a">
Our model: 

 DropoutModel(
  (input_to_hidden): Linear(in_features=784, out_features=256, bias=True)
  (hidden_1_to_hidden_2): Linear(in_features=256, out_features=128, bias=True)
  (hidden_2_to_hidden_3): Linear(in_features=128, out_features=64, bias=True)
  (hidden_3_to_output): Linear(in_features=64, out_features=10, bias=True)
  (dropout): Dropout(p=0.2)
) 

The state dict keys: 

 odict_keys(['input_to_hidden.weight', 'input_to_hidden.bias', 'hidden_1_to_hidden_2.weight', 'hidden_1_to_hidden_2.bias', 'hidden_2_to_hidden_3.weight', 'hidden_2_to_hidden_3.bias', 'hidden_3_to_output.weight', 'hidden_3_to_output.bias'])
</pre>
<p>The simplest thing to do is simply save the state dict with <a href="https://pytorch.org/docs/stable/torch.html?highlight=save#torch.save"><code>torch.save</code></a>, which uses python's <a href="https://docs.python.org/3.6/library/pickle.html">pickle</a> to serialze the settings. PyTorch has <a href="https://pytorch.org/docs/stable/notes/serialization.html#recommend-saving-models">an explanation</a> for why you would prefer saving the settings instead of the entire model.</p>
<p>As an example, we can save our trained model's settings to a file <code>checkpoint.pth</code>.</p>
<div class="highlight">
<pre><span></span><span class="n">file_name</span> <span class="o">=</span> <span class="s2">"checkpoint.pth"</span>
<span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="n">file_name</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">check_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"File Size: </span><span class="si">{}</span><span class="s2"> K"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">check_path</span><span class="o">.</span><span class="n">stat</span><span class="p">()</span><span class="o">.</span><span class="n">st_size</span><span class="o">/</span><span class="mi">10</span><span class="o">**</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
<pre class="example">
File Size: 972.392 K
</pre>
<p>So it's almost a megabyte, better remember to clean it up later.</p>
<p>I couldn't find an explanation for the file-extension, but the pytorch documentation mentions that it's a convention to use <code>.pt</code> and <code>.pth</code> as extensions. I'm assuming <i>pt</i> is for PyTorch and the <i>h</i> is for hyper-parameters, but I'm not really sure that it's the case.</p>
<p>To load the model you can use <a href="https://pytorch.org/docs/stable/torch.html?highlight=torch%20load#torch.load"><code>torch.load</code></a>.</p>
<div class="highlight">
<pre><span></span><span class="n">state_dict</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">'checkpoint.pth'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">state_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</pre></div>
<pre class="example">
odict_keys(['input_to_hidden.weight', 'input_to_hidden.bias', 'hidden_1_to_hidden_2.weight', 'hidden_1_to_hidden_2.bias', 'hidden_2_to_hidden_3.weight', 'hidden_2_to_hidden_3.bias', 'hidden_3_to_output.weight', 'hidden_3_to_output.bias'])
</pre>
<p>To load the state-dict you take your instantiated but untrained model and call its <a href="https://pytorch.org/docs/stable/nn.html?highlight=load_state_dict#torch.nn.Module.load_state_dict"><code>load_state_dict</code></a> method.</p>
<div class="highlight">
<pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">state_dict</span><span class="p">)</span>
</pre></div>
<p>Seems pretty straightforward, but as usual it's a bit more complicated. Loading the state dict works only if the model architecture is exactly the same as the checkpoint architecture. Using a model with a different architecture, this fails.</p>
<div class="highlight">
<pre><span></span><span class="n">parameters</span> <span class="o">=</span> <span class="n">HyperParameters</span><span class="p">()</span>
<span class="n">parameters</span><span class="o">.</span><span class="n">hidden_layer_1</span> <span class="o">=</span> <span class="mi">400</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">bad_model</span> <span class="o">=</span> <span class="n">DropoutModel</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
<span class="c1"># This will throw an error because the tensor sizes are wrong!</span>
<span class="n">bad_model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">state_dict</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="ne">RuntimeError</span><span class="p">:</span> <span class="n">Error</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="n">loading</span> <span class="n">state_dict</span> <span class="k">for</span> <span class="n">DropoutModel</span><span class="p">:</span>
        <span class="n">size</span> <span class="n">mismatch</span> <span class="k">for</span> <span class="n">input_to_hidden</span><span class="o">.</span><span class="n">weight</span><span class="p">:</span> <span class="n">copying</span> <span class="n">a</span> <span class="n">param</span> <span class="n">of</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">400</span><span class="p">,</span> <span class="mi">784</span><span class="p">])</span> <span class="kn">from</span> <span class="nn">checkpoint</span><span class="p">,</span> <span class="n">where</span> <span class="n">the</span> <span class="n">shape</span> <span class="ow">is</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">784</span><span class="p">])</span> <span class="ow">in</span> <span class="n">current</span> <span class="n">model</span><span class="o">.</span>
        <span class="n">size</span> <span class="n">mismatch</span> <span class="k">for</span> <span class="n">input_to_hidden</span><span class="o">.</span><span class="n">bias</span><span class="p">:</span> <span class="n">copying</span> <span class="n">a</span> <span class="n">param</span> <span class="n">of</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">400</span><span class="p">])</span> <span class="kn">from</span> <span class="nn">checkpoint</span><span class="p">,</span> <span class="n">where</span> <span class="n">the</span> <span class="n">shape</span> <span class="ow">is</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">256</span><span class="p">])</span> <span class="ow">in</span> <span class="n">current</span> <span class="n">model</span><span class="o">.</span>
        <span class="n">size</span> <span class="n">mismatch</span> <span class="k">for</span> <span class="n">hidden_1_to_hidden_2</span><span class="o">.</span><span class="n">weight</span><span class="p">:</span> <span class="n">copying</span> <span class="n">a</span> <span class="n">param</span> <span class="n">of</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span> <span class="mi">400</span><span class="p">])</span> <span class="kn">from</span> <span class="nn">checkpoint</span><span class="p">,</span> <span class="n">where</span> <span class="n">the</span> <span class="n">shape</span> <span class="ow">is</span> <span class="n">torch</span><span class="o">.</span><span class="n">Size</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">])</span> <span class="ow">in</span> <span class="n">current</span> <span class="n">model</span><span class="o">.</span>
</pre></div>
<p>This means we need to rebuild the model exactly as it was when trained. Information about the model architecture needs to be saved in the checkpoint, along with the state dict. To do this, you build a dictionary with all the information you need to compeletely rebuild the model.</p>
<p>Originally the bad-model was just called 'model' and that seems to have messed up the state-dict so I'm going to re-use the one we made before.</p>
<div class="highlight">
<pre><span></span><span class="n">checkpoint</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'hyperparameters'</span><span class="p">:</span> <span class="n">HyperParameters</span><span class="p">,</span>
              <span class="s1">'state_dict'</span><span class="p">:</span> <span class="n">state_dict</span><span class="p">}</span>

<span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
</pre></div>
<p>Remember that this is using pickle under the hood so whatever you save has to be pickleable. It probably would be safer to use parameters instead of a settings object like I did, but I didn't know we were going to be doing this.</p>
<p>Here's a function to load checkpoint-files.</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">load_checkpoint</span><span class="p">(</span><span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">:</span>
    <span class="sd">"""Load the model checkpoint from disk</span>

<span class="sd">    Args:</span>
<span class="sd">     filepath: path to the saved checkpoint</span>
<span class="sd">    """</span>
    <span class="n">checkpoint</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">DropoutModel</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">[</span><span class="s2">"hyperparameters"</span><span class="p">])</span>
    <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">[</span><span class="s1">'state_dict'</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">model</span>
</pre></div>
<p>You can see from the function that the checkpoint is really just pickling a dictionary, and we can add any arbitrary things we want to it. I'm not really sure what it gives that using pickle directly doesn't have.</p>
<div class="highlight">
<pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">load_checkpoint</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
<pre class="example">
DropoutModel(
  (input_to_hidden): Linear(in_features=784, out_features=256, bias=True)
  (hidden_1_to_hidden_2): Linear(in_features=256, out_features=128, bias=True)
  (hidden_2_to_hidden_3): Linear(in_features=128, out_features=64, bias=True)
  (hidden_3_to_output): Linear(in_features=64, out_features=10, bias=True)
  (dropout): Dropout(p=0.2)
)
</pre>
<p>PyTorch has more about saving and loading models in <a href="https://pytorch.org/tutorials/beginner/saving_loading_models.html">their documentation</a>, including saving your model to continue training later (you need to save more than the model's settings).</p>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/nano/pytorch/part-5-inference-and-validation/">Part 5 - Inference and Validation</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/nano/pytorch/part-5-inference-and-validation/" rel="bookmark"><time class="published dt-published" datetime="2018-11-19T22:19:42-08:00" itemprop="datePublished" title="2018-11-19 22:19">2018-11-19 22:19</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/nano/pytorch/part-5-inference-and-validation/#org33c6f4e">Introduction</a></li>
<li><a href="posts/nano/pytorch/part-5-inference-and-validation/#org36de369">Setup</a></li>
<li><a href="posts/nano/pytorch/part-5-inference-and-validation/#orga0d76db">The Data</a></li>
<li><a href="posts/nano/pytorch/part-5-inference-and-validation/#org844e4ad">The Model</a></li>
<li><a href="posts/nano/pytorch/part-5-inference-and-validation/#org6a01abd">Validation</a></li>
<li><a href="posts/nano/pytorch/part-5-inference-and-validation/#org7a824cf">Overfitting</a></li>
<li><a href="posts/nano/pytorch/part-5-inference-and-validation/#orgacfcb7e">The Dropout Model</a></li>
<li><a href="posts/nano/pytorch/part-5-inference-and-validation/#org8503ba2">Inference</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org33c6f4e">
<h2 id="org33c6f4e">Introduction</h2>
<div class="outline-text-2" id="text-org33c6f4e">
<p>This is from <a href="https://github.com/udacity/deep-learning-v2-pytorch.git">Udacity's Deep Learning Repository</a> which supports their Deep Learning Nanodegree.</p>
<p>Now that you have a trained network, you can use it for making predictions. This is typically called <b>inference</b>, a term borrowed from statistics. However, neural networks have a tendency to perform <b>too well</b> on the training data and aren't able to generalize to data that hasn't been seen before. This is called <b>overfitting</b> and it impairs inference performance. To test for overfitting while training, we measure the performance on data not in the training set called the <b>validation</b> set. We avoid overfitting through regularization such as dropout while monitoring the validation performance during training.</p>
</div>
</div>
<div class="outline-2" id="outline-container-org36de369">
<h2 id="org36de369">Setup</h2>
<div class="outline-text-2" id="text-org36de369"></div>
<div class="outline-3" id="outline-container-orgf373049">
<h3 id="orgf373049">Imports</h3>
<div class="outline-text-3" id="text-orgf373049"></div>
<div class="outline-4" id="outline-container-org08c7fd8">
<h4 id="org08c7fd8">Python</h4>
<div class="outline-text-4" id="text-org08c7fd8">
<div class="highlight">
<pre><span></span><span class="kn">import</span> <span class="nn">os</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgf562d93">
<h4 id="orgf562d93">PyPi</h4>
<div class="outline-text-4" id="text-orgf562d93">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">dotenv</span> <span class="kn">import</span> <span class="n">load_dotenv</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span><span class="p">,</span> <span class="n">optim</span>
<span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">transforms</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">pyplot</span>
<span class="kn">import</span> <span class="nn">pandas</span>
<span class="kn">import</span> <span class="nn">seaborn</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>
<span class="kn">import</span> <span class="nn">torch</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org0c99b6b">
<h4 id="org0c99b6b">The Nano Degree Repo</h4>
<div class="outline-text-4" id="text-org0c99b6b">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">nano.pytorch</span> <span class="kn">import</span> <span class="n">helper</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org0f47855">
<h4 id="org0f47855">This Project</h4>
<div class="outline-text-4" id="text-org0f47855">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">fashion</span> <span class="kn">import</span> <span class="n">label_decoder</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-orgf3c70ab">
<h3 id="orgf3c70ab">Plotting</h3>
<div class="outline-text-3" id="text-orgf3c70ab">
<div class="highlight">
<pre><span></span><span class="n">get_python</span><span class="p">()</span><span class="o">.</span><span class="n">run_line_magic</span><span class="p">(</span><span class="s1">'matplotlib'</span><span class="p">,</span> <span class="s1">'inline'</span><span class="p">)</span>
<span class="n">get_python</span><span class="p">()</span><span class="o">.</span><span class="n">run_line_magic</span><span class="p">(</span><span class="s1">'config'</span><span class="p">,</span> <span class="s2">"InlineBackend.figure_format = 'retina'"</span><span class="p">)</span>
<span class="n">seaborn</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s2">"whitegrid"</span><span class="p">,</span>
            <span class="n">rc</span><span class="o">=</span><span class="p">{</span><span class="s2">"axes.grid"</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">"font.family"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"sans-serif"</span><span class="p">],</span>
                <span class="s2">"font.sans-serif"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"Latin Modern Sans"</span><span class="p">,</span> <span class="s2">"Lato"</span><span class="p">],</span>
                <span class="s2">"figure.figsize"</span><span class="p">:</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">)},</span>
            <span class="n">font_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgd6c82d9">
<h3 id="orgd6c82d9">The Environment</h3>
<div class="outline-text-3" id="text-orgd6c82d9">
<div class="highlight">
<pre><span></span><span class="n">load_dotenv</span><span class="p">()</span>
<span class="n">DATA_PATH</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"FASHION_MNIST"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">DATA_PATH</span><span class="p">)</span>
</pre></div>
<pre class="example">
~/datasets/F_MNIST/
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-orga0d76db">
<h2 id="orga0d76db">The Data</h2>
<div class="outline-text-2" id="text-orga0d76db">
<p>We're going to load the dataset through torchvision but this time we'll be taking advantage of the test set which you can get by setting <code>train=False</code>.</p>
<p>The test set contains images just like the training set. Typically you'll see 10-20% of the original dataset held out for testing and validation with the rest being used for training.</p>
</div>
<div class="outline-3" id="outline-container-org6c99414">
<h3 id="org6c99414">Normalize the Data</h3>
<div class="outline-text-3" id="text-org6c99414">
<div class="highlight">
<pre><span></span><span class="n">means</span> <span class="o">=</span> <span class="n">spread</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span><span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
                                <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">spread</span><span class="p">)])</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org2f56a5f">
<h3 id="org2f56a5f">Training Data</h3>
<div class="outline-text-3" id="text-org2f56a5f">
<p>Once again we're going to use the <a href="https://github.com/zalandoresearch/fashion-mnist">Fashion MNIST</a> data set.</p>
<div class="highlight">
<pre><span></span><span class="n">training_set</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">FashionMNIST</span><span class="p">(</span><span class="n">DATA_PATH</span><span class="p">,</span>
                                     <span class="n">download</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                     <span class="n">train</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                     <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">training_batches</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">training_set</span><span class="p">,</span>
                                               <span class="n">batch_size</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span>
                                               <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org554ce41">
<h3 id="org554ce41">Test Data</h3>
<div class="outline-text-3" id="text-org554ce41">
<p>By setting <code>train=False</code> in the <code>FashionMNIST</code> constructor you implicitly get the test set.</p>
<div class="highlight">
<pre><span></span><span class="n">test_set</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">FashionMNIST</span><span class="p">(</span><span class="n">DATA_PATH</span><span class="p">,</span>
                                 <span class="n">download</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">train</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">test_batches</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">test_set</span><span class="p">,</span>
                                           <span class="n">batch_size</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span>
                                           <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org844e4ad">
<h2 id="org844e4ad">The Model</h2>
<div class="outline-text-2" id="text-org844e4ad">
<p>We're going to use the object-oriented approach instead of the pipeline that we used earlier. It's going to have three hidden layers and one output layer.</p>
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">HyperParameters</span><span class="p">:</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="mi">28</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">hidden_layer_1</span> <span class="o">=</span> <span class="mi">256</span>
    <span class="n">hidden_layer_2</span> <span class="o">=</span> <span class="mi">128</span>
    <span class="n">hidden_layer_3</span> <span class="o">=</span> <span class="mi">64</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">learning_rate</span> <span class="o">=</span> <span class="mf">0.003</span>
    <span class="n">epochs</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="n">dropout_probability</span> <span class="o">=</span> <span class="mf">0.2</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Classifier</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_to_hidden</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span>
                                         <span class="n">HyperParameters</span><span class="o">.</span><span class="n">hidden_layer_1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hidden_1_to_hidden_2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">hidden_layer_1</span><span class="p">,</span>
                                              <span class="n">HyperParameters</span><span class="o">.</span><span class="n">hidden_layer_2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hidden_2_to_hidden_3</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">hidden_layer_2</span><span class="p">,</span>
                                              <span class="n">HyperParameters</span><span class="o">.</span><span class="n">hidden_layer_3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hidden_3_to_output</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">hidden_layer_3</span><span class="p">,</span>
                                            <span class="n">HyperParameters</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="sd">"""One forward-pass through the network"""</span>
        <span class="c1"># make sure input tensor is flattened</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_to_hidden</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hidden_1_to_hidden_2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hidden_2_to_hidden_3</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hidden_3_to_output</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                          <span class="n">dim</span><span class="o">=</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">Classifier</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-org6a01abd">
<h2 id="org6a01abd">Validation</h2>
<div class="outline-text-2" id="text-org6a01abd">
<p>The goal of validation is to measure the model's performance on data that isn't part of the training set. Performance here is up to the developer to define though. Typically this is just accuracy, the percentage of classes the network predicted correctly. Other options are <a href="https://en.wikipedia.org/wiki/Precision_and_recall#Definition_(classification_context)">precision and recall</a>, top-5 error rate, etc.. We'll focus on accuracy here. First we'll do a forward pass with one batch from the test set.</p>
<p>Get the next image-batch.</p>
<div class="highlight">
<pre><span></span><span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">test_batches</span><span class="p">))</span>
</pre></div>
<p>Now we'll get the model probabilities for the image-batch.</p>
<div class="highlight">
<pre><span></span><span class="n">probabilities</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">model</span><span class="p">(</span><span class="n">images</span><span class="p">))</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">shape</span> <span class="o">=</span> <span class="n">probabilities</span><span class="o">.</span><span class="n">shape</span>
<span class="nb">print</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
<span class="n">rows</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">shape</span>
<span class="k">assert</span> <span class="n">rows</span> <span class="o">==</span> <span class="mi">64</span>
<span class="k">assert</span> <span class="n">columns</span> <span class="o">==</span> <span class="mi">10</span>
</pre></div>
<pre class="example">
torch.Size([64, 10])
</pre>
<p>With the probabilities, we can get the most likely class using the <a href="https://pytorch.org/docs/stable/torch.html#torch.topk"><code>probabilities.topk</code></a> method. This returns the \(k\) highest values in the tensor. Since we just want the most likely class, we can use <code>probabilities.topk(1)</code>. This returns a tuple of the top-\(k\) values and the top-\(k\) indices. If the highest value is the fifth element, we'll get back 4 as the index.</p>
<div class="highlight">
<pre><span></span><span class="n">top_p</span><span class="p">,</span> <span class="n">top_class</span> <span class="o">=</span> <span class="n">probabilities</span><span class="o">.</span><span class="n">topk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
<p>Look at the most likely classes for the first 10 examples</p>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">top_class</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:])</span>
</pre></div>
<pre class="example" id="org87d8dd3">
tensor([[6],
        [6],
        [6],
        [6],
        [6],
        [6],
        [6],
        [6],
        [5],
        [6]])
</pre>
<p>Now we can check if the predicted classes match the labels. This is simple to do by equating <code>top_class</code> and <code>labels</code>, but we have to be careful of the shapes. Here <code>top_class</code> is a 2D tensor with shape <code>(64, 1)</code> while <code>labels</code> is 1D with shape <code>(64)</code>. To get the equality to work out the way we want, <code>top_class</code> and <code>labels</code> must have the same shape.</p>
<p>If we do this:</p>
<div class="highlight">
<pre><span></span><span class="n">equals</span> <span class="o">=</span> <span class="n">top_class</span> <span class="o">==</span> <span class="n">labels</span>
</pre></div>
<p><code>equals</code> will have shape <code>(64, 64)</code>, try it yourself. What it's doing is comparing the one element in each row of <code>top_class</code> with each element in <code>labels</code> which returns 64 True/False boolean values for each row, so we have to reshape the labels first using the <code>view</code> method.</p>
<div class="highlight">
<pre><span></span><span class="n">equals</span> <span class="o">=</span> <span class="n">top_class</span> <span class="o">==</span> <span class="n">labels</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">*</span><span class="n">top_class</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
<p>Now we need to calculate the percentage of correct predictions. <code>equals</code> has binary values, either 0 or 1. This means that if we just sum up all the values and divide by the number of values, we get the percentage of correct predictions. This is the same operation as taking the mean, so we can get the accuracy with a call to <code>torch.mean</code>. If only it was that simple. If you try <code>torch.mean(equals)</code>, you'll get an error.</p>
<div class="highlight">
<pre><span></span><span class="ne">RuntimeError</span><span class="p">:</span> <span class="n">mean</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">implemented</span> <span class="k">for</span> <span class="nb">type</span> <span class="n">torch</span><span class="o">.</span><span class="n">ByteTensor</span>
</pre></div>
<p>This happens because <code>equals</code> has type <code>torch.ByteTensor</code> but <code>torch.mean</code> isn't implemented for tensors with that type. So we'll need to convert <code>equals</code> to a float tensor. Note that when we take <code>torch.mean</code> it returns a scalar tensor, to get the actual value as a float we'll need to do <code>accuracy.item()</code>.</p>
<div class="highlight">
<pre><span></span><span class="n">accuracy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">equals</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">FloatTensor</span><span class="p">))</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'Accuracy: </span><span class="si">{</span><span class="n">accuracy</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s1">%'</span><span class="p">)</span>
</pre></div>
<pre class="example">
Accuracy: 10.9375%
</pre>
<p>The network is untrained so it's making random guesses and we should see an accuracy around 10%. Now let's train our network and include our validation pass so we can measure how well the network is performing on the test set. Since we're not updating our parameters in the validation pass, we can speed up our code by turning off gradients using <code>torch.no_grad()</code>:</p>
<div class="highlight">
<pre><span></span><span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
    <span class="c1"># validation pass here</span>
    <span class="k">for</span> <span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">testloader</span><span class="p">:</span>
</pre></div>
<p>Implement the validation loop below and print out the total accuracy after the loop. You can largely copy and paste the code from above, but I suggest typing it in because writing it out yourself is essential for building the skill. In general you'll always learn more by typing it rather than copy-pasting. You should be able to get an accuracy above 80%.</p>
<p>The <code>train_losses</code> and <code>test_losses</code> are kept for plotting later on.</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">criterion</span><span class="p">):</span>
    <span class="n">train_losses</span><span class="p">,</span> <span class="n">test_losses</span><span class="p">,</span> <span class="n">accuracies</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">epochs</span><span class="p">):</span>
        <span class="n">running_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">training_batches</span><span class="p">:</span>        
            <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
            <span class="c1"># images = images.view(images.shape[0], -1)</span>
            <span class="n">log_probabilities</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">log_probabilities</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
            <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
            <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
            <span class="n">running_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>        
        <span class="k">else</span><span class="p">:</span>
            <span class="n">test_loss</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">accuracy</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">test_batches</span><span class="p">:</span>
                    <span class="c1"># images = images.view(images.shape[0], -1)</span>
                    <span class="n">log_probabilities</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
                    <span class="n">test_loss</span> <span class="o">+=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">log_probabilities</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
                    <span class="n">probabilities</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">log_probabilities</span><span class="p">)</span>
                    <span class="n">top_p</span><span class="p">,</span> <span class="n">top_class</span> <span class="o">=</span> <span class="n">probabilities</span><span class="o">.</span><span class="n">topk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">equals</span> <span class="o">=</span> <span class="n">top_class</span> <span class="o">==</span> <span class="n">labels</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">*</span><span class="n">top_class</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">accuracy</span> <span class="o">+=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">equals</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">FloatTensor</span><span class="p">))</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">mean_accuracy</span> <span class="o">=</span> <span class="n">accuracy</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">test_batches</span><span class="p">)</span>
            <span class="n">train_losses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">running_loss</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">training_batches</span><span class="p">))</span>
            <span class="n">test_losses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test_loss</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">test_batches</span><span class="p">))</span>
            <span class="n">accuracies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_accuracy</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"Epoch: </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epoch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">HyperParameters</span><span class="o">.</span><span class="n">epochs</span><span class="p">),</span>
                  <span class="s2">"Training loss: </span><span class="si">{:.2f}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">train_losses</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                  <span class="s2">"Test Loss: </span><span class="si">{:.2f}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">test_losses</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                  <span class="s2">"Test Accuracy: </span><span class="si">{:.2f}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mean_accuracy</span><span class="p">)),</span>
    <span class="k">return</span> <span class="n">train_losses</span><span class="p">,</span> <span class="n">test_losses</span><span class="p">,</span> <span class="n">accuracies</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">Classifier</span><span class="p">()</span>
<span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">NLLLoss</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">)</span>

<span class="n">train_losses_0</span><span class="p">,</span> <span class="n">test_losses_0</span><span class="p">,</span> <span class="n">accuracies_0</span> <span class="o">=</span> <span class="n">train</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">criterion</span><span class="p">)</span>
</pre></div>
<pre class="example" id="org8ef2c37">
Epoch: 1/30 Training loss: 0.51 Test Loss: 0.43 Test Accuracy: 0.84
Epoch: 2/30 Training loss: 0.39 Test Loss: 0.42 Test Accuracy: 0.85
Epoch: 3/30 Training loss: 0.35 Test Loss: 0.38 Test Accuracy: 0.86
Epoch: 4/30 Training loss: 0.33 Test Loss: 0.38 Test Accuracy: 0.86
Epoch: 5/30 Training loss: 0.32 Test Loss: 0.37 Test Accuracy: 0.87
Epoch: 6/30 Training loss: 0.30 Test Loss: 0.37 Test Accuracy: 0.87
Epoch: 7/30 Training loss: 0.29 Test Loss: 0.38 Test Accuracy: 0.87
Epoch: 8/30 Training loss: 0.28 Test Loss: 0.38 Test Accuracy: 0.87
Epoch: 9/30 Training loss: 0.28 Test Loss: 0.39 Test Accuracy: 0.87
Epoch: 10/30 Training loss: 0.27 Test Loss: 0.38 Test Accuracy: 0.87
Epoch: 11/30 Training loss: 0.26 Test Loss: 0.37 Test Accuracy: 0.87
Epoch: 12/30 Training loss: 0.25 Test Loss: 0.38 Test Accuracy: 0.88
Epoch: 13/30 Training loss: 0.25 Test Loss: 0.38 Test Accuracy: 0.88
Epoch: 14/30 Training loss: 0.24 Test Loss: 0.36 Test Accuracy: 0.88
Epoch: 15/30 Training loss: 0.24 Test Loss: 0.40 Test Accuracy: 0.88
Epoch: 16/30 Training loss: 0.23 Test Loss: 0.39 Test Accuracy: 0.88
Epoch: 17/30 Training loss: 0.23 Test Loss: 0.39 Test Accuracy: 0.88
Epoch: 18/30 Training loss: 0.22 Test Loss: 0.42 Test Accuracy: 0.87
Epoch: 19/30 Training loss: 0.22 Test Loss: 0.45 Test Accuracy: 0.87
Epoch: 20/30 Training loss: 0.22 Test Loss: 0.38 Test Accuracy: 0.88
Epoch: 21/30 Training loss: 0.21 Test Loss: 0.38 Test Accuracy: 0.89
Epoch: 22/30 Training loss: 0.20 Test Loss: 0.42 Test Accuracy: 0.88
Epoch: 23/30 Training loss: 0.21 Test Loss: 0.41 Test Accuracy: 0.88
Epoch: 24/30 Training loss: 0.20 Test Loss: 0.42 Test Accuracy: 0.88
Epoch: 25/30 Training loss: 0.20 Test Loss: 0.42 Test Accuracy: 0.88
Epoch: 26/30 Training loss: 0.19 Test Loss: 0.43 Test Accuracy: 0.89
Epoch: 27/30 Training loss: 0.19 Test Loss: 0.44 Test Accuracy: 0.88
Epoch: 28/30 Training loss: 0.19 Test Loss: 0.43 Test Accuracy: 0.88
Epoch: 29/30 Training loss: 0.19 Test Loss: 0.41 Test Accuracy: 0.88
Epoch: 30/30 Training loss: 0.18 Test Loss: 0.41 Test Accuracy: 0.88
</pre>
<div class="highlight">
<pre><span></span><span class="n">train_losses_0</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">train_losses_0</span><span class="p">)</span>
<span class="n">accuracies_0</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">accuracies_0</span><span class="p">)</span>
<span class="n">test_losses_0</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">test_losses_0n</span><span class="p">)</span>
</pre></div>
<p>What do our outcomes look like?</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">print_best</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">pandas</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">decimals</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
               <span class="n">minimum</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">"""Print a table of the best and last outcomes</span>

<span class="sd">    Args:</span>
<span class="sd">     data: the source of the information</span>
<span class="sd">     label: what to put in the headline</span>
<span class="sd">     decimals: how many decimal places to use</span>
<span class="sd">     minimum: whether we want the lowest score (vs the highest)</span>
<span class="sd">    """</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"|</span><span class="si">{}</span><span class="s2">| Value|"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"|-+-|"</span><span class="p">)</span>
    <span class="n">best</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">if</span> <span class="n">minimum</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">best_index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()</span> <span class="k">if</span> <span class="n">minimum</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"|Best|{{:.</span><span class="si">{}</span><span class="s2">f}}|"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">best</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"|Best Location|</span><span class="si">{}</span><span class="s2">|"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">best_index</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"|Final|{{:.</span><span class="si">{}</span><span class="s2">f}}|"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">print_best</span><span class="p">(</span><span class="n">train_losses_0</span><span class="p">,</span> <span class="s2">"Training Loss"</span><span class="p">)</span>
</pre></div>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Training Loss</th>
<th class="org-right" scope="col">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Best</td>
<td class="org-right">0.180</td>
</tr>
<tr>
<td class="org-left">Best Location</td>
<td class="org-right">29</td>
</tr>
<tr>
<td class="org-left">Final</td>
<td class="org-right">0.180</td>
</tr>
</tbody>
</table>
<p>So our best training loss was the final one.</p>
<div class="highlight">
<pre><span></span><span class="n">print_best</span><span class="p">(</span><span class="n">test_losses_0</span><span class="p">,</span> <span class="s2">"Test Loss"</span><span class="p">)</span>
</pre></div>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Test Loss</th>
<th class="org-right" scope="col">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Best</td>
<td class="org-right">0.365</td>
</tr>
<tr>
<td class="org-left">Best Location</td>
<td class="org-right">13</td>
</tr>
<tr>
<td class="org-left">Final</td>
<td class="org-right">0.415</td>
</tr>
</tbody>
</table>
<p>While the test loss was best less than halfway through the epochs.</p>
<div class="highlight">
<pre><span></span><span class="n">print_best</span><span class="p">(</span><span class="n">accuracies_0</span><span class="p">,</span> <span class="s2">"Test Accuracy"</span><span class="p">,</span> <span class="n">minimum</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Test Accuracy</th>
<th class="org-right" scope="col">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Best</td>
<td class="org-right">0.854</td>
</tr>
<tr>
<td class="org-left">Best Location</td>
<td class="org-right">17</td>
</tr>
<tr>
<td class="org-left">Final</td>
<td class="org-right">0.851</td>
</tr>
</tbody>
</table>
<p>The accuracy also seems to have peaked almost at the halfway point, although the difference between the best and the final is pretty much just a rounding difference.</p>
<div class="highlight">
<pre><span></span><span class="n">figure</span><span class="p">,</span> <span class="p">(</span><span class="n">axe_0</span><span class="p">,</span> <span class="n">axe_1</span><span class="p">)</span> <span class="o">=</span> <span class="n">pyplot</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">figure</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">"Train and Test Without Dropout"</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s2">"bold"</span><span class="p">)</span>
<span class="n">y_minimum</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># the top plot</span>
<span class="n">axe_0</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">"Accuracy"</span><span class="p">)</span>

<span class="c1"># the bottom plot</span>
<span class="n">axe_1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">"Epoch"</span><span class="p">)</span>
<span class="n">axe_1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">"Loss"</span><span class="p">)</span>

<span class="n">test_rolling</span> <span class="o">=</span> <span class="n">test_losses_0</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">axe_1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">epochs</span><span class="p">),</span> <span class="n">train_losses_0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">"Train"</span><span class="p">)</span>
<span class="n">axe_1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">epochs</span><span class="p">),</span> <span class="n">test_rolling</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">"Rolling Test"</span><span class="p">)</span>
<span class="n">axe_1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">epochs</span><span class="p">),</span> <span class="n">test_losses_0</span><span class="p">,</span> <span class="s2">"."</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">"Test"</span><span class="p">)</span>
<span class="n">axe_1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="n">y_minimum</span><span class="p">)</span>

<span class="n">axe_0</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="n">y_minimum</span><span class="p">)</span>
<span class="n">axe_0</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">accuracies_0</span><span class="p">)),</span> <span class="n">accuracies_0</span><span class="p">,</span> <span class="s2">"r"</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">"Mean Test Accuracy"</span><span class="p">)</span>
<span class="n">axe_0</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">HyperParameters</span><span class="o">.</span><span class="n">epochs</span><span class="p">))</span>
<span class="n">legend</span> <span class="o">=</span> <span class="n">axe</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
<div class="figure" id="orge5907fd">
<p><img alt="losses.png" src="posts/nano/pytorch/part-5-inference-and-validation/losses.png"></p>
</div>
<p>So, although the accuracy metric on the test set is pretty stable, the training loss keeps going down even as the test loss is creeping upwards. Does this imply that accuracy isn't the right metric? Log-loss differs from accuracy in that it doesn't just penalize you for what you got wrong, but also by how far you were wrong - so if you predict a high probability for the wrong label, you will get penalized more than if you predicted it but with a relatively lower probability, as opposed to accuracy which just use the binary right and wrong. So, even though our accuracy looks stable, the Log-Loss is getting worse because our model is making the same mistakes but it is getting more confident about those bad predictions. So, on to the next section where we look at one way to try and fix this.</p>
</div>
</div>
<div class="outline-2" id="outline-container-org7a824cf">
<h2 id="org7a824cf">Overfitting</h2>
<div class="outline-text-2" id="text-org7a824cf">
<p>If we look at the training and validation losses as we train the network, we can see a phenomenon known as overfitting.</p>
<p>The network learns the training set better and better, resulting in lower training losses. However, it starts having problems generalizing to data outside the training set leading to the validation loss increasing. The ultimate goal of any deep learning model is to make predictions on new data, so we should strive to get the lowest validation loss possible. One option is to use the version of the model with the lowest validation loss, here the one around 8-10 training epochs. This strategy is called <b>early-stopping</b>. In practice, you'd save the model frequently as you're training then later choose the model with the lowest validation loss.</p>
<p>The most common method to reduce overfitting (outside of early-stopping) is <a href="https://en.wikipedia.org/wiki/Dropout_(neural_networks)"><b>dropout</b></a>, where we randomly drop input units. This forces the network to share information between weights, increasing it's ability to generalize to new data. Adding dropout in PyTorch is straightforward using the <a href="https://pytorch.org/docs/stable/nn.html#torch.nn.Dropout"><code>nn.Dropout</code></a> module.</p>
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">Classifier</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">784</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc3</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc4</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

        <span class="c1"># Dropout module with 0.2 drop probability</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># make sure input tensor is flattened</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Now with dropout</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc2</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc3</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

        <span class="c1"># output so no dropout here</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc4</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span>
</pre></div>
<p>During training we want to use dropout to prevent overfitting, but during inference we want to use the entire network. So, we need to turn off dropout during validation, testing, and whenever we're using the network to make predictions. To do this, you use <code>model.eval()</code>. This sets the model to evaluation mode where the dropout probability is 0. You can turn dropout back on by setting the model to train mode with <code>model.train()</code>. In general, the pattern for the validation loop will look like this, where you turn off gradients, set the model to evaluation mode, calculate the validation loss and metric, then set the model back to train mode.</p>
<div class="highlight">
<pre><span></span><span class="c1"># Turn off gradients</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
    <span class="c1"># set model to evaluation mode</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

    <span class="c1"># validation pass here</span>
    <span class="k">for</span> <span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">testloader</span><span class="p">:</span>
        <span class="o">...</span>

<span class="c1"># set model back to train mode</span>
<span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-orgacfcb7e">
<h2 id="orgacfcb7e">The Dropout Model</h2>
<div class="outline-text-2" id="text-orgacfcb7e">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">DropoutModel</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">"""Model with dropout to prevent overfitting</span>

<span class="sd">    Args:</span>
<span class="sd">     hyperparameters: object with the hyper-parameter settings</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hyperparameters</span><span class="p">:</span> <span class="nb">object</span><span class="o">=</span><span class="n">HyperParameters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_to_hidden</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">hyperparameters</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span>
                                         <span class="n">hyperparameters</span><span class="o">.</span><span class="n">hidden_layer_1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hidden_1_to_hidden_2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">hyperparameters</span><span class="o">.</span><span class="n">hidden_layer_1</span><span class="p">,</span>
                                              <span class="n">hyperparameters</span><span class="o">.</span><span class="n">hidden_layer_2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hidden_2_to_hidden_3</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">hyperparameters</span><span class="o">.</span><span class="n">hidden_layer_2</span><span class="p">,</span>
                                              <span class="n">hyperparameters</span><span class="o">.</span><span class="n">hidden_layer_3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hidden_3_to_output</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">hyperparameters</span><span class="o">.</span><span class="n">hidden_layer_3</span><span class="p">,</span>
                                            <span class="n">hyperparameters</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>

        <span class="c1"># Dropout module with 0.2 drop probability</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">hyperparameters</span><span class="o">.</span><span class="n">dropout_probability</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="sd">"""One Forward pass through the network"""</span>
        <span class="c1"># make sure input tensor is flattened</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Now with dropout</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_to_hidden</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hidden_1_to_hidden_2</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hidden_2_to_hidden_3</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

        <span class="c1"># output so no dropout here</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hidden_3_to_output</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                             <span class="n">dim</span><span class="o">=</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">DropoutModel</span><span class="p">()</span>
<span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">NLLLoss</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">)</span>
<span class="n">train_loss_1</span><span class="p">,</span> <span class="n">test_loss_1</span><span class="p">,</span> <span class="n">accuracies_1</span> <span class="o">=</span> <span class="n">train</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">,</span> <span class="n">criterion</span><span class="p">)</span>
</pre></div>
<pre class="example" id="orgf060269">
Epoch: 1/30 Training loss: 0.60 Test Loss: 0.53 Test Accuracy: 0.81
Epoch: 2/30 Training loss: 0.49 Test Loss: 0.49 Test Accuracy: 0.83
Epoch: 3/30 Training loss: 0.45 Test Loss: 0.47 Test Accuracy: 0.84
Epoch: 4/30 Training loss: 0.43 Test Loss: 0.48 Test Accuracy: 0.83
Epoch: 5/30 Training loss: 0.43 Test Loss: 0.47 Test Accuracy: 0.84
Epoch: 6/30 Training loss: 0.41 Test Loss: 0.45 Test Accuracy: 0.85
Epoch: 7/30 Training loss: 0.40 Test Loss: 0.45 Test Accuracy: 0.85
Epoch: 8/30 Training loss: 0.40 Test Loss: 0.49 Test Accuracy: 0.84
Epoch: 9/30 Training loss: 0.40 Test Loss: 0.47 Test Accuracy: 0.83
Epoch: 10/30 Training loss: 0.39 Test Loss: 0.44 Test Accuracy: 0.85
Epoch: 11/30 Training loss: 0.38 Test Loss: 0.46 Test Accuracy: 0.85
Epoch: 12/30 Training loss: 0.38 Test Loss: 0.49 Test Accuracy: 0.83
Epoch: 13/30 Training loss: 0.38 Test Loss: 0.44 Test Accuracy: 0.85
Epoch: 14/30 Training loss: 0.37 Test Loss: 0.43 Test Accuracy: 0.85
Epoch: 15/30 Training loss: 0.38 Test Loss: 0.46 Test Accuracy: 0.85
Epoch: 16/30 Training loss: 0.37 Test Loss: 0.47 Test Accuracy: 0.85
Epoch: 17/30 Training loss: 0.37 Test Loss: 0.46 Test Accuracy: 0.85
Epoch: 18/30 Training loss: 0.37 Test Loss: 0.54 Test Accuracy: 0.82
Epoch: 19/30 Training loss: 0.37 Test Loss: 0.44 Test Accuracy: 0.86
Epoch: 20/30 Training loss: 0.37 Test Loss: 0.45 Test Accuracy: 0.85
Epoch: 21/30 Training loss: 0.36 Test Loss: 0.45 Test Accuracy: 0.85
Epoch: 22/30 Training loss: 0.35 Test Loss: 0.47 Test Accuracy: 0.85
Epoch: 23/30 Training loss: 0.36 Test Loss: 0.45 Test Accuracy: 0.86
Epoch: 24/30 Training loss: 0.36 Test Loss: 0.46 Test Accuracy: 0.85
Epoch: 25/30 Training loss: 0.35 Test Loss: 0.46 Test Accuracy: 0.85
Epoch: 26/30 Training loss: 0.35 Test Loss: 0.48 Test Accuracy: 0.85
Epoch: 27/30 Training loss: 0.35 Test Loss: 0.46 Test Accuracy: 0.86
Epoch: 28/30 Training loss: 0.35 Test Loss: 0.45 Test Accuracy: 0.85
Epoch: 29/30 Training loss: 0.35 Test Loss: 0.47 Test Accuracy: 0.86
Epoch: 30/30 Training loss: 0.35 Test Loss: 0.46 Test Accuracy: 0.86
</pre>
<div class="highlight">
<pre><span></span><span class="n">test_loss_1</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">test_loss_1</span><span class="p">)</span>
<span class="n">train_loss_1</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">train_loss_1</span><span class="p">)</span>
<span class="n">accuracies_1</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">accuracies_1</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">print_both</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">pandas</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">data_2</span><span class="p">:</span> <span class="n">pandas</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
               <span class="n">decimals</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">minimum</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">"""Prints both data sets side by side</span>

<span class="sd">    Args:</span>
<span class="sd">     data: the first data series</span>
<span class="sd">     data_2: the second data series</span>
<span class="sd">     label: something to identify the data sets</span>
<span class="sd">     decimals: the number of decimal places to use</span>
<span class="sd">     minimum: whether minimalization is the optimal</span>
<span class="sd">    """</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"|</span><span class="si">{}</span><span class="s2">|First|Second|"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">label</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"|-+-+-|"</span><span class="p">)</span>
    <span class="n">best</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">if</span> <span class="n">minimum</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">best_index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()</span> <span class="k">if</span> <span class="n">minimum</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
    <span class="n">best_2</span> <span class="o">=</span> <span class="n">data_2</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">if</span> <span class="n">minimum</span> <span class="k">else</span> <span class="n">data_2</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">best_index_2</span> <span class="o">=</span>  <span class="n">data_2</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()</span> <span class="k">if</span> <span class="n">minimum</span> <span class="k">else</span> <span class="n">data_2</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"|Best|{{:.</span><span class="si">{0}</span><span class="s2">f}}|{{:.</span><span class="si">{0}</span><span class="s2">f}}|"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">best</span><span class="p">,</span> <span class="n">best_2</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"|Best Location|</span><span class="si">{}</span><span class="s2">|</span><span class="si">{}</span><span class="s2">|"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">best_index</span><span class="p">,</span> <span class="n">best_index_2</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"|Final|{{:.</span><span class="si">{0}</span><span class="s2">f}}|{{:.</span><span class="si">{0}</span><span class="s2">f}}|"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">data_2</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">print_both</span><span class="p">(</span><span class="n">train_losses_0</span><span class="p">,</span> <span class="n">train_loss_1</span><span class="p">,</span> <span class="s2">"Training Loss"</span><span class="p">)</span>
</pre></div>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left">
<col class="org-right">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Training Loss</th>
<th class="org-right" scope="col">First</th>
<th class="org-right" scope="col">Second</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Best</td>
<td class="org-right">0.180</td>
<td class="org-right">0.347</td>
</tr>
<tr>
<td class="org-left">Best Location</td>
<td class="org-right">29</td>
<td class="org-right">29</td>
</tr>
<tr>
<td class="org-left">Final</td>
<td class="org-right">0.180</td>
<td class="org-right">0.347</td>
</tr>
</tbody>
</table>
<p>So the best loss in both the models was the last one, but our new model does considerably worse. Maybe you need more training when the dropout is used.</p>
<div class="highlight">
<pre><span></span><span class="n">print_both</span><span class="p">(</span><span class="n">test_losses_0</span><span class="p">,</span> <span class="n">test_loss_1</span><span class="p">,</span> <span class="s2">"Test Loss"</span><span class="p">)</span>
</pre></div>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left">
<col class="org-right">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Test Loss</th>
<th class="org-right" scope="col">First</th>
<th class="org-right" scope="col">Second</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Best</td>
<td class="org-right">0.365</td>
<td class="org-right">0.434</td>
</tr>
<tr>
<td class="org-left">Best Location</td>
<td class="org-right">13</td>
<td class="org-right">13</td>
</tr>
<tr>
<td class="org-left">Final</td>
<td class="org-right">0.415</td>
<td class="org-right">0.460</td>
</tr>
</tbody>
</table>
<p>Weirdly, they both peak at the same point in the epochs, also weirdly the test loss is still worse for the dropout model.</p>
<div class="highlight">
<pre><span></span><span class="n">print_both</span><span class="p">(</span><span class="n">accuracies_0</span><span class="p">,</span> <span class="n">accuracies_1</span><span class="p">,</span> <span class="s2">"Test Accuracy"</span><span class="p">,</span> <span class="n">minimum</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left">
<col class="org-right">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Test Accuracy</th>
<th class="org-right" scope="col">First</th>
<th class="org-right" scope="col">Second</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Best</td>
<td class="org-right">0.886</td>
<td class="org-right">0.859</td>
</tr>
<tr>
<td class="org-left">Best Location</td>
<td class="org-right">25</td>
<td class="org-right">18</td>
</tr>
<tr>
<td class="org-left">Final</td>
<td class="org-right">0.882</td>
<td class="org-right">0.859</td>
</tr>
</tbody>
</table>
<p>Our accuracy seems to peak at a little over half the epochs, but surprisingly, it also does quite a bit worse with dropout…</p>
<div class="highlight">
<pre><span></span><span class="n">figure</span><span class="p">,</span> <span class="p">(</span><span class="n">axe_top</span><span class="p">,</span> <span class="n">axe_bottom</span><span class="p">)</span> <span class="o">=</span> <span class="n">pyplot</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">figure</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span>
    <span class="s2">"Training and Test Loss with Dropout (p=</span><span class="si">{}</span><span class="s2">)"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">HyperParameters</span><span class="o">.</span><span class="n">dropout_probability</span><span class="p">),</span> <span class="n">weight</span><span class="o">=</span><span class="s2">"bold"</span><span class="p">)</span>
<span class="n">axe_bottom</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">"Epoch"</span><span class="p">)</span>
<span class="n">axe_bottom</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">"Loss"</span><span class="p">)</span>

<span class="n">rolling_loss</span> <span class="o">=</span> <span class="n">test_loss_1</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">rolling_loss_0</span> <span class="o">=</span> <span class="n">test_losses_0</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

<span class="n">axe_bottom</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">epochs</span><span class="p">),</span> <span class="n">rolling_loss</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">"Rolling Mean Test"</span><span class="p">)</span>
<span class="n">axe_bottom</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">epochs</span><span class="p">),</span> <span class="n">rolling_loss_0</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">"Rolling Mean Test No Dropout"</span><span class="p">)</span>
<span class="n">axe_bottom</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">epochs</span><span class="p">),</span> <span class="n">train_loss_1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">"Train"</span><span class="p">)</span>
<span class="n">axe_bottom</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">epochs</span><span class="p">),</span> <span class="n">test_loss_1</span><span class="p">,</span> <span class="s2">"g.-"</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">"Test"</span><span class="p">)</span>

<span class="n">accuracy_rolling</span> <span class="o">=</span> <span class="n">accuracies_1</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">accuracy_rolling_0</span> <span class="o">=</span> <span class="n">accuracies_0</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">axe_top</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">"Accuracy"</span><span class="p">)</span>
<span class="n">axe_top</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">accuracies_1</span><span class="p">)),</span> <span class="n">accuracy_rolling</span><span class="p">,</span> <span class="s2">"r"</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">axe_top</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">accuracies_0</span><span class="p">)),</span> <span class="n">accuracy_rolling_0</span><span class="p">,</span> <span class="s2">"b"</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">axe_top</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">accuracies_0</span><span class="p">)),</span> <span class="n">accuracies_0</span><span class="p">,</span> <span class="s2">"b."</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">"No Dropout"</span><span class="p">)</span>
<span class="n">axe_top</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">accuracies_1</span><span class="p">)),</span> <span class="n">accuracies_1</span><span class="p">,</span> <span class="s2">"r."</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">"With Dropout"</span><span class="p">)</span>
<span class="n">axe_top</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">HyperParameters</span><span class="o">.</span><span class="n">epochs</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="n">axe_top</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">legend</span> <span class="o">=</span> <span class="n">axe_bottom</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
<div class="figure" id="orgad4d5e6">
<p><img alt="dropout_losses.png" src="posts/nano/pytorch/part-5-inference-and-validation/dropout_losses.png"></p>
</div>
<p>So we seem to have helped the problem of the loss growing at the expense of overall performance. I'm not sure this is really the lesson we're supposed to take away from this. Maybe if we tried more epochs the dropout model would emerge victorious.</p>
</div>
</div>
<div class="outline-2" id="outline-container-org8503ba2">
<h2 id="org8503ba2">Inference</h2>
<div class="outline-text-2" id="text-org8503ba2">
<p>Now that the model is trained, we can use it for inference. We've done this before, but now we need to remember to set the model in inference mode with <code>model.eval()</code>. You'll also want to turn off autograd with the <code>torch.no_grad()</code> context.</p>
</div>
<div class="outline-3" id="outline-container-orge18185c">
<h3 id="orge18185c">Testing the Model</h3>
<div class="outline-text-3" id="text-orge18185c"></div>
<div class="outline-4" id="outline-container-org1cc41ce">
<h4 id="org1cc41ce">Get the Test Image</h4>
<div class="outline-text-4" id="text-org1cc41ce">
<div class="highlight">
<pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

<span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">test_batches</span><span class="p">)</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org7cc2b61">
<h4 id="org7cc2b61">Convert the 2D image to a 1D vector</h4>
<div class="outline-text-4" id="text-org7cc2b61">
<div class="highlight">
<pre><span></span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">784</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org739564f">
<h4 id="org739564f">Calculate the Class Probabilities (softmax) for the Image</h4>
<div class="outline-text-4" id="text-org739564f">
<p>We run the forward pass once with the gradient turned off to get our probabilities.</p>
<div class="highlight">
<pre><span></span><span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">probabilities</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org9e13701">
<h4 id="org9e13701">Plot the image and probabilities</h4>
<div class="outline-text-4" id="text-org9e13701">
<div class="highlight">
<pre><span></span><span class="n">helper</span><span class="o">.</span><span class="n">view_classify</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">),</span> <span class="n">probabilities</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">'Fashion'</span><span class="p">)</span>
</pre></div>
<div class="figure" id="orgd6829fb">
<p><img alt="test_image.png" src="posts/nano/pytorch/part-5-inference-and-validation/test_image.png"></p>
</div>
<div class="highlight">
<pre><span></span><span class="n">expected</span> <span class="o">=</span> <span class="n">label_decoder</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()]</span>
<span class="n">actual</span> <span class="o">=</span> <span class="n">label_decoder</span><span class="p">[</span><span class="n">probabilities</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Expected: </span><span class="si">{}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">expected</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Actual: </span><span class="si">{}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">actual</span><span class="p">))</span>
<span class="k">assert</span> <span class="n">expected</span> <span class="o">==</span> <span class="n">actual</span>
</pre></div>
<pre class="example">
Expected: Trouser
Actual: Trouser
</pre>
<p>So, it looks like we got it right this time.</p>
</div>
</div>
</div>
</div>
</div>
</article>
<article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article">
<header>
<h1 class="p-name entry-title"><a class="u-url" href="posts/nano/pytorch/part-4-fashion/">Part 4 - Classifying Fashion-MNIST</a></h1>
<div class="metadata">
<p class="byline author vcard"><span class="byline-name fn" itemprop="author">Cloistered Monkey</span></p>
<p class="dateline"><a href="posts/nano/pytorch/part-4-fashion/" rel="bookmark"><time class="published dt-published" datetime="2018-11-19T19:15:07-08:00" itemprop="datePublished" title="2018-11-19 19:15">2018-11-19 19:15</time></a></p>
</div>
</header>
<div class="e-content entry-content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="posts/nano/pytorch/part-4-fashion/#org15015d4">Introduction</a></li>
<li><a href="posts/nano/pytorch/part-4-fashion/#org7661fa8">Set Up</a></li>
<li><a href="posts/nano/pytorch/part-4-fashion/#org706a21a">The Data</a></li>
<li><a href="posts/nano/pytorch/part-4-fashion/#org64f3ef2">The Network</a></li>
</ul>
</div>
</div>
<div class="outline-2" id="outline-container-org15015d4">
<h2 id="org15015d4">Introduction</h2>
<div class="outline-text-2" id="text-org15015d4">
<p>This is from <a href="https://github.com/udacity/deep-learning-v2-pytorch.git">Udacity's Deep Learning Repository</a> which supports their Deep Learning Nanodegree.</p>
<p>This post uses the <a href="https://github.com/zalandoresearch/fashion-mnist">Fashion-MNIST dataset</a>, a set of article images from <a href="https://www.zalando.com/">Zalando</a>, a fashion retailer. It is meant to be a drop-in replacement for the MNIST dataset. The dataset was created because some people the consider original MNIST too easy, with classical machine learning algorithms achieving better than 97% accuracy. The dataset keeps the 10 classes, but now instead of digits they represent clothing types.</p>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-right">
<col class="org-left"></colgroup>
<thead>
<tr>
<th class="org-right" scope="col">Label</th>
<th class="org-left" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0</td>
<td class="org-left">T-shirt/top</td>
</tr>
<tr>
<td class="org-right">1</td>
<td class="org-left">Trouser</td>
</tr>
<tr>
<td class="org-right">2</td>
<td class="org-left">Pullover</td>
</tr>
<tr>
<td class="org-right">3</td>
<td class="org-left">Dress</td>
</tr>
<tr>
<td class="org-right">4</td>
<td class="org-left">Coat</td>
</tr>
<tr>
<td class="org-right">5</td>
<td class="org-left">Sandal</td>
</tr>
<tr>
<td class="org-right">6</td>
<td class="org-left">Shirt</td>
</tr>
<tr>
<td class="org-right">7</td>
<td class="org-left">Sneaker</td>
</tr>
<tr>
<td class="org-right">8</td>
<td class="org-left">Bag</td>
</tr>
<tr>
<td class="org-right">9</td>
<td class="org-left">Ankle boot</td>
</tr>
</tbody>
</table>
<div class="highlight">
<pre><span></span><span class="n">descriptions</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"T-shirt/top"</span><span class="p">,</span>
                <span class="s2">"Trouser"</span><span class="p">,</span>
                <span class="s2">"Pullover"</span><span class="p">,</span>
                <span class="s2">"Dress"</span><span class="p">,</span>
                <span class="s2">"Coat"</span><span class="p">,</span>
                <span class="s2">"Sandal"</span><span class="p">,</span>
                <span class="s2">"Shirt"</span><span class="p">,</span>
                <span class="s2">"Sneaker"</span><span class="p">,</span>
                <span class="s2">"Bag"</span><span class="p">,</span>
                <span class="s2">"Ankle boot"</span><span class="p">,</span>
                <span class="p">)</span>

<span class="n">label_decoder</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">descriptions</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-org7661fa8">
<h2 id="org7661fa8">Set Up</h2>
<div class="outline-text-2" id="text-org7661fa8"></div>
<div class="outline-3" id="outline-container-org76f1365">
<h3 id="org76f1365">Imports</h3>
<div class="outline-text-3" id="text-org76f1365"></div>
<div class="outline-4" id="outline-container-orge4c2d9d">
<h4 id="orge4c2d9d">Python Standard Library</h4>
<div class="outline-text-4" id="text-orge4c2d9d">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-org90a408b">
<h4 id="org90a408b">PyPi</h4>
<div class="outline-text-4" id="text-org90a408b">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">torchvision</span> <span class="kn">import</span> <span class="n">datasets</span><span class="p">,</span> <span class="n">transforms</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">nn</span><span class="p">,</span> <span class="n">optim</span>
<span class="kn">import</span> <span class="nn">seaborn</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>
</pre></div>
</div>
</div>
<div class="outline-4" id="outline-container-orgbb763a4">
<h4 id="orgbb763a4">The Udacity Code</h4>
<div class="outline-text-4" id="text-orgbb763a4">
<div class="highlight">
<pre><span></span><span class="kn">from</span> <span class="nn">nano.pytorch</span> <span class="kn">import</span> <span class="n">helper</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-3" id="outline-container-org9331b75">
<h3 id="org9331b75">Plotting</h3>
<div class="outline-text-3" id="text-org9331b75">
<div class="highlight">
<pre><span></span><span class="n">get_ipython</span><span class="p">()</span><span class="o">.</span><span class="n">run_line_magic</span><span class="p">(</span><span class="s1">'matplotlib'</span><span class="p">,</span> <span class="s1">'inline'</span><span class="p">)</span>
<span class="n">get_ipython</span><span class="p">()</span><span class="o">.</span><span class="n">run_line_magic</span><span class="p">(</span><span class="s1">'config'</span><span class="p">,</span> <span class="s2">"InlineBackend.figure_format = 'retina'"</span><span class="p">)</span>
<span class="n">seaborn</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s2">"whitegrid"</span><span class="p">,</span>
            <span class="n">rc</span><span class="o">=</span><span class="p">{</span><span class="s2">"axes.grid"</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s2">"font.family"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"sans-serif"</span><span class="p">],</span>
                <span class="s2">"font.sans-serif"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"Latin Modern Sans"</span><span class="p">,</span> <span class="s2">"Lato"</span><span class="p">],</span>
                <span class="s2">"figure.figsize"</span><span class="p">:</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">)},</span>
            <span class="n">font_scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="outline-2" id="outline-container-org706a21a">
<h2 id="org706a21a">The Data</h2>
<div class="outline-text-2" id="text-org706a21a"></div>
<div class="outline-3" id="outline-container-org695c1fc">
<h3 id="org695c1fc">Normalization</h3>
<div class="outline-text-3" id="text-org695c1fc">
<p>First, a transform to normalize the data.</p>
<div class="highlight">
<pre><span></span><span class="n">means</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">deviations</span> <span class="o">=</span> <span class="n">means</span>
<span class="n">transform</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span><span class="n">transforms</span><span class="o">.</span><span class="n">ToTensor</span><span class="p">(),</span>
                                <span class="n">transforms</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">deviations</span><span class="p">)])</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org490cdb1">
<h3 id="org490cdb1">Load The Data</h3>
<div class="outline-text-3" id="text-org490cdb1">
<p>First our training set.</p>
<div class="highlight">
<pre><span></span><span class="n">training</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">FashionMNIST</span><span class="p">(</span><span class="s1">'~/datasets/F_MNIST/'</span><span class="p">,</span>
                                 <span class="n">download</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">train</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">)</span>

<span class="n">training_batches</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">training</span><span class="p">,</span>
                                               <span class="n">batch_size</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span>
                                               <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
<pre class="example" id="orgc09234c">
Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-images-idx3-ubyte.gz
Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-labels-idx1-ubyte.gz
Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-images-idx3-ubyte.gz
Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-labels-idx1-ubyte.gz
Processing...
Done!
</pre>
<p>Now our test set.</p>
<div class="highlight">
<pre><span></span><span class="n">testing</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">FashionMNIST</span><span class="p">(</span><span class="s1">'~/datasets/F_MNIST/'</span><span class="p">,</span>
                                <span class="n">download</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">train</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">)</span>

<span class="n">test_batches</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">testing</span><span class="p">,</span>
                                           <span class="n">batch_size</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span>
                                           <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
<p>The data is apparently on a european amazon web-service server.</p>
<p>Let's take a look at one of the images.</p>
<div class="highlight">
<pre><span></span><span class="k">def</span> <span class="nf">show_next_image</span><span class="p">(</span><span class="n">data_set</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="sd">"""plots the next image</span>

<span class="sd">    Args:</span>
<span class="sd">     data_set: iterator to get the next image from</span>

<span class="sd">    Returns:</span>
<span class="sd">     image, label: the next items in the data set</span>
<span class="sd">    """</span>
    <span class="n">image</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">data_set</span><span class="p">)</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
    <span class="n">helper</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
    <span class="k">return</span> <span class="n">image</span><span class="p">,</span> <span class="n">label</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">with</span> <span class="n">seaborn</span><span class="o">.</span><span class="n">axes_style</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s2">"white"</span><span class="p">,</span> <span class="n">rc</span><span class="o">=</span><span class="p">{</span><span class="s2">"figure.figsize"</span><span class="p">:</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)}):</span>
    <span class="n">image</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">show_next_image</span><span class="p">(</span><span class="n">training_batches</span><span class="p">)</span>
</pre></div>
<div class="figure" id="org2ee9612">
<p><img alt="image.png" src="posts/nano/pytorch/part-4-fashion/image.png"></p>
</div>
<p>Every time I re-run this the image changes. That was originally just a blob.</p>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">label_decoder</span><span class="p">[</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()])</span>
</pre></div>
<pre class="example">
Sneaker
</pre></div>
</div>
</div>
<div class="outline-2" id="outline-container-org64f3ef2">
<h2 id="org64f3ef2">The Network</h2>
<div class="outline-text-2" id="text-org64f3ef2">
<p>Here you should define your network. As with MNIST, each image is 28x28 which is a total of 784 pixels, and there are 10 classes. You should include at least one hidden layer. We suggest you use ReLU activations for the layers and to return the logits or log-softmax from the forward pass. It's up to you how many layers you add and the size of those layers.</p>
</div>
<div class="outline-3" id="outline-container-orgbfb2869">
<h3 id="orgbfb2869">Hyper Parameters</h3>
<div class="outline-text-3" id="text-orgbfb2869">
<div class="highlight">
<pre><span></span><span class="k">class</span> <span class="nc">HyperParameters</span><span class="p">:</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="mi">28</span> <span class="o">*</span> <span class="mi">28</span>
    <span class="n">hidden_layer_1</span> <span class="o">=</span> <span class="mi">128</span>
    <span class="n">hidden_layer_2</span> <span class="o">=</span> <span class="mi">64</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">learning_rate</span> <span class="o">=</span> <span class="mf">0.005</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">epochs</span> <span class="o">=</span> <span class="mi">200</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org4710c66">
<h3 id="org4710c66">The Model</h3>
<div class="outline-text-3" id="text-org4710c66">
<div class="highlight">
<pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
    <span class="n">OrderedDict</span><span class="p">(</span>
        <span class="n">input_to_hidden</span><span class="o">=</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span>
                                  <span class="n">HyperParameters</span><span class="o">.</span><span class="n">hidden_layer_1</span><span class="p">),</span>
        <span class="n">activation_1</span><span class="o">=</span><span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(),</span>
        <span class="n">hidden_to_hidden</span><span class="o">=</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">hidden_layer_1</span><span class="p">,</span>
                                   <span class="n">HyperParameters</span><span class="o">.</span><span class="n">hidden_layer_2</span><span class="p">),</span>
        <span class="n">activation_2</span><span class="o">=</span><span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(),</span>
        <span class="n">hidden_to_output</span><span class="o">=</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">hidden_layer_2</span><span class="p">,</span>
                                   <span class="n">HyperParameters</span><span class="o">.</span><span class="n">outputs</span><span class="p">),</span>
        <span class="n">activation_out</span><span class="o">=</span><span class="n">nn</span><span class="o">.</span><span class="n">LogSoftmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">rows</span><span class="p">),</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-org9730196">
<h3 id="org9730196">The Optimizer and Loss</h3>
<div class="outline-text-3" id="text-org9730196">
<div class="highlight">
<pre><span></span><span class="n">criterion</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">NLLLoss</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="outline-3" id="outline-container-orgdbf0f23">
<h3 id="orgdbf0f23">Training</h3>
<div class="outline-text-3" id="text-orgdbf0f23">
<p>The process:</p>
<ul class="org-ul">
<li>Make a forward pass through the network to get the logits</li>
<li>Use the logits to calculate the loss</li>
<li>Perform a backward pass through the network with `loss.backward()` to calculate the gradients</li>
<li>Take a step with the optimizer to update the weights</li>
</ul>
<p>By adjusting the hyperparameters (hidden units, learning rate, etc), you should be able to get the training loss below 0.4.</p>
<div class="highlight">
<pre><span></span><span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">HyperParameters</span><span class="o">.</span><span class="n">epochs</span><span class="p">):</span>
    <span class="n">running_loss</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">training_batches</span><span class="p">:</span>
        <span class="c1"># some setup</span>
        <span class="c1">## Flatten the images</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">## Reset the optimizer</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>

        <span class="c1"># forward pass</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>

        <span class="c1"># back-propagation</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>

        <span class="c1"># take the next step</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
        <span class="n">running_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">epoch</span> <span class="o">%</span> <span class="mi">10</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Training loss: </span><span class="si">{</span><span class="n">running_loss</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">data_batches</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>
<pre class="example" id="orgf74d13b">
Training loss: 1.2992842076048414
Training loss: 0.4147487568385057
Training loss: 0.3563503011393903
Training loss: 0.31974349495793963
Training loss: 0.2909906929267495
Training loss: 0.2669587785135836
Training loss: 0.24693025264150298
Training loss: 0.22828677767661334
Training loss: 0.2111341437932525
Training loss: 0.19651830268662368
Training loss: 0.18078892016763498
Training loss: 0.1678272306934984
Training loss: 0.15590339134147427
Training loss: 0.1440456182614509
Training loss: 0.13368237831159188
Training loss: 0.1232291767592115
Training loss: 0.11354898248336462
Training loss: 0.104927517529299
Training loss: 0.09589472461912806
Training loss: 0.08939716171846589
</pre>
<p>Check out a prediction.</p>
<div class="highlight">
<pre><span></span><span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">test_batches</span><span class="p">)</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="n">image</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1"># Convert 2D image to 1D vector</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">resize_</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">784</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
    <span class="n">logits</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="n">probabilities</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
<div class="highlight">
<pre><span></span><span class="k">with</span> <span class="n">seaborn</span><span class="o">.</span><span class="n">axes_style</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="s2">"whitegrid"</span><span class="p">):</span>
    <span class="n">helper</span><span class="o">.</span><span class="n">view_classify</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">resize_</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">),</span> <span class="n">probabilities</span><span class="p">,</span>
                         <span class="n">version</span><span class="o">=</span><span class="s1">'Fashion'</span><span class="p">)</span>
</pre></div>
<div class="figure" id="orgb237d60">
<p><img alt="prediction_image.png" src="posts/nano/pytorch/part-4-fashion/prediction_image.png"></p>
</div>
<p>That looks pretty good to me.</p>
<div class="highlight">
<pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">label_decoder</span><span class="p">[</span><span class="n">label</span><span class="o">.</span><span class="n">item</span><span class="p">()])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">label_decoder</span><span class="p">[</span><span class="n">probabilities</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()])</span>
</pre></div>
<pre class="example">
Sandal
Sandal
</pre>
<p>So this time we got it right.</p>
<div class="highlight">
<pre><span></span><span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">label</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">break</span>
<span class="nb">print</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">resize_</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">784</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="n">probabilities</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">label_decoder</span><span class="p">[</span><span class="n">probabilities</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">label_decoder</span><span class="p">[</span><span class="n">label</span><span class="o">.</span><span class="n">item</span><span class="p">()])</span>
</pre></div>
<pre class="example">
10
Dress
Coat
</pre>
<p>Oops, look like we're still having problems.</p>
<div class="highlight">
<pre><span></span><span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">test_batches</span><span class="p">:</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">predicted</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">outputs</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">labels</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">correct</span> <span class="o">+=</span> <span class="p">(</span><span class="n">predicted</span> <span class="o">==</span> <span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">'Accuracy of the network on the test images: </span><span class="si">%d</span><span class="s1"> </span><span class="si">%%</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span>
    <span class="mi">100</span> <span class="o">*</span> <span class="n">correct</span> <span class="o">/</span> <span class="n">total</span><span class="p">))</span>
</pre></div>
<pre class="example">
Accuracy of the network on the test images: 88 %
</pre>
<p>Not bad, it could probably be tuned to do better, the loss hasn't stopped reducing, for instance, so maybe more epochs would help.</p>
<div class="highlight">
<pre><span></span><span class="n">class_correct</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="mf">0.</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="n">class_total</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="mf">0.</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"|Item|Accuracy (%)|"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"|-+-|"</span><span class="p">)</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">images</span><span class="p">,</span> <span class="n">labels</span> <span class="ow">in</span> <span class="n">test_batches</span><span class="p">:</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">predicted</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">predicted</span> <span class="o">==</span> <span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">class_correct</span><span class="p">[</span><span class="n">label</span><span class="o">.</span><span class="n">item</span><span class="p">()]</span> <span class="o">+=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">class_total</span><span class="p">[</span><span class="n">label</span><span class="o">.</span><span class="n">item</span><span class="p">()]</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'|</span><span class="si">{}</span><span class="s1">|</span><span class="si">{:.1f}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">label_decoder</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">class_correct</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">class_total</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
</pre></div>
<table border="2" cellpadding="6" cellspacing="0" frame="hsides" rules="groups">
<colgroup>
<col class="org-left">
<col class="org-right"></colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Item</th>
<th class="org-right" scope="col">Accuracy (%)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">T-shirt/top</td>
<td class="org-right">88.0</td>
</tr>
<tr>
<td class="org-left">Trouser</td>
<td class="org-right">97.5</td>
</tr>
<tr>
<td class="org-left">Pullover</td>
<td class="org-right">87.2</td>
</tr>
<tr>
<td class="org-left">Dress</td>
<td class="org-right">88.0</td>
</tr>
<tr>
<td class="org-left">Coat</td>
<td class="org-right">83.2</td>
</tr>
<tr>
<td class="org-left">Sandal</td>
<td class="org-right">97.4</td>
</tr>
<tr>
<td class="org-left">Shirt</td>
<td class="org-right">57.3</td>
</tr>
<tr>
<td class="org-left">Sneaker</td>
<td class="org-right">95.5</td>
</tr>
<tr>
<td class="org-left">Bag</td>
<td class="org-right">95.7</td>
</tr>
<tr>
<td class="org-left">Ankle boot</td>
<td class="org-right">95.6</td>
</tr>
</tbody>
</table>
<p>Generally it seems to do okay, but the shirt seems to have gotten worse than when I was using fewer epochs. I might be overfitting by putting so many epochs and if I were to improve it I would probably work on other hyper-parameters.</p>
</div>
</div>
</div>
</div>
</article>
</div>
<ul class="pager postindexpager clearfix">
<li class="previous"><a href="index-6.html" rel="prev">Newer posts</a></li>
<li class="next"><a href="index-4.html" rel="next">Older posts</a></li>
</ul>
<!--End of body content-->
<footer id="footer"><a href="http://creativecommons.org/licenses/by/4.0/" rel="license"><img alt="Creative Commons License" id="license-image" src="https://i.creativecommons.org/l/by/4.0/80x15.png" style="border-width:0"></a>This work is licensed under a <a href="http://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>. <a href="mailto:necromuralist@protonmail.com">Cloistered Monkey</a> - Powered by <a href="https://getnikola.com" rel="nofollow">Nikola</a></footer>
</div>
</div>
<script src="assets/js/all-nocdn.js"></script>
<script>

    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
</script>
</body>
</html>
